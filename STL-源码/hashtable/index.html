<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>hashtable 源码分析 | Cu1universe</title><meta name="keywords" content="STL, hashtable"><meta name="author" content="Cu1"><meta name="copyright" content="Cu1"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="hashtable前言:hashtable 实现一个关联容器, 其在插入, 删除等操作都可以做到 O(1) 实现 哈希表概念哈希方法 直接定址法：取关键字或关键字的某个线性函数值为散列地址。（这种散列函数叫做自身函数）  数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。  平方取中法：取关键字平方后的中间几位为哈希地址。通常在选">
<meta property="og:type" content="article">
<meta property="og:title" content="hashtable 源码分析">
<meta property="og:url" content="https://cu1universe.cn/STL-%E6%BA%90%E7%A0%81/hashtable/index.html">
<meta property="og:site_name" content="Cu1universe">
<meta property="og:description" content="hashtable前言:hashtable 实现一个关联容器, 其在插入, 删除等操作都可以做到 O(1) 实现 哈希表概念哈希方法 直接定址法：取关键字或关键字的某个线性函数值为散列地址。（这种散列函数叫做自身函数）  数字分析法：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。  平方取中法：取关键字平方后的中间几位为哈希地址。通常在选">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s4.ax1x.com/2022/02/14/H6o0n1.jpg">
<meta property="article:published_time" content="2022-04-25T16:00:00.000Z">
<meta property="article:modified_time" content="2022-04-26T07:42:11.725Z">
<meta property="article:author" content="Cu1">
<meta property="article:tag" content="STL, hashtable">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s4.ax1x.com/2022/02/14/H6o0n1.jpg"><link rel="shortcut icon" href="https://s4.ax1x.com/2022/02/25/bEauvT.jpg"><link rel="canonical" href="https://cu1universe.cn/STL-%E6%BA%90%E7%A0%81/hashtable/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'hashtable 源码分析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-26 15:42:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="/css/custom.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/font_3206210_f2vpakpfd7l.css"  media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Cu1ii/BlogDebris@main/CDN/CSS/css.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s4.ax1x.com/2022/02/14/H6o0n1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">30</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">16</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Cu1universe</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">hashtable 源码分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-25T16:00:00.000Z" title="发表于 2022-04-26 00:00:00">2022-04-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-26T07:42:11.725Z" title="更新于 2022-04-26 15:42:11">2022-04-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/STL-%E6%BA%90%E7%A0%81/">STL 源码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="hashtable 源码分析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/STL-%E6%BA%90%E7%A0%81/hashtable/#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p><code>hashtable</code> 实现一个关联容器, 其在插入, 删除等操作都可以做到 <code>O(1)</code> 实现</p>
<h2 id="哈希表概念"><a href="#哈希表概念" class="headerlink" title="哈希表概念"></a>哈希表概念</h2><h3 id="哈希方法"><a href="#哈希方法" class="headerlink" title="哈希方法"></a>哈希方法</h3><ol>
<li><p><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值为散列地址。（这种散列函数叫做自身函数）</p>
</li>
<li><p><strong>数字分析法</strong>：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</p>
</li>
<li><p><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。</p>
</li>
<li><p><strong>折叠法</strong>：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。</p>
</li>
<li><p><strong>随机数法</strong> </p>
</li>
<li><p><strong>除留余数法</strong>：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。</p>
</li>
</ol>
<p><em>hashtable解决冲突的办法就是开链.</em></p>
<h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><p>哈希表的冲突处理也有很多种.</p>
<ol>
<li>开放定址法<ul>
<li>线性探测 : 本来的位置被占有(冲突), 重新再往后找到第一个有空的位置插入进去</li>
<li>二次探测 : 本来的位置被占有(冲突), 每次有冲突就平方一次重新查找</li>
</ul>
</li>
<li>开链 : 本来的位置被占有(冲突), 形成一个链表插入到链表中</li>
</ol>
<p><strong>装载因子 : 装入表中的元素 / 表的实际大小.</strong> 装载因子越大说明冲突的可能性就越大. </p>
<h2 id="hashtable-分析"><a href="#hashtable-分析" class="headerlink" title="hashtable 分析"></a>hashtable 分析</h2><p><strong>hashtable 前置声明</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_const_iterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="hashtable-基础定义"><a href="#hashtable-基础定义" class="headerlink" title="hashtable 基础定义"></a>hashtable 基础定义</h3><p><code>hashtable</code> 采用开链法来处理 <code>hash</code> 冲突, 所以需要有一个桶 <code>bucket</code> 以及每一个节点 <code>node</code></p>
<p><strong>桶 bucket:</strong> 定义的哈希表的小大, 采用 <code>vector </code> 为桶的容器</p>
<p>关于桶的, 通常采用质数来作为桶的大小. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">53</span>,         <span class="number">97</span>,           <span class="number">193</span>,         <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">  <span class="number">1543</span>,       <span class="number">3079</span>,         <span class="number">6151</span>,        <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">  <span class="number">49157</span>,      <span class="number">98317</span>,        <span class="number">196613</span>,      <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">  <span class="number">1572869</span>,    <span class="number">3145739</span>,      <span class="number">6291469</span>,     <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">  <span class="number">50331653</span>,   <span class="number">100663319</span>,    <span class="number">201326611</span>,   <span class="number">402653189</span>, <span class="number">805306457</span>, </span><br><span class="line">  <span class="number">1610612741</span>, <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在后续的 <code>sgi_STL</code> 版本后, 会根据编译器版本以及平台, 选择不同的质数数量以更好的适应不同平台.</p>
<p>由于涉及到 hashtable 后续的扩容问题, 所以提供了 <code> unsigned long __stl_next_prime(unsigned long n)</code> 函数来找到一个满足条件的质数. </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_next_prime(<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* first = __stl_prime_list;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* pos = <span class="built_in">lower_bound</span>(first, last, n);</span><br><span class="line">  <span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关于扩容:</strong> 在这里设计者依旧采用了一个通过经验得到的判断,  当桶 <code>bucket</code> 中元素容量 &gt; 当前桶的大小时, 就要在上述的质数数组中寻找第一个不小于元素容量的质数重新作为桶的大小</p>
<p><strong>节点 node:</strong> 在桶的每一个位置采用链表的结构进行存储, 所以节点为链表节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __hashtable_node* next;</span><br><span class="line">  Value val;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure>

<h3 id="hashtable-迭代器"><a href="#hashtable-迭代器" class="headerlink" title="hashtable 迭代器"></a>hashtable 迭代器</h3><p><code>hashtable</code> 迭代器是 <code>forward_iterator_tag</code> 类型, 正向迭代器, 所以不提供回退的功能, 也就是说它没有重载 <code>operator--</code></p>
<p><code>__hashtable_const_iterator</code> 和 <code>__hashtable_iterator</code> 除了内部数据设置为 const 外, 其他结构都是相同的, 这里只对后者进行分析</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;  hashtable;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">          iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn,  ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">          const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;	<span class="comment">// 正向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">  node* cur;		<span class="comment">// 定义节点</span></span><br><span class="line">  hashtable* ht;	<span class="comment">// 定义哈希表指针</span></span><br><span class="line"></span><br><span class="line">  __hashtable_iterator(node* n, hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123;&#125;</span><br><span class="line">  __hashtable_iterator() &#123;&#125;</span><br><span class="line">  <span class="comment">// 重载指针</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line">	<span class="comment">// 重在++, 因为是正向迭代器, 所以没有--</span></span><br><span class="line">  iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">  iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于 <code>hashtable</code>  采用的是开链法来处理哈希冲突, 所以迭代器在找完一条链之后, 如何再进行 <code>operator++</code>, 这时就需要回到 <code>hashtable</code> , 所以在 hashtable 迭代器中需要有一个指向 <code>hashtable</code> 的指针</p>
<h3 id="hashtable-1"><a href="#hashtable-1" class="headerlink" title="hashtable"></a>hashtable</h3><p><strong>hashtable 类型定义</strong></p>
<p>模板参数含义:</p>
<ol>
<li>Value: 节点的实值类型</li>
<li>Key:    节点的键值类型</li>
<li>HashFcn: hash function 的类型</li>
<li>ExtractKey: 从节点中取出键值的方法 (函数或者仿函数)</li>
<li>EqualKey: 判断键值是否相同的方法 (函数或者仿函数)</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">  <span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>            size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>         difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type*       pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp;       reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里返回的都是仿函数</span></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hash; &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> equals; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 这里定义的都是函数或者仿函数</span></span><br><span class="line">  hasher hash;</span><br><span class="line">  key_equal equals;</span><br><span class="line">  ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line"></span><br><span class="line">  vector&lt;node*,Alloc&gt; buckets;	<span class="comment">// 以vector作为桶, node*</span></span><br><span class="line">  size_type num_elements;		<span class="comment">// 哈希表中元素个数的计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; iterator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器定义为友元</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  __<span class="title">hashtable_iterator</span>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  __<span class="title">hashtable_const_iterator</span>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>构造与析构函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 构造函数, 没有定义默认构造函数</span></span><br><span class="line">  <span class="built_in">hashtable</span>(size_type n, <span class="keyword">const</span> HashFcn&amp;  hf,<span class="keyword">const</span> EqualKey&amp;   eql,<span class="keyword">const</span> ExtractKey&amp; ext)</span><br><span class="line">    : <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(ext), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hashtable</span>(size_type n, <span class="keyword">const</span> HashFcn&amp;  hf, <span class="keyword">const</span> EqualKey&amp;   eql)</span><br><span class="line">    : <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">hashtable</span>(<span class="keyword">const</span> hashtable&amp; ht)</span><br><span class="line">    : <span class="built_in">hash</span>(ht.hash), <span class="built_in">equals</span>(ht.equals), <span class="built_in">get_key</span>(ht.get_key), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">copy_from</span>(ht);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">hashtable</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>基本属性获取</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_elements; &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换, 并不是交换所有数据, 只是交换了其指针指向和个数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(hashtable&amp; ht)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    __STD::<span class="built_in">swap</span>(hash, ht.hash);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(equals, ht.equals);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(get_key, ht.get_key);</span><br><span class="line">    buckets.<span class="built_in">swap</span>(ht.buckets);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(num_elements, ht.num_elements);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (size_type n = <span class="number">0</span>; n &lt; buckets.<span class="built_in">size</span>(); ++n)</span><br><span class="line">    	<span class="comment">// 从头遍历桶, 如果有不空的链表存在, 就返回该链表的第一个元素</span></span><br><span class="line">      <span class="keyword">if</span> (buckets[n])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(buckets[n], <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 没有元素就返回end.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// end返回0</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>, <span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type n = <span class="number">0</span>; n &lt; buckets.<span class="built_in">size</span>(); ++n)</span><br><span class="line">      <span class="keyword">if</span> (buckets[n])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_iterator</span>(buckets[n], <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="number">0</span>, <span class="keyword">this</span>); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回桶的大小</span></span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __stl_prime_list[__stl_num_primes - <span class="number">1</span>]; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回指定位置的节点的个数</span></span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type bucket)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (node* cur = buckets[bucket]; cur; cur = cur-&gt;next)</span><br><span class="line">      result += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="hashtable-具体方法"><a href="#hashtable-具体方法" class="headerlink" title="hashtable 具体方法"></a>hashtable 具体方法</h3><p><strong>重载操作符</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  hashtable&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> hashtable&amp; ht)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;ht != <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="built_in">clear</span>();	<span class="comment">// 清除原表中的数据</span></span><br><span class="line">      <span class="comment">// 重新进行赋值</span></span><br><span class="line">      hash = ht.hash;</span><br><span class="line">      equals = ht.equals;</span><br><span class="line">      get_key = ht.get_key;</span><br><span class="line">      <span class="built_in">copy_from</span>(ht);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> hashtable&amp;, <span class="keyword">const</span> hashtable&amp;);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 iterator++ 操作需要使用到 hashtable 的成员, 所以只能在定义完成 hashtable 时才能</span></span><br><span class="line"><span class="comment">// 实现 operator++</span></span><br><span class="line"><span class="comment">// 重载++</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">ExK</span>, <span class="keyword">class</span> <span class="title">EqK</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> node* old = cur;</span><br><span class="line">  cur = cur-&gt;next;</span><br><span class="line">    <span class="comment">// cur指向了NULL</span></span><br><span class="line">  <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">    size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">      <span class="comment">// 寻找桶中下一个链表不为空的链表的第一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())</span><br><span class="line">      cur = ht-&gt;buckets[bucket];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">ExK</span>, <span class="keyword">class</span> <span class="title">EqK</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> __hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;&amp; ht1,</span><br><span class="line">                <span class="keyword">const</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;&amp; ht2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::node node;</span><br><span class="line">    <span class="comment">// 先判断桶的大小</span></span><br><span class="line">  <span class="keyword">if</span> (ht1.buckets.<span class="built_in">size</span>() != ht2.buckets.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 其次比较桶中每个指向的链表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; ht1.buckets.<span class="built_in">size</span>(); ++n) &#123;</span><br><span class="line">    node* cur1 = ht1.buckets[n];</span><br><span class="line">    node* cur2 = ht2.buckets[n];</span><br><span class="line">      <span class="comment">// 比较链表中的元素也是否相等</span></span><br><span class="line">    <span class="keyword">for</span> ( ; cur1 &amp;&amp; cur2 &amp;&amp; cur1-&gt;val == cur2-&gt;val;</span><br><span class="line">          cur1 = cur1-&gt;next, cur2 = cur2-&gt;next)</span><br><span class="line">      &#123;&#125;</span><br><span class="line">      <span class="comment">// 有一个链表还有剩余的元素就表示不相等</span></span><br><span class="line">    <span class="keyword">if</span> (cur1 || cur2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p><strong>重新分配 resize(int)</strong></p>
<p>由于上文中说到,  当 <strong>hashtable</strong> 中的元素个数超过 <strong>桶 bucket</strong> 大小时, 会重新给 hashtable 分配更大的容量并将所有元素重新分配到新的 <strong>bucket</strong> 里, 对于设计者来说, 这是一个经验之谈. </p>
<p>但是扩容也带来了性能的不稳定性, 一旦出现大量重复插入的数据, 将导致对于内存和时间的浪费,  如果打过 <code>codeforces</code> 的同学可以知道, <code>unordered_map</code> 会被 hack 掉.  所以对于特定的数据或者场景, 还是慎用 <code>hashtable</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">resize</span>(size_type num_elements_hint)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">   <span class="comment">// 如果元素个数大于 bucket 最大值, 那么就要扩容并给元素重新分配 bucket</span></span><br><span class="line">  <span class="keyword">if</span> (num_elements_hint &gt; old_n) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; old_n) &#123;</span><br><span class="line">      <span class="function">vector&lt;node*, A&gt; <span class="title">tmp</span><span class="params">(n, (node*) <span class="number">0</span>)</span></span>;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 将原来桶中的元素重新 rehash 到新桶中  </span></span><br><span class="line">        <span class="keyword">for</span> (size_type bucket = <span class="number">0</span>; bucket &lt; old_n; ++bucket) &#123;</span><br><span class="line">          node* first = buckets[bucket];</span><br><span class="line">          <span class="keyword">while</span> (first) &#123;</span><br><span class="line">            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val, n);</span><br><span class="line">            buckets[bucket] = first-&gt;next;</span><br><span class="line">            first-&gt;next = tmp[new_bucket];</span><br><span class="line">            tmp[new_bucket] = first;</span><br><span class="line">            first = buckets[bucket];          </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">      <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_type bucket = <span class="number">0</span>; bucket &lt; tmp.<span class="built_in">size</span>(); ++bucket) &#123;</span><br><span class="line">          <span class="keyword">while</span> (tmp[bucket]) &#123;</span><br><span class="line">            node* next = tmp[bucket]-&gt;next;</span><br><span class="line">            <span class="built_in">delete_node</span>(tmp[bucket]);</span><br><span class="line">            tmp[bucket] = next;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<p><code>hashtable</code> 也有 <code>insert_equal</code> 和 <code>insert_unique</code> 两种插入方式</p>
<ul>
<li>insert_equal: 插入返回的是插入位置的迭代器,  且插入时, 会将所有相同值的节点全部放在一起</li>
<li>insert_unique: 插入返回的是一个 <code>pair</code> first 为插入后新元素的迭代器, second 为 bool 表示是否插入成功</li>
</ul>
<p>同时提供了 <code>ForwardIterator</code> 和 <code>InputIterator</code> 的类型迭代器相对应的不同插入方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="comment">// 不可重复插入</span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="keyword">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 可重复插入</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">// 不可重复插入返回的是pair结构</span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="keyword">bool</span>&gt; <span class="title">insert_unique_noresize</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span>;</span><br><span class="line">  	<span class="comment">// 可重复插入返回的是迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 以下是insert的各个重载函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">	<span class="comment">// 针对InputIterator的迭代器</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">insert_unique</span>(f, l, <span class="built_in">iterator_category</span>(f));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">insert_equal</span>(f, l, <span class="built_in">iterator_category</span>(f));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(InputIterator f, InputIterator l,input_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; f != l; ++f)</span><br><span class="line">      <span class="built_in">insert_unique</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(InputIterator f, InputIterator l,input_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; f != l; ++f)</span><br><span class="line">      <span class="built_in">insert_equal</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 针对ForwardIterator类型的迭代器, 一个个进行插入</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(ForwardIterator f, ForwardIterator l,forward_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_unique_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(ForwardIterator f, ForwardIterator l,forward_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_equal_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(<span class="keyword">const</span> value_type* f, <span class="keyword">const</span> value_type* l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = l - f;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_unique_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type* f, <span class="keyword">const</span> value_type* l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = l - f;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_equal_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(const_iterator f, const_iterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_unique_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(const_iterator f, const_iterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_equal_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以发现, 上面所有的方法都调用了 <code>insert_***_noresize</code></p>
<ul>
<li><code>insert_unique_noresize</code> 不可重复插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator, <span class="keyword">bool</span>&gt; </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_unique_noresize</span>(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确定插入的桶的具体位置</span></span><br><span class="line">  <span class="keyword">const</span> size_type n = <span class="built_in">bkt_num</span>(obj);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素插入到链表中</span></span><br><span class="line">  <span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next) </span><br><span class="line">      <span class="comment">// 判断该元素在链表中是否已经存在了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)))</span><br><span class="line">      <span class="comment">// 存在pair第二个参数返回false</span></span><br><span class="line">      <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);	</span><br><span class="line">  <span class="comment">// 元素不存在链表中, 将它插入到链表的头部</span></span><br><span class="line">  node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">  tmp-&gt;next = first;</span><br><span class="line">  buckets[n] = tmp;</span><br><span class="line">  ++num_elements;	<span class="comment">// 计数++</span></span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(<span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>), <span class="literal">true</span>);	<span class="comment">// 返回pair结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>insert_equal_noresize</code>可重复插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_equal_noresize</span>(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确定插入的桶的具体位置</span></span><br><span class="line">  <span class="keyword">const</span> size_type n = <span class="built_in">bkt_num</span>(obj);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 将元素插入到链表中</span></span><br><span class="line">  <span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next) </span><br><span class="line">      <span class="comment">// 判断该元素在链表中是否已经存在了, 则将元素插入到重复数据的位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj))) &#123;</span><br><span class="line">      node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">      tmp-&gt;next = cur-&gt;next;</span><br><span class="line">      cur-&gt;next = tmp;</span><br><span class="line">      ++num_elements;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素不存在链表中, 将它插入到链表的头部</span></span><br><span class="line">  node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">  tmp-&gt;next = first;</span><br><span class="line">  buckets[n] = tmp;	</span><br><span class="line">  ++num_elements;	<span class="comment">// 计数++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);	<span class="comment">// 返回pair结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>查找</strong></p>
<ul>
<li><code>find</code>: 单纯的查找</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">	<span class="comment">// 找到指定的桶的位置再在链表中进行遍历</span></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">    node* first;</span><br><span class="line">    <span class="comment">// 找到指定的位置并返回</span></span><br><span class="line">    <span class="keyword">for</span> ( first = buckets[n];first &amp;&amp; !<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key);  first = first-&gt;next)</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(first, <span class="keyword">this</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>find_or_insert</code>: 如果找到了, 就返回该元素数据, 反之就将指定元素插入到链表的头部, 再返回元素默认数据</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::reference </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">find_or_insert</span>(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  size_type n = <span class="built_in">bkt_num</span>(obj);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line">	<span class="comment">// 如果找到了就返回该元素的数据</span></span><br><span class="line">  <span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)))</span><br><span class="line">      <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到指定元素就将其插入到链表的头部</span></span><br><span class="line">  node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">  tmp-&gt;next = first;</span><br><span class="line">  buckets[n] = tmp;</span><br><span class="line">  ++num_elements;</span><br><span class="line">  <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong></p>
<p>erase有很多个重载函数, 这里就具体分析一个</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> iterator&amp; it)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> const_iterator&amp; it)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::size_type </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">erase</span>(<span class="keyword">const</span> key_type&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line">  size_type erased = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 找到key具体在哪一个链表</span></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    node* cur = first;</span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">      <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">        <span class="comment">// 元素在中间</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(next-&gt;val), key)) &#123;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        <span class="built_in">delete_node</span>(next);</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        ++erased;</span><br><span class="line">        --num_elements;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 在头部</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 析构, 释放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key)) &#123;</span><br><span class="line">      buckets[n] = first-&gt;next;</span><br><span class="line">      <span class="built_in">delete_node</span>(first);</span><br><span class="line">      ++erased;</span><br><span class="line">      --num_elements;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> erased;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">erase_bucket</span>(<span class="keyword">const</span> size_type n, node* last)</span><br><span class="line">&#123;</span><br><span class="line">  node* cur = buckets[n];</span><br><span class="line">  <span class="keyword">while</span> (cur != last) &#123;</span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">    <span class="built_in">delete_node</span>(cur);</span><br><span class="line">    cur = next;</span><br><span class="line">    buckets[n] = cur;</span><br><span class="line">    --num_elements;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    node* cur = buckets[i];</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="number">0</span>) &#123;</span><br><span class="line">      node* next = cur-&gt;next;</span><br><span class="line">      <span class="built_in">delete_node</span>(cur);</span><br><span class="line">      cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    buckets[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  num_elements = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以发现, 其操作本质还是找到对应的桶后, 进行链表操作.</p>
<p><strong>复制</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">copy_from</span>(<span class="keyword">const</span> hashtable&amp; ht)</span><br><span class="line">&#123;</span><br><span class="line">  buckets.<span class="built_in">clear</span>(); <span class="comment">//把元素全部删除</span></span><br><span class="line">  buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());	<span class="comment">// 重新调整桶的大小</span></span><br><span class="line">    <span class="comment">// 重新插入</span></span><br><span class="line">  buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), ht.buckets.<span class="built_in">size</span>(), (node*) <span class="number">0</span>);</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">      <span class="comment">// 插入</span></span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; ht.buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> node* cur = ht.buckets[i]) &#123;</span><br><span class="line">        node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">        buckets[i] = copy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (node* next = cur-&gt;next; next; cur = next, next = cur-&gt;next) &#123;</span><br><span class="line">          copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">          copy = copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num_elements = ht.num_elements;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p><code>hashtbale</code> 选用开链法来处理 hash 冲突</p>
</li>
<li><p>采用质数作为桶的容量, 并在元素个数大于桶大小时扩容并进行 rehash</p>
</li>
<li><p>与 <code>RB-tree</code>:</p>
<ol>
<li>再插入过程中, 前者平均是 O(1), 后者为 O(nlogn)</li>
<li>前者插入是无序的, 后者是有序的</li>
<li>前者桶满后效率很低, 后者不会考虑到满</li>
<li>两者都实现了可重复和不可重复</li>
<li>前者正向迭代器, 没有 <code>operator--</code>, 后者迭代器实现了 <code>operator--</code></li>
</ol>
</li>
<li><p>至于 <strong>hash function</strong> ,  又其他头文件定义, hashtable 只是进行调用, 并不属于 hashtable 容器, 所以不再进行</p>
<p>分析, 且对于一些类型, 标准库并没有提供 <code>hash function</code> <strong>(标准库不可能提前知道你要建立的类型是什么)</strong> 需要用户自己去定义 <code>hash function</code></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Cu1</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://cu1universe.cn/STL-%E6%BA%90%E7%A0%81/hashtable/">https://cu1universe.cn/STL-%E6%BA%90%E7%A0%81/hashtable/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://cu1universe.cn" target="_blank">Cu1universe</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/STL-hashtable/">STL, hashtable</a></div><div class="post_share"><div class="social-share" data-image="https://s4.ax1x.com/2022/02/14/H6o0n1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/MySQL/MySQL-order-by,-limit-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL order by, limit 同时使用问题</div></div></a></div><div class="next-post pull-right"><a href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/POST%20%E5%92%8C%20GET%20%E7%9A%84%E5%8C%BA%E5%88%AB/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">POST 和 GET 的区别</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="cols"><div class="col"><div class="container"><div class="front avatarPanel"><div class="inner"><div class="player-title">Attributes</div><div class="player-avatar"><img src="https://s4.ax1x.com/2022/02/14/H6o0n1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div></div></div><div class="back attributesPanel"><div class="inner"><div class="player-lv">LV.3</div><div class="player-name">Cu1</div><div class="attributes-value"><div class="attributes-value-item"><a href="/archives/"><div class="attributes">文章</div><div class="value-bar"><div class="value-bar-fill" style="width:30.00%"><div class="value-bar-fill-in" style="background: rgba(89, 230, 54,0.6)"></div></div></div><span>30/100</span></a></div><div class="attributes-value-item"><a href="/tags/"><div class="attributes">标签</div><div class="value-bar"><div class="value-bar-fill" style="width:21.00%"><div class="value-bar-fill-in" style="background: rgba(224, 20, 20, 0.6)"></div></div></div><span>21/100</span></a></div><div class="attributes-value-item"><a href="/categories/"><div class="attributes">分类</div><div class="value-bar"><div class="value-bar-fill" style="width:16.00%"><div class="value-bar-fill-in" style="background: rgba(30, 97, 226, 0.6)"></div></div></div><span>16/100</span></a></div></div></div></div></div></div><div class="col"><div class="container"><div class="front descriptionPanel"><div class="inner"><div class="player_description"><div style="text-align:center;"><b>庐山烟雨浙江潮，<br>未到千般恨不消。<br>到得还来别无事，<br>庐山烟雨浙江潮。</b></div></div><div class="play-bottom"></div></div></div><div class="back buttonPanel"><div class="inner"><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>点下一行!</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Cu1ii" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="mailto:cu1universe@gmail.com" target="_blank" title="Email"><i class="iconfont icon-gmail"></i></a><a class="social-icon" href="https://www.zhihu.com/people/hu-luo-bu-xu-62-23" target="_blank" title="知乎"><i class="iconfont icon-zhihu"></i></a></div><div class="play-bottom"></div></div></div></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b>请成为更厉害的大人和更可爱的小孩</b></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#hashtable"><span class="toc-number">1.</span> <span class="toc-text">hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">哈希表概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">哈希方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86"><span class="toc-number">1.2.2.</span> <span class="toc-text">冲突处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashtable-%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">hashtable 分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable-%E5%9F%BA%E7%A1%80%E5%AE%9A%E4%B9%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">hashtable 基础定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">hashtable 迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable-1"><span class="toc-number">1.3.3.</span> <span class="toc-text">hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable-%E5%85%B7%E4%BD%93%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">hashtable 具体方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/C/cmake%E7%AC%94%E8%AE%B0/" title="CMake 笔记">CMake 笔记</a><time datetime="2023-03-09T16:00:00.000Z" title="发表于 2023-03-10 00:00:00">2023-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Java/HTML/" title="HTML">HTML</a><time datetime="2022-05-16T16:00:00.000Z" title="发表于 2022-05-17 00:00:00">2022-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Java/Spring/SpringMVC/" title="SpringMVC">SpringMVC</a><time datetime="2022-05-16T16:00:00.000Z" title="发表于 2022-05-17 00:00:00">2022-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Java/Spring/SpringBoot/" title="SpringBoot">SpringBoot</a><time datetime="2022-05-16T16:00:00.000Z" title="发表于 2022-05-17 00:00:00">2022-05-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Java/Spring/Spring/" title="Spring">Spring</a><time datetime="2022-05-16T16:00:00.000Z" title="发表于 2022-05-17 00:00:00">2022-05-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cu1</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twiko-32cx40g3a-cu1universe-gmailcom.vercel.app/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.vemoji)'))
      }
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twiko-32cx40g3a-cu1universe-gmailcom.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      document.getElementById('twikoo-count').innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async src="/js/diytitle.js"></script><script async src="//at.alicdn.com/t/font_2264842_3izu8i5eoc2.js"></script><div class="aplayer no-destroy" data-id="7325805268" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="I,LOVE,YOU" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://npm.elemecdn.com/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><div id="ghbdages" style="overflow:hidden;max-height:90px;height:auto;text-align:center;margin-top:10px"><div class="swiper-wrapper"><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v5.4.0"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v3.8.2"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://www.jsdelivr.com/" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&amp;logo=jsDelivr" alt=""/></a></div><div class="swiper-slide"><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本站项目由Github托管"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></div></div></div><style>a.github-badge:hover:before {display:none}</style>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://cdn.jsdelivr.net/gh/Cu1ii/BlogDebris@main/CDN/js/runtime.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify/lib/swiperbdage_init.min.js"></script><!-- hexo injector body_end end --><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>