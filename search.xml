<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>叠字</title>
      <link href="/%E7%94%9F%E6%B4%BB/%E6%9C%89%E8%B6%A3%E6%9D%82/2022-05-07-%E5%8F%A0%E5%AD%97/"/>
      <url>/%E7%94%9F%E6%B4%BB/%E6%9C%89%E8%B6%A3%E6%9D%82/2022-05-07-%E5%8F%A0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="叠字"><a href="#叠字" class="headerlink" title="叠字"></a>叠字</h1><ul><li>三个金念<strong>鑫</strong>（xīn）</li><li>三个水念<strong>淼</strong>（miǎo）</li><li> 三个火念<strong>焱</strong>（yàn） </li><li>三个土念<strong>垚</strong>（yáo）</li><li> 三个牛念<strong>犇</strong>（bēn） </li><li>三个手念<strong>掱</strong>（pá） </li><li>三个目念<strong>瞐</strong>（mò） </li><li>三个田念<strong>畾</strong>（lěi） </li><li>三个马念<strong>骉</strong>（biāo） </li><li>三个羊念<strong>羴</strong>（shān） </li><li>三个犬念<strong>猋</strong>（biāo） </li><li>三个鹿念<strong>麤</strong>（cū）</li><li>三个鱼念<strong>鱻</strong>（xiān） </li><li>三个贝念<strong>赑</strong>（bì）</li><li> 三个力念<strong>劦</strong>（lie）</li><li> 三个毛念<strong>毳</strong>（cuì） </li><li>三个耳念<strong>聶</strong>（niè） </li><li>三个车念<strong>轟</strong>（hōng） </li><li>三个直念<strong>矗</strong>（chù） </li><li>三个龙念<strong>龘</strong>（tà、dá） </li><li>三个原念<strong>厵</strong>（yuán） </li><li>三个雷念<strong>靐</strong>（bìng） </li><li>三个飞念<strong>飝</strong>（fēi） </li><li>三个刀念<strong>刕</strong>（lí） </li><li>三个又念<strong>叒</strong>（ruò） </li><li>三个士念<strong>壵</strong>（zhuàng） </li><li>三个小念<strong>尛</strong>（mó） </li><li>三个子念<strong>孨</strong>（zhuǎn） </li><li>三个止念<strong>歮</strong>（sè）</li><li> 三个风念<strong>飍</strong>（xiū） </li><li>三个隼念<strong>雥</strong>（zá） </li><li>三个吉念<strong>嚞</strong>（zhé）</li><li> 三个言念<strong>譶</strong>（tà） </li><li>三个舌念<strong>舙</strong>（qì）</li><li>三个香念<strong>馫</strong>（xīn） </li><li>三个泉念<strong>灥</strong>（xún）</li><li> 三个心念<strong>惢</strong>（suǒ）</li><li> 三个白念<strong>皛</strong>（xiǎo）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 有趣杂 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TinySTL 文档 1.0</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/TinySTL/TinySTL%E6%96%87%E6%A1%A31.0/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/TinySTL/TinySTL%E6%96%87%E6%A1%A31.0/</url>
      
        <content type="html"><![CDATA[<h1 id="TinySTL"><a href="#TinySTL" class="headerlink" title="TinySTL"></a>TinySTL</h1><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p><strong>模板参数:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tmplate &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span></span></span><br><span class="line"><span class="class">&#123;</span> ... &#125;;</span><br></pre></td></tr></table></figure><p>​    <strong>T:</strong> 数据类型</p><h4 id="内部类型表示"><a href="#内部类型表示" class="headerlink" title="内部类型表示:"></a>内部类型表示:</h4><ul><li><code>typedef mystl::allocator&lt;T&gt; allocator_type;</code> 分配器类型</li><li><code>typedef mystl::allocator&lt;T&gt;  data_allocator;</code> 分配数据内存类型</li><li><code>typedef typename allocator_type::value_type value_type;</code> 内部数据类型</li><li><code>typedef typename allocator_type::pointer pointer;</code> 内部指针类型, 下面的引用类似</li><li><code>typedef typename allocator_type::const_pointer const_pointer;</code></li><li><code>typedef typename allocator_type::reference reference;</code></li><li><code>typedef typename allocator_type::const_reference const_reference;</code></li><li><code>typedef typename allocator_type::size_type size_type;</code> 容量类型</li><li><code>typedef typename allocator_type::difference_type difference_type;</code> 两个<strong>迭代器</strong>之间的距离</li><li><code>typedef value_type*  iterator;</code> 迭代器类型</li><li><code>typedef const value_type* const_iterator;</code></li><li><code>typedef mystl::reverse_iterator&lt;iterator&gt; reverse_iterator;</code>  反向迭代器</li><li><code>typedef mystl::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T* start; <span class="comment">// vector 的第一个元素的位置</span></span><br><span class="line">T* finish; <span class="comment">// vecotr 的最后一个元素的下一个位置</span></span><br><span class="line">T* end_of_storage; <span class="comment">//vector 容量的最后一个位置的下一个位置</span></span><br></pre></td></tr></table></figure><p><strong>方法关系图:</strong></p><p>[<img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s1.ax1x.com/2022/05/07/OlZhGV.png" alt="OlZhGV.png"></p><h4 id="辅助函数"><a href="#辅助函数" class="headerlink" title="辅助函数"></a>辅助函数</h4><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>position: 插入的位置</li><li>value: 插入的值</li></ul><p><strong>内部调用:</strong></p><ul><li><code>clear()</code></li></ul><p>对插入的数据进行内部调整, 如果剩余容量可以插入, 就直接插入, 反之则重新进行空间分配后再插入元素</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class ...Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, Args&amp;&amp; ...args)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>模板参数:</strong></p><ul><li>…Args:  要传入的数据列表</li></ul><p><strong>方法参数:</strong></p><ul><li>position: 要插入的位置</li><li>args: 传入的参数列表的右值引用</li></ul><p>对插入的数据进行内部调整, 如果剩余容量可以插入, 就直接插入, 反之则重新进行空间分配后再插入元素, 且元素为右值, 用于插入右值时使用</p><p><strong>内部调用:</strong></p><ul><li><code>clear()</code></li></ul></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>释放 <code>vector</code> 管理的内存</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>n:  给 <code>vector</code> 初始化的大小</p></li><li><p>value: <code>vector</code> 中元素的初始值</p></li></ul></li></ul><p><strong>内部调用:</strong> </p><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">space_initialize</span><span class="params">(size_type size, size_type cap)</span></span></span><br></pre></td></tr></table></figure>将 <code>vector</code> 的空间初始化为 <code>n</code>,  且所有元素的值都是 <code>value</code></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(Iter first, Iter last)</span></span>;</span><br></pre></td></tr></table></figure><strong>模板参数:</strong> <ul><li>Iter: 需要一个迭代器</li></ul><strong>方法参数:</strong><ul><li>first: 区间起始位置</li><li>last: 区间最后位置的下一个位置</li></ul><strong>内部调用:</strong></li><li>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">space_initialize</span><span class="params">(size_type size, size_type cap)</span></span></span><br></pre></td></tr></table></figure>接受两个迭代器并将 $[first, last)$ 中的内容作为 <code>vector</code> 的初始内容, 此时 vector 的大小为 <code>distance(first, last)</code></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try_init</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>给 <code>vector</code>  分配默认大小, 当前设置默认大小为 16, 且内部没有元素</p><p>保证不抛出异常</p></li></ul><ul><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">space_initialize</span><span class="params">(size_type size, size_type cap)</span></span></span><br></pre></td></tr></table></figure><ul><li>size: 要给 <code>vector</code> 初始化的大小</li><li>cap: 给 <code>vector</code> 初始化时设置的最大容量</li></ul><p>使 <code>vector</code> 留出 size 大小, 同时容量为 cap</p></li></ul><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul><li><p><strong>默认构造:</strong> <code>vector()</code> 内部调用 <code>try_init()</code> 来为 <code>vector</code> 分配初始大小</p></li><li><p><strong>有参构造 1:</strong> <code> explicit vector(size_type n)</code>  </p><ul><li><p>n :  <code>vector</code> 的大小, 容器内的元素都将初始化为 <code> value_type</code> 的默认值**(有构造函数则调用 T 的默认构造)**</p></li><li><p>explicit: 防止出现隐式转换为 <code>vector</code></p></li></ul></li><li><p><strong>有参构造 2:</strong><code>vector(size_type n, const T&amp; value)</code> </p><ul><li><p>n: 同 1</p></li><li><p>value: <code>vector</code> 中元素的初始值</p></li></ul><p><strong>内部调用:</strong></p><p>​     <code>fill_initialize(n, value)</code> </p></li><li><p><strong>有参构造 3:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">        mystl::is_input_iterator&lt;Iter&gt;::value, <span class="keyword">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="built_in">vector</span>(Iter first, Iter last)</span><br></pre></td></tr></table></figure><p><strong>模板参数:</strong> </p><ul><li><p>Iter: 接收的迭代器类型</p></li><li><p>第二个模板参数则是进行判断是否为 <code>input_iterator</code> , 若不是则该方法失效</p></li></ul><p><strong>方法参数:</strong></p><ul><li><p>first: 区间起始位置的迭代器</p></li><li><p>last: 为区间结束位置的下一位置迭代器, 且该位置为开区间</p></li></ul><p><strong>内部调用:</strong></p><p>​    <code>range_initialize(first, last)</code></p></li><li><p><strong>初始化列表构造函数:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(std::initializer_list&lt;T&gt; ilist) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>ilist: 初始化列表</li></ul><p><strong>内部调用:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>&gt;</span>    </span><br><span class="line"><span class="built_in">range_initialize</span>(Iter first, Iter last)</span><br></pre></td></tr></table></figure></li></ul><h4 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数:"></a>复制构造函数:</h4><ol><li><p><code> vector(const vector&lt;T&gt;&amp; other)</code></p><ul><li>other:  要复制的  <code>vecotr&lt;T&gt;</code> 对象引用</li></ul><p><strong>内部调用:</strong>  <code>range_initialize(other.begin(), other.end())</code></p></li><li></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(vector&lt;T&gt;&amp;&amp; other)</span><br><span class="line">    :<span class="built_in">start</span>(other.start),</span><br><span class="line">     <span class="built_in">finish</span>(other.finish),</span><br><span class="line">     <span class="built_in">end_of_storage</span>(other.end_of_storage) &#123; ... &#125;</span><br></pre></td></tr></table></figure><ul><li>other: 要复制的 <code>vector</code> 的右值引用</li></ul><p>   <strong>保证不抛出异常</strong></p><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">vector</span>()</span><br></pre></td></tr></table></figure><p>将 vector 内部元素全部析构, 再将 vector 内部空间释放</p><p><strong>内部调用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deallocate</span>()</span><br></pre></td></tr></table></figure><h4 id="获取容器信息"><a href="#获取容器信息" class="headerlink" title="获取容器信息:"></a>获取容器信息:</h4><ul><li><code>iterator begin() noexcept</code></li></ul><p>​       获取容器第一个元素位置, 并返回迭代器, 保证不抛出异常</p><ul><li><p><code>const_iterator begin() const noexcept</code></p><p>返回常量迭代器, 当 vector 对象是 const 时会被调用, 其他同上</p></li><li><p><code>iterator end() noexcept</code></p><p>返回 <code>vector</code> 最后一个元素的后一个位置</p></li><li><p><code>const_iterator end() const noexcept</code></p><p>参考 <code>begin()</code></p></li><li><p><code>reverse_iterator rbegin() noexcept</code></p><p>返回一个反向迭代器, 其本质指向 <code>vector</code> 的 <code>end()</code> 保证不抛出异常</p></li><li><p><code>const_reverse_iterator  rbegin()    const noexcept</code></p><p>参考 <code>begin()</code></p></li><li><p><code>reverse_iterator rend() noexcept</code></p><p>返回一个反向迭代器, 指本质向 <code>vector</code> 的 <code>begin()</code> 保证不抛出异常</p></li><li><p><code>const_reverse_iterator rend() const noexcept</code></p><p>参考 <code>begin()</code></p></li><li><p><code>const_iterator cbegin() const noexcept</code></p><p>返回 <code>vector</code> 首部位置的迭代器, 且其是一个常量, 保证不抛出异常 </p></li><li><p><code>const_iterator cend() const noexcept</code></p><p>参考 <code>cbegin()</code></p></li><li><p><code>const_reverse_iterator  crbegin()   const noexcept</code></p><p>参考 <code>cbegin()</code></p></li><li><p><code>const_reverse_iterator  crend()     const noexcept</code></p><p>参考 <code>cbegin()</code></p></li><li><p><code>bool empty() const noexcept</code></p><p>判断 <code>vector</code> 是否为空, 根据 <code>start</code> 是否和 <code>finish</code> 指向同一位置来判断 <code>vector</code> 是否为空. 保证不抛出异常</p></li><li><p><code>size_type size()     const noexcept</code></p><p>返回 <code>vector</code> 中元素个数. 保证不抛出异常</p></li><li><p><code>size_type max_size() const noexcept</code></p><p><code>vector</code>  可纳最大元素个数. 保证不抛出异常</p></li><li><p><code>size_type capacity() const noexcept</code></p><p>返回 <code>vector</code> 容量. 保证不抛出异常</p></li><li><p><code>void reserve(size_type n);</code></p><ul><li>n: 要求重新分配的大小</li></ul><p><strong>内部调用:</strong></p><ul><li><code>clear()</code></li></ul><p>重新分配 vector 容量, 且只有原容量小于要求大小时才会重新分配</p></li><li><p><code>reference at(size_type n)</code></p><ul><li>n: 要获取的下标位置</li></ul><p>获取指定下标处元素, 当指定下标超出有效范围后会抛出异常</p></li><li><p><code>const_reference at(size_type n) const</code></p><p>效果同上, 返回的是常量引用, 作为 <code>const vector</code> 对象调用时的版本</p></li><li><p><code>reference front()</code></p><p>获取第一个元素的引用</p></li><li><p><code>const_reference front() const</code></p><p>参考 <code>at(size_type n)</code></p></li><li><p><code>reference back()</code></p><p>获取最后一个元素的引用</p></li><li><p><code>const_reference back() const</code></p><p>参考 <code>at(size_type n)</code></p></li></ul><h4 id="修改容器相关"><a href="#修改容器相关" class="headerlink" title="修改容器相关"></a>修改容器相关</h4><ul><li><p><code>void fill_assign(size_type n, const T&amp; value);</code></p><ul><li>n: 向 <code>vector</code> 中填充的元素个数</li><li>value:  向 <code>vector</code> 中填充的元素值</li></ul><p><strong>调用方法:</strong></p><ul><li><code>vector(size_type n, const T&amp; value)</code></li><li><code>iterator erase(const_iterator pos)</code></li></ul><p>该方法会将 <code>vector</code> 的 <code>size()</code> 修改为 $n$</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">IIter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_assign</span><span class="params">(IIter first, IIter last, input_iterator_tag)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>模板参数:</strong></p><ul><li>IIter: 接受的迭代器</li></ul><p><strong>方法参数:</strong></p><ul><li>first: 区间左端点迭代器</li><li>last: 区间右端点迭代器</li><li>input_iterator_tag: 表明 IIter 是一个 <code>input_iterator</code> </li></ul><p><strong>内部调用:</strong></p><ul><li><code>iterator erase(const_iterator first, const_iterator last)</code></li><li><code>iterator insert(const_iterator pos, const T&amp; value)</code></li></ul><p>使用 $[first, last)$ 中的元素填充 <code>vector</code> 并将容量设置为 <code>distance(first, last)</code>, 该方法用于处理 <code>input_iterator</code> 类型迭代器, 其内部复制使用采用循环赋值的方式</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FIter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_assign</span><span class="params">(FIter first, FIter last, forward_iterator_tag)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>模板参数:</strong></p><ul><li>FIter: 接受的前向迭代器</li></ul><p><strong>方法参数:</strong></p><ul><li>first: 区间左端点迭代器</li><li>last: 区间右端点迭代器</li><li>forward_iterator_tag: 表明 FIter 是一个 <code>forward_iterator</code> </li></ul><p>使用 $[first, last)$ 中的元素填充 <code>vector</code> 并将容量设置为 <code>distance(first, last)</code>, 该方法用于处理 <code>forward_iterator</code> 类型迭代器, 其内部复制使用采用整体拷贝的方式, 来提升性能</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span></span></span><br></pre></td></tr></table></figure><p><strong>方法参数:</strong></p><ul><li>n: 向 <code>vector</code> 中填充的元素个数</li><li>value:  向 <code>vector</code> 中填充的元素值</li></ul><p><strong>内部调用:</strong></p><ul><li><code>void fill_assign(size_type n, const T&amp; value);</code></li></ul><p>使用 $n$ 个值为 <code>value</code> 的元素填充 <code>vector</code></p></li><li><p>```c++<br>template &lt;class Iter, typename std::enable_if&lt;</p><pre><code>    mystl::is_input_iterator&lt;Iter&gt;::value, int&gt;::type = 0&gt;</code></pre><p>void assign(Iter first, Iter last)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**模板参数:**</span><br><span class="line"></span><br><span class="line">- Iter: 接受的迭代器</span><br><span class="line">- 第二参数来判断是否为 `input_iterator` 类型迭代器, 不是则该方法则失效</span><br><span class="line"></span><br><span class="line">**方法参数:**</span><br><span class="line"></span><br><span class="line">- first: 区间左端点迭代器</span><br><span class="line">- last: 区间右端点迭代器</span><br><span class="line"></span><br><span class="line">使用 $[first, last)$ 的元素来填充 `vector` , 并且将容量修改为 `distance(first, last)` 同时内部根据迭代器实际类型来实例化不同的处理方法, 来提高性能</span><br><span class="line"></span><br><span class="line">**内部调用:**</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">copy_assign(first, last, iterator_category(first));</span><br><span class="line">// 根据第三参数来选择调用</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">IIter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_assign</span><span class="params">(IIter first, IIter last, input_iterator_tag)</span></span>;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">FIter</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_assign</span><span class="params">(FIter first, FIter last, forward_iterator_tag)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><code>void assign(std::initializer_list&lt;value_type&gt; il)</code></p><p><strong>内部调用:</strong></p><ul><li><code>void copy_assign(FIter first, FIter last, forward_iterator_tag);</code></li></ul><p>使用初始化链表来填充  <code>vector</code> </p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(const_iterator pos, Args&amp;&amp; ...args)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>方法参数:</strong></p><ul><li>pos: 要插入元素的位置</li><li>…args:  要插入的参数包的右值引用</li></ul><p>将参数包的第一个参数在 <code>pos</code> 位置处就地构造元素, 避免额外的复制或者移动开销</p><p><strong>内部调用:</strong></p><ul><li><p>当需要扩容时调用 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class ...Args&gt;</span><br><span class="line">void insert_aux(iterator position, Args&amp;&amp; ...args)</span><br></pre></td></tr></table></figure></li></ul></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp; ...args)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>方法参数:</strong></p><ul><li>…args:  要插入的参数包的右值引用</li></ul><p><strong>内部调用:</strong></p><ul><li><p>当需要扩容时调用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_aux</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; value)</span></span></span><br></pre></td></tr></table></figure></li></ul><p>将参数包的第一个参数在 <code>end()</code>位置处就地构造元素, 避免额外的复制或者移动开销</p></li><li><p><code>void push_back(const T&amp; value)</code></p><p><strong>方法参数:</strong></p><ul><li>value: 要放入 <code>vector</code> 中的值引用</li></ul><p><strong>内部调用:</strong></p><ul><li><code>void insert_aux(iterator position, const T&amp; value);</code></li></ul><p>向 <code>vector</code> 最后加入元素</p></li><li><p><code>void push_back(T&amp;&amp; value)</code></p><p><strong>方法参数:</strong></p><ul><li>value: 要插入的元素的右值引用</li></ul><p><strong>内部调用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp; ...args)</span></span>;</span><br></pre></td></tr></table></figure><p>作用同上, 只是这里传入的右值引用</p></li><li><p><code>void pop_back()</code></p><p>删除最后一个元素</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Iter&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_insert</span><span class="params">(const_iterator position, Iter first, Iter last)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>模板参数:</strong></p><ul><li>Iter: 接受的迭代器</li></ul><p><strong>方法参数:</strong></p><ul><li><p>position: 要插入的位置</p></li><li><p>first: 区间左端点迭代器</p></li><li><p>last: 区间右端点迭代器</p></li></ul><p>在 position 处插入 $[first, last)$ 区间内的元素</p></li><li><p><code>iterator insert(const_iterator pos, const T&amp; value)</code></p><p><strong>方法参数:</strong></p><ul><li>pos: 要插入的位置</li><li>value: 要插入元素的值</li></ul><p><strong>内部调用:</strong></p><ul><li><code>void insert_aux(iterator position, const T&amp; value);</code></li></ul><p>在 pos 处插入值为 <code>value</code> 的元素</p></li><li><p><code>iterator insert(const_iterator pos, T&amp;&amp; value)</code></p><p><strong>方法参数:</strong></p><ul><li>pos: 要插入元素的位置</li><li>value: 要插入元素的值</li></ul><p><strong>内部调用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;class... Args&gt;</span><br><span class="line"><span class="function">iterator <span class="title">emplace</span><span class="params">(const_iterator pos, Args&amp;&amp; ...args)</span></span>;</span><br></pre></td></tr></table></figure><p>将元素值为 <code>value</code> 插入 <code>vector</code> 的 <code>pos</code> 处</p></li><li><p><code>iterator insert(const_iterator pos)</code></p><p><strong>方法参数:</strong></p><ul><li>pos: 要插入的位置</li></ul><p><strong>内部调用:</strong></p><ul><li><code>iterator insert(const_iterator pos, T&amp;&amp; value)</code></li></ul><p>在 <code>pos</code> 插入一个该类型的默认值</p></li><li><p><code>void insert(const_iterator pos, size_type n, const T&amp; value);</code></p><p><strong>方法参数:</strong></p><ul><li>pos: 要插入的位置</li><li>n: 要插入的元素的数量</li><li>value: 要插入元素的值</li></ul><p>在 <code>pos</code> 处插入 $n$ 个值为 <code>value</code> 的元素</p></li><li><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">        mystl::is_input_iterator&lt;Iter&gt;::value, <span class="keyword">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">insert</span>(const_iterator pos, Iter first, Iter last)</span><br></pre></td></tr></table></figure><p><strong>模板参数:</strong></p><ul><li>Iter: 接受的迭代器</li><li>第二参数来判断是否为 <code>input_iterator</code> 类型迭代器, 不是则该方法则失效</li></ul><p><strong>方法参数:</strong></p><ul><li>pos: 要插入的位置</li><li>first: 要插入区间的左端点</li><li>last: 要插入区间的右端点</li></ul><p><strong>内部调用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;class Iter&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_insert</span><span class="params">(const_iterator position, Iter first, Iter last)</span></span>;</span><br></pre></td></tr></table></figure><p>将 $[first, last)$ 的元素值插入到 <code>pos</code> 位置</p></li><li><p><code>iterator erase(const_iterator pos);</code></p><p><strong>方法参数:</strong></p><ul><li>pos: 要删除元素的位置</li></ul><p>删除 <code>pos</code> 位置的元素</p></li><li><p><code>iterator erase(const_iterator first, const_iterator last);</code></p><p><strong>方法参数:</strong></p><ul><li>first: 要删除区间的左端点</li><li>last: 要删除区间的右端点</li></ul><p>删除区间 $[first, last)$ 内的元素</p></li><li><p><code>void swap(vector&lt;T&gt;&amp; other) noexcept;</code></p><p><strong>方法参数:</strong></p><ul><li>other: 要与当前对象交换的对象</li></ul><p>交换两个 <code>vector</code> 该方法不会抛出异常.</p></li><li><p><code>void clear();</code></p><p>清空 <code>vector</code> 只是析构掉储存的元素, 并不释放空间</p></li><li><p><code>void reverse()</code></p><p><strong>内部调用:</strong></p><ul><li><code>std::reverse(first, last)</code></li></ul><p>此部分暂时通过调用 <code>std::reverse</code> 实现, 反转 <code>vector</code> 元素</p></li><li><p><code>void resize(size_type new_size, const T&amp; value);</code></p><p><strong>方法参数:</strong></p><ul><li>new_size: 设置的 <code>vector</code> 存储元素的大小</li><li>value: 重新设置大小后元素的值</li></ul><p><strong>内部调用:</strong></p><ul><li><code>iterator erase(const_iterator first, const_iterator last);</code></li><li><code>void insert(const_iterator pos, size_type n, const T&amp; value);</code></li></ul><p>将 <code>vector</code> 的元素数量重置为 <code>new_size</code> 且元素值为 <code>value</code></p></li><li><p><code>void resize(size_type new_size)</code></p><p><strong>方法参数:</strong></p><ul><li>new_size: 设置的 <code>vector</code> 存储元素的大小</li></ul><p><strong>内部调用:</strong></p><ul><li><code>void resize(size_type new_size, const T&amp; value);</code></li></ul><p>将 <code>vector</code> 的元素数量重置为 <code>new_size</code> 且元素值为默认值</p></li></ul><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><p><strong>赋值运算符:</strong></p><ul><li><p><strong>左值引用版本</strong></p><p><code>vector&lt;T&gt;&amp; operator=(const vector&lt;T&gt;&amp; rhs);</code></p><p><strong>内部调用:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Iter</span>, <span class="title">typename</span> <span class="title">std</span>:</span>:enable_if&lt;</span><br><span class="line">        mystl::is_input_iterator&lt;Iter&gt;::value, <span class="keyword">int</span>&gt;::type = <span class="number">0</span>&gt;</span><br><span class="line"><span class="built_in">vector</span>(Iter first, Iter last)</span><br></pre></td></tr></table></figure></li><li><p><strong>右值引用版本</strong></p><p><code>vector&lt;T&gt;&amp; operator=(vector&lt;T&gt;&amp;&amp; rhs)</code></p><p><strong>内部调用:</strong></p><ul><li><code>clear()</code></li></ul><p>保证不抛出异常</p></li><li><p><strong>初始化列表版本</strong><br><code>vector&lt;T&gt;&amp; operator=(std::initializer_list&lt;T&gt; ilist)</code></p></li><li><p><strong>内部调用:</strong></p><ul><li><code>vector(std::initializer_list&lt;T&gt; ilist) &#123; ... &#125;</code></li></ul></li></ul><p><strong>重载 [] 运算符:</strong></p><ul><li><p><code>reference operator[](size_type n)</code></p><p>取出下标为 $n$ 的元素</p></li><li><p><code>const_reference operator[](size_type n) const</code></p><p>同上, 当对象为常对象时优先调用</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
          <category> TinySTL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TinySTL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扫描线(线段树)</title>
      <link href="/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%89%AB%E6%8F%8F%E7%BA%BF(%E7%BA%BF%E6%AE%B5%E6%A0%91)/"/>
      <url>/acm/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%89%AB%E6%8F%8F%E7%BA%BF(%E7%BA%BF%E6%AE%B5%E6%A0%91)/</url>
      
        <content type="html"><![CDATA[<h1 id="扫描线-线段树"><a href="#扫描线-线段树" class="headerlink" title="扫描线(线段树)"></a>扫描线(线段树)</h1><p>关于<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%AE%B5%E6%A0%91&spm=1001.2101.3001.7020">线段树</a>辅助扫描线的基本思想，已经有很多大佬去详细的解释了，可以去看一下<a href="https://blog.csdn.net/xianpingping/article/details/83032798">传送门</a></p><p><strong>这里主要说一下线段树辅助扫描线的一些问题以及几种变形</strong></p><ol><li><p>关于数据的离散化，离散化很多时候是为了减小空间消耗，但是我认为在线段树辅助扫描线时，基本都是需要进行离散化的，因为在以x(y)为坐标轴时，维护的是 $[1, m] $ (m不确定)，但是显然坐标轴上的区间点坐标不一定是从1开始的，所以要离散出一个区间其范围是 $[1, m]$</p></li><li><p> 在一般线段树进行区间划分的时候，通常采用下面的方式</p></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">(操作函数) (l, mid)</span><br><span class="line">(操作函数) (mid + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><p>   但是，在线段树辅助扫描线的时候，这样划分是不可以的，由于线段树维护的是连续区间，而上面划分区间的时候 $mid$ 和 $mid + 1$中间是有距离的，所以会少统计答案导致错误，所以可以给线段树维护的区间换个意义，可以将其理解为维护的是一个个区间</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|___|___|___|___|</span><br><span class="line">1 2   3   4  5</span><br></pre></td></tr></table></figure><p>   比如上面这个图，将 $[1, 2]$ 定义为 1 号区间，$[2, 3]$ 定义为 2 号区间 … 这样的话，每一个叶子节点的意义不再是一个离散的点，而是表示一个长度为 1 的区间，而上级节点维护的，就是这一个个区间的组成的大区间<br>    在进行维护时可以发现，如果要更新 $[2, 4]$ 这段区间 <strong>(这里2，4指的是端点坐标)</strong>,就等于维护 $[2, 3]$ 这两个区间**(这里的2，3是指的区间编号)**, 可以发现，当要维护节点 $[l, r]$ 这一段区间时就等同于维护第 $(l，l + 1… r - 1)$ 号区间，也就是 $[l, r - 1]$ 范围的区间，所以在更新线段树的时候，传的更新范围参数应该是 $(l, r - 1)$ ，但是如果求区间长度，用 $(r - 1) - l$ 是不正确的，没关系，只要在计算区间长度的时候，给 r 加一个 1 就解决了这个问题<br>    由于我差劲的表达能力以及这种方式自身的抽象性，可能看到这里会觉得，这是什么玩意,看不懂啊，没关系，这只是一种处理方法，下面在讲到其他问题的时候会给出一种简单易懂方式</p><ul><li><p><strong>例题1 :</strong> <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1542">Atlantis</a></p><p>这道题目还挺经典的，由于在acwiing上莫名奇妙的MLE所以选择HDU的题目链接，有兴趣的朋友可以去看下acwing上的这道题目,而且数据也加强过了,线段树辅助扫描线的板子题,用的是第一种划分区间的处理方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch rt &lt;&lt; 1 | 1 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mark[maxn &lt;&lt; <span class="number">2</span>];<span class="comment">//该区间是否为可用边,以及覆盖的次数</span></span><br><span class="line"><span class="keyword">double</span> sum[maxn &lt;&lt; <span class="number">2</span>];<span class="comment">//记录该区间下边的总长度</span></span><br><span class="line">vector &lt;<span class="keyword">double</span>&gt; Hash;<span class="comment">//对横坐标进行离散化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//以横坐标作为线段(区间),对横坐标线段进行扫描</span></span><br><span class="line"><span class="comment">//扫描的作用是每次更新下底边总长度和下底边个数,增加新面积</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//线段</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> l, r, h;</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    <span class="built_in">seg</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">seg</span>(<span class="keyword">double</span> x1, <span class="keyword">double</span> x2, <span class="keyword">double</span> H, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        l = x1, r = x2, h = H, d = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> seg &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s[maxn &lt;&lt; <span class="number">1</span>];<span class="comment">//边有2n条需要乘2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前区间是边的一部分,长度直接记为区间长度</span></span><br><span class="line">    <span class="keyword">if</span> (mark[rt]) sum[rt] = Hash[r + <span class="number">1</span>] - Hash[l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l == r) sum[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> sum[rt] = sum[lch] + sum[rch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        mark[rt] += d;</span><br><span class="line">        <span class="built_in">pushup</span>(rt, l, r);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= mid) <span class="built_in">update</span>(L, R, l, mid, lch, d);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid)  <span class="built_in">update</span>(L, R, mid + <span class="number">1</span>, r, rch, d);</span><br><span class="line">    <span class="built_in">pushup</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">double</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(Hash.<span class="built_in">begin</span>(), Hash.<span class="built_in">end</span>(), key) - Hash.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> x1, x2, y1, y2;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n) &#123;</span><br><span class="line">        Hash.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">            Hash.<span class="built_in">push_back</span>(x1), Hash.<span class="built_in">push_back</span>(x2);</span><br><span class="line">            s[k++] = <span class="built_in">seg</span>(x1, x2, y1, <span class="number">1</span>); <span class="comment">//入边</span></span><br><span class="line">            s[k++] = <span class="built_in">seg</span>(x1, x2, y2, <span class="number">-1</span>); <span class="comment">//出边</span></span><br><span class="line">        &#125;                   </span><br><span class="line">        <span class="built_in">sort</span>(Hash.<span class="built_in">begin</span>(), Hash.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s, s + k);</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        Hash.<span class="built_in">erase</span>(<span class="built_in">unique</span>(Hash.<span class="built_in">begin</span>(), Hash.<span class="built_in">end</span>()), Hash.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = Hash.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> L = <span class="built_in">search</span>(s[i].l);</span><br><span class="line">            <span class="keyword">int</span> R = <span class="built_in">search</span>(s[i].r) - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新区间</span></span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="number">0</span>, len - <span class="number">2</span>, <span class="number">1</span>, s[i].d);</span><br><span class="line">            ans += sum[<span class="number">1</span>] * (s[i + <span class="number">1</span>].h - s[i].h);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\nTotal explored area: %.2lf\n\n&quot;</span>, ++num, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>第二种划分方式</strong></p><p> 可以得知，线段树辅助扫描线，维护的是连续区间 ，那么在进行区间划分的时候，直接不将边界分开就好了，后面的两道题就采用这种方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">(左区间函数) (l, mid);</span><br><span class="line">(右区间函数) (mid, r);</span><br></pre></td></tr></table></figure><ul><li><p>**例题2: **  <a href="https://www.acwing.com/problem/content/250/">窗内的星星</a></p><p>这个题主要是将点扩充成矩形后求最大面积交，利用线段树辅助扫描线维护每加入一条边后，最大的矩形面积交的值，加入一条入边就等于扫描线停下的位置进入了这个矩形覆盖的增益区域，加入一条入边就表示扫描线已经移出这个矩形的增益区域，如果当进入一个矩形的增益区域的同时，还没有出之前矩形的增益区域，那么这个区域的增益值就会叠加，只需要每一次加边的时候同时记录此时的最大值，在所有最大值中取最大就可以了，但是关于这个题的边界判断，我个人觉得这个题还是不太对劲</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch rt &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll y1, y2, h, c;</span><br><span class="line">    <span class="built_in">seg</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">seg</span>(ll ys, ll yd, ll H, ll v) &#123;</span><br><span class="line">        y1 = ys, y2 = yd, h = H, c = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> seg &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (h == a.h) <span class="keyword">return</span> c &lt; a.c;</span><br><span class="line">        <span class="keyword">return</span> h &lt; a.h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;line[maxn];</span><br><span class="line"></span><br><span class="line">ll ms[maxn &lt;&lt; <span class="number">2</span>], add[maxn &lt;&lt; <span class="number">2</span>], Hash[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ms[rt] = <span class="built_in">max</span>(ms[lch], ms[rch]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (add[rt]) &#123;</span><br><span class="line">        add[lch] += add[rt];</span><br><span class="line">        add[rch] += add[rt];</span><br><span class="line">        ms[lch] += add[rt];</span><br><span class="line">        ms[rch] += add[rt];</span><br><span class="line">        add[rt] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, ll val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        ms[rt] += val;</span><br><span class="line">        add[rt] += val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(rt);</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; mid) <span class="built_in">update</span>(L, R, l, mid, lch, val);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(L, R, mid, r, rch, val);</span><br><span class="line">    <span class="built_in">pushup</span>(rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(ll x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(Hash, Hash + n, x) - Hash;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, w, h, x, y, c;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; n &gt;&gt; w &gt;&gt; h) &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;</span><br><span class="line">            Hash[k] = y;</span><br><span class="line">            line[k++] = <span class="built_in">seg</span>(y, <span class="number">1LL</span> * y + h - <span class="number">1</span>, x, c);<span class="comment">//入边</span></span><br><span class="line">            Hash[k] = <span class="number">1LL</span> * y + h - <span class="number">1</span>;</span><br><span class="line">           <span class="comment">// cout &lt;&lt; &quot;1: &quot; &lt;&lt; Hash[k] &lt;&lt; endl;</span></span><br><span class="line">            line[k++] = <span class="built_in">seg</span>(y, <span class="number">1LL</span> * y + h - <span class="number">1</span>, <span class="number">1LL</span> * x + w, -c);<span class="comment">//出边</span></span><br><span class="line">           <span class="comment">// cout &lt;&lt; &quot;2: &quot; &lt;&lt; line[k - 1].y1 &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(Hash, Hash + k);</span><br><span class="line">        <span class="built_in">sort</span>(line, line + k);</span><br><span class="line">        <span class="comment">//离散化</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">unique</span>(Hash, Hash + k) - Hash;</span><br><span class="line">        ll ans = <span class="number">-0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> L = <span class="built_in">search</span>(line[i].y1, m);</span><br><span class="line">            <span class="keyword">int</span> R = <span class="built_in">search</span>(line[i].y2, m);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; &quot;r: &quot; &lt;&lt; R &lt;&lt; &quot; l: &quot; &lt;&lt; L &lt;&lt; endl;</span></span><br><span class="line">            <span class="built_in">update</span>(L, R, <span class="number">0</span>, m - <span class="number">1</span>, <span class="number">1</span>, line[i].c);</span><br><span class="line">           <span class="comment">// cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; ms[1] &lt;&lt; endl;</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, ms[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>求矩形并的周长</strong><br> 这个问题其实类似求矩形面积并，但是要稍微抽象一些，求这类问题有两种方法，但由于蒟蒻只会一种，所以就只介绍一种…</p><p>依旧是向求面积并时，标记入边和出边，遇到入边就给对应的范围 + 1，表示覆盖了一次，遇到出边就就给对应范围 -1 表示扫描线覆盖的这个区域覆盖次数 -1，在统计周长的时候，先按照横坐标进行一次扫描线，每一次统计加入该边后的覆盖长度与上一次覆盖长度差的绝对值，然后再按照纵坐标进行一次扫描线，即为答案，要注意，由于可能出现入边和出边重叠的情况，但是重叠的部分是不算周长的，这里对边进行排序的时候，遇到重叠情况，采取先加入边再加出边的策略。</p><p>演示 计算与轴平行的矩形并的长度<br><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://img-blog.csdnimg.cn/20210217202806879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NVQ1VDMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这个方法挺抽象的，我强行解释一下：<br> 对于每一次加入入边，那么覆盖的长度一定 &gt;= 上一次覆盖的长度，就说明变长的这一部分一定是之前未被覆盖的，也就是说其没有被前面的矩形并所完全包含进去</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://img-blog.csdnimg.cn/20210217204041365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NVQ1VDMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这里黄色表示新加入的入边，之前由于1,2号入边已经将新加入的入边覆盖过了，而且其对应的出边并没有在新加入的入边之前就被扫描到，所以事实上这条边是在这两个矩形并的内部，并不能对周长产生贡献，也可以换个说法，当加入一条入边时，覆盖的长度并没有变化，说明，这个入边的下面有至少一条入边将这个区域给覆盖了，而且上面至少也对应一条出边，等待着将这个区域取消覆盖状态，也就是说，新加入的入边至少处于一个矩形的内部，对周长是没有贡献的，出边也同理，每加入一条出边覆盖的长度 &lt;= 上一次的长度，如果等于上一次长度，说明这条出边也是没有对周长产生贡献的</p><p>之前看到的一句话，总结的很好</p><blockquote><p>因为每次添加了一条线段，如果没有没有使总区间覆盖长度发生变化，说明这条线段其实在多边形的内部，被覆盖掉了，不能计算，只要能引起总区间长度发生变化的，说明该线段不被覆盖不被包含</p></blockquote><ul><li><p><strong>例题3:</strong>  [<a href="https://www.luogu.com.cn/problem/P1856">USACO5.5]矩形周长Picture</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lch rt &lt;&lt; 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rch rt &lt;&lt; 1 | 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10000</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y1, y2, d;</span><br><span class="line">    <span class="built_in">seg</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">seg</span>(<span class="keyword">int</span> X, <span class="keyword">int</span> Y1, <span class="keyword">int</span> Y2, <span class="keyword">int</span> flag) &#123;</span><br><span class="line">        x = X, y1 = Y1, y2 = Y2, d = flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> seg &amp;a) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x != a.x) <span class="keyword">return</span> x &lt; a.x;</span><br><span class="line">        <span class="keyword">return</span> d &gt; a.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos[maxn][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> mark[maxn &lt;&lt; <span class="number">2</span>], sum[maxn &lt;&lt; <span class="number">2</span>], n;</span><br><span class="line">vector &lt;<span class="keyword">int</span>&gt; Hash;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lower_bound</span>(Hash.<span class="built_in">begin</span>(), Hash.<span class="built_in">end</span>(), key) - Hash.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mark[rt]) sum[rt] = Hash[r] - Hash[l];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l == r) sum[rt] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> sum[rt] = sum[lch] + sum[rch];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> rt, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;</span><br><span class="line">        mark[rt] += d;</span><br><span class="line">        <span class="built_in">pushup</span>(rt, l, r);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (L &lt; mid) <span class="built_in">update</span>(L, R, l, mid, lch, d);</span><br><span class="line">    <span class="keyword">if</span> (R &gt; mid) <span class="built_in">update</span>(L, R, mid, r, rch, d);</span><br><span class="line">    <span class="built_in">pushup</span>(rt, l, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_ans</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(s, s + k), <span class="built_in">sort</span>(Hash.<span class="built_in">begin</span>(), Hash.<span class="built_in">end</span>());</span><br><span class="line">    Hash.<span class="built_in">erase</span>(<span class="built_in">unique</span>(Hash.<span class="built_in">begin</span>(), Hash.<span class="built_in">end</span>()), Hash.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> length = Hash.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> L = <span class="built_in">search</span>(s[i].y1);</span><br><span class="line">        <span class="keyword">int</span> R = <span class="built_in">search</span>(s[i].y2);</span><br><span class="line">        <span class="built_in">update</span>(L, R, <span class="number">0</span>, length - <span class="number">1</span>, <span class="number">1</span>, s[i].d);</span><br><span class="line">        res += <span class="built_in">abs</span>(last - sum[<span class="number">1</span>]);</span><br><span class="line">        last = sum[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> &amp;k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    Hash.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">        pos[i][<span class="number">0</span>] = x1, pos[i][<span class="number">1</span>] = y1, pos[i][<span class="number">2</span>] = x2, pos[i][<span class="number">3</span>] = y2;</span><br><span class="line">        Hash.<span class="built_in">push_back</span>(x1), Hash.<span class="built_in">push_back</span>(x2);</span><br><span class="line">        s[k++] = <span class="built_in">seg</span>(y1, x1, x2, <span class="number">1</span>);<span class="comment">//入边</span></span><br><span class="line">        s[k++] = <span class="built_in">seg</span>(y2, x1, x2, <span class="number">-1</span>);<span class="comment">//入边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">get_ans</span>(k);</span><br><span class="line">    <span class="built_in">init</span>(k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span></span><br><span class="line">        x1 = pos[i][<span class="number">0</span>], y1 = pos[i][<span class="number">1</span>], x2 = pos[i][<span class="number">2</span>], y2 = pos[i][<span class="number">3</span>];</span><br><span class="line">        Hash.<span class="built_in">push_back</span>(y1), Hash.<span class="built_in">push_back</span>(y2);</span><br><span class="line">        s[k++] = <span class="built_in">seg</span>(x1, y1, y2, <span class="number">1</span>);<span class="comment">//入边</span></span><br><span class="line">        s[k++] = <span class="built_in">seg</span>(x2, y1, y2, <span class="number">-1</span>);<span class="comment">//入边</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">get_ans</span>(k);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里再补充一下求矩形面积交的做法，其实跟矩形面积并基本相似，只需要再维护一个每加入一条边后，当前所有重叠边的长度,并且同时维护每个区间覆盖的总长度，由于没有Pushdown函数，所以需要处理一下Pushup函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[rt].cnt)</span><br><span class="line">t[rt].len=X[r+<span class="number">1</span>]-X[l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l==r)</span><br><span class="line">t[rt].len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t[rt].len=t[rt&lt;&lt;<span class="number">1</span>].len+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">if</span>(t[rt].cnt&gt;<span class="number">1</span>)</span><br><span class="line">t[rt].s=X[r+<span class="number">1</span>]-X[l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l==r)</span><br><span class="line">t[rt].s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t[rt].cnt==<span class="number">1</span>)</span><br><span class="line">t[rt].s=t[rt&lt;&lt;<span class="number">1</span>].len+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t[rt].s=t[rt&lt;&lt;<span class="number">1</span>].s+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>解释一下:</strong></p><ol><li>对于覆盖次数 &gt;= 2的区间，区间长度直接为当前区间长度</li><li> 对于覆盖次数 == 1的区间，由于这个区间的标记只是说明当前区间被覆盖，对于它的子区间我们并不能清楚的知道，若是它下面的小区间也被覆盖过至少一次，那么此时就等于覆盖了这个小区间两次以上，那么当前的区间覆盖次数 &gt;= 2的长度就是子区间的长度和 (这里为什么选择子区间覆盖的长度，因为对于一个区间，其多次覆盖的长度一定不长于子区间覆盖的全部长度)</li><li> 对于没有被覆盖(或者说这个区间没有完全被用作矩形边长的一部分)，就分别统计子区间的全部覆盖长度和覆盖两次及以上的长度即可</li></ol><p>**例题4: ** <a href="http://acm.hdu.edu.cn/showproblem.php?pid=1255">Hdu1255</a></p><p>代码转自<a href="https://blog.csdn.net/riba2534/article/details/76854995">传送门</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson l,m,rt&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson m+1,r,rt&lt;&lt;1|1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">double</span> l,r,h;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="built_in">Seg</span>() &#123;&#125;</span><br><span class="line"><span class="built_in">Seg</span>(<span class="keyword">double</span> a,<span class="keyword">double</span> b,<span class="keyword">double</span> c,<span class="keyword">int</span> d):<span class="built_in">l</span>(a),<span class="built_in">r</span>(b),<span class="built_in">h</span>(c),<span class="built_in">f</span>(d) &#123;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Seg &amp;cmp) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> h&lt;cmp.h;</span><br><span class="line">&#125;</span><br><span class="line">&#125; e[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">double</span> len,s;</span><br><span class="line">&#125; t[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">double</span> X[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(t[rt].cnt)</span><br><span class="line">t[rt].len=X[r+<span class="number">1</span>]-X[l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l==r)</span><br><span class="line">t[rt].len=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t[rt].len=t[rt&lt;&lt;<span class="number">1</span>].len+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">if</span>(t[rt].cnt&gt;<span class="number">1</span>)</span><br><span class="line">t[rt].s=X[r+<span class="number">1</span>]-X[l];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(l==r)</span><br><span class="line">t[rt].s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t[rt].cnt==<span class="number">1</span>)</span><br><span class="line">t[rt].s=t[rt&lt;&lt;<span class="number">1</span>].len+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].len;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t[rt].s=t[rt&lt;&lt;<span class="number">1</span>].s+t[rt&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> rt,<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)</span><br><span class="line">&#123;</span><br><span class="line">t[rt].cnt+=val;</span><br><span class="line"><span class="built_in">pushdown</span>(l,r,rt);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(L&lt;=m) <span class="built_in">update</span>(L,R,lson,val);</span><br><span class="line"><span class="keyword">if</span>(R&gt;m) <span class="built_in">update</span>(L,R,rson,val);</span><br><span class="line"><span class="built_in">pushdown</span>(l,r,rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">double</span> a,b,c,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line"><span class="keyword">while</span>(q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">mem</span>(t,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf%lf&quot;</span>,&amp;a,&amp;b,&amp;c,&amp;d);</span><br><span class="line">X[num]=a;</span><br><span class="line">e[num++]=<span class="built_in">Seg</span>(a,c,b,<span class="number">1</span>);</span><br><span class="line">X[num]=c;</span><br><span class="line">e[num++]=<span class="built_in">Seg</span>(a,c,d,<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(X,X+num);</span><br><span class="line"><span class="built_in">sort</span>(e,e+num);</span><br><span class="line"><span class="keyword">int</span> m=<span class="built_in">unique</span>(X,X+num)-X;</span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">lower_bound</span>(X,X+m,e[i].l)-X;</span><br><span class="line"><span class="keyword">int</span> r=<span class="built_in">lower_bound</span>(X,X+m,e[i].r)-X<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">update</span>(l,r,<span class="number">0</span>,m,<span class="number">1</span>,e[i].f);</span><br><span class="line">ans+=t[<span class="number">1</span>].s*(e[i+<span class="number">1</span>].h-e[i].h);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>区间 DP 基础</title>
      <link href="/acm/DP/%E5%8C%BA%E9%97%B4%20DP%20%E5%9F%BA%E7%A1%80/"/>
      <url>/acm/DP/%E5%8C%BA%E9%97%B4%20DP%20%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="区间-DP-基础"><a href="#区间-DP-基础" class="headerlink" title="区间 DP 基础"></a>区间 DP 基础</h1><h2 id="什么是区间-DP-区间-DP-特征"><a href="#什么是区间-DP-区间-DP-特征" class="headerlink" title="什么是区间 DP, 区间 DP 特征"></a>什么是区间 DP, 区间 DP 特征</h2><blockquote><p>区间类动态规划是线性动态规划的扩展，它在分阶段地划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。令状态 $f(i, j)$ 表示将下标位置 到 的所有元素合并能获得的价值的最大值，那么 $f(i, j) = max{f(i, k) + f(k + 1, j) + cost}, cost$ 为将这两组元素合并起来的代价。</p><p>区间 DP 的特点：</p><p><strong>合并</strong>：即将两个或多个部分进行整合，当然也可以反过来；</p><p><strong>特征</strong>：能将问题分解为能两两合并的形式；</p><p><strong>求解</strong>：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。</p></blockquote><p><strong>这里给出两道例题进行具体分析: 矩阵连乘问题，石头合并问题</strong></p><h2 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h2><p><strong>题目描述：</strong></p><p><a href="https://so.csdn.net/so/search?q=%E7%9F%A9%E9%98%B5&spm=1001.2101.3001.7020">矩阵</a> $ [A_1,A_2,…,A_n ]$，其中，$A_i$ 与 $A_{i+1}$ 是可乘的，$(i = 1, 2,…, n-1)$。用加括号的方法表示矩阵连乘的次序，不同的计算次序计算量（乘法次数）是不同的，找出一种加括号的方法，使得矩阵连乘的次数最小。</p><p>这里我们要先知道 ：$m * n$ 的 $A$ 矩阵 和 $n * k$ 的 $B$ 矩阵的乘法运算次数为：$m * n * k$</p><p>以$A_1 A_2 A_3$ 三个矩阵相乘为例，乘法的顺序可以是  $(A_1 * A_2) * A_3$ 或者是 $A_1 * (A_2 * A_3)$ 这两种顺序的计算量是可能会不同的，所以矩阵的相乘顺序是会影响连乘的次数。</p><p>先设 $m[i][j]$ 是矩阵 $A_i - A_j$ 的最小相乘次数。<br>那对于 $A_i - A_j$，可以将其拆分为 $A_i - A_k，A_{k+1} - A_j (i &lt;= k &lt; j) $ 我们只需要找到这么一个 $k$ 使得以 $k$为分割点所拆分出来的两部分的结果相乘使得 $m[i][j]$ 最小<br>则$m[i][j] = m[i][k] + m[k + 1][j] + p_{i-1} * p_k * p_j$，那么就将原问题拆解为分别求 $A_i - A_k$ 和 $A_{k+1}－ A_j $的矩阵相乘的最少相乘次数，那么我们就可以得到这样的递推公式</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://img-blog.csdnimg.cn/20200518155055607.png" alt="在这里插入图片描述"></p><p>这里我们采用第底向上的方式：<br>我们根据</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://img-blog.csdnimg.cn/20200518155352559.png" alt="在这里插入图片描述"></p><p>发现，若是想要计算 $m[i][j]$，就必须先计算出 i  和 j 中的每一个 k 的 $m[i][k] ,m[k +1][j]$，所以就从最小的连乘单元：2个矩阵连乘开始进行计算，而且所有的被分割的子序列，长度都会小于 $j - i +1$. 所以选择根据矩阵链长度的递增开始计算</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://img-blog.csdnimg.cn/20200518155711551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NVQ1VDMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m[size][size],s[size][size];<span class="comment">//m[i][j]的值是i - j的最小乘数，s[i][j]则是记录过程</span></span><br><span class="line"><span class="keyword">int</span> p[size];<span class="comment">//存储矩阵的第一个行和中间矩阵的列数以及最后一个矩阵的列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Min_matrix</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++)&#123;<span class="comment">//矩阵连乘的单元规模</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++)&#123;<span class="comment">//对不同规模的矩阵连乘单元,确定共有多少单元</span></span><br><span class="line">            <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">            m[i][j] = m[i + <span class="number">1</span>][j] + p[i - <span class="number">1</span>] * p[i] * p[j];<span class="comment">//先赋一个初值,以进行下面的比较</span></span><br><span class="line">            s[i][j] = i;<span class="comment">//i - j 的最小相乘次数的决策点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; j; k++)&#123;<span class="comment">//通过遍历中间点来找到最优决策点</span></span><br><span class="line">                <span class="keyword">int</span> temp = m[i][k] + m[k + <span class="number">1</span>][j] + p[i - <span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">                <span class="keyword">if</span>(m[i][j] &gt; temp)&#123;</span><br><span class="line">                    m[i][j] = temp;</span><br><span class="line">                    s[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_matrix</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="comment">//递归打印每次的决策点</span></span><br><span class="line">    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;A[&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="built_in">Print_matrix</span>(i,s[i][j]);<span class="comment">//这里是递归i - j的每一个决策点，，这里是向左打印</span></span><br><span class="line">    <span class="built_in">Print_matrix</span>(s[i][j] + <span class="number">1</span>,j);<span class="comment">//向右打印</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请输入矩阵的个数n : &quot;</span>&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;请依次输入每个矩阵的行数和最后一个矩阵的列数：&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">cin&gt;&gt;p[i];</span><br><span class="line"><span class="built_in">Min_matrix</span>(n);</span><br><span class="line"><span class="built_in">Print_matrix</span>(<span class="number">1</span>,n);</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;最小计算量的值为：&quot;</span>&lt;&lt;m[<span class="number">1</span>][n]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>石子合并问题:</strong></p><p>跟上面矩阵相乘的思想很接近，不过由于是相邻的石头相加，运算方式不同，思路跟上面一样，这里只给出递推公式<br>$f[i] [j]$：代表合并第i到第j个石头的最小花费</p><p>$sum [ i ]$：表示 $1 –&gt; i$ 个石头的权值之和</p><p>$f[i, j]= min{ f[i, k] + f[k  + 1, j] + sum[i, j] - sum[i] + a[i]}$</p><p>至于为什么是 $sum [ j ]-sum [ i ]+a[i]$，从第 i 个石头到第 j 个石头进行合并的花费就是第i到第j个石头的权值合。</p><h3 id="练习题目"><a href="#练习题目" class="headerlink" title="练习题目:"></a>练习题目:</h3><ul><li><a href="https://www.acwing.com/problem/content/284/">石子合并</a></li><li><a href="http://poj.org/problem?id=2955">Brackets</a></li><li><a href="https://www.acwing.com/problem/content/481/">加分二叉树</a></li><li><a href="https://www.acwing.com/problem/content/285/">多边形</a></li><li><a href="https://www.acwing.com/problem/content/286/">金字塔</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm, dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL order by, limit 同时使用问题</title>
      <link href="/MySQL/MySQL-order-by,-limit-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/MySQL/MySQL-order-by,-limit-%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL-order-by-limit-同时使用问题"><a href="#MySQL-order-by-limit-同时使用问题" class="headerlink" title="MySQL order by, limit 同时使用问题"></a>MySQL order by, limit 同时使用问题</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html">MySQL 文档原文</a></p><p>建议去阅读一下 <strong>MySQL</strong> 文档</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果 <code>order by</code> 排序属性的值不唯一,  <code>order by</code> 与 <code>limit</code> 同时使用可能会出现查询结果不同的现象.</p><p>例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category;</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| id | category | rating |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">|  2 |        3 |    5.0 |</span><br><span class="line">|  7 |        3 |    2.7 |</span><br><span class="line">+----+----------+--------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category LIMIT 5;</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| id | category | rating |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">+----+----------+--------+</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><strong>文档原文如下:</strong></p><blockquote><p>If you combine <code>LIMIT *</code>row_count<code>*</code> with <code>ORDER BY</code>, MySQL stops sorting as soon as it has found the first <em><code>row_count</code></em> rows of the sorted result, rather than sorting the entire result. If ordering is done by using an index, this is very fast. If a filesort must be done, all rows that match the query without the <code>LIMIT</code> clause are selected, and most or all of them are sorted, before the first <em><code>row_count</code></em> are found. After the initial rows have been found, MySQL does not sort any remainder of the result set.</p><p>One manifestation of this behavior is that an <code>ORDER BY</code> query with and without <code>LIMIT</code> may return rows in different order, as described later in this section.</p></blockquote><p>如果你将 <code>LIMIT row_count</code> 子句与 <code>ORDER BY</code> 子句组合在一起使用的话, MySQL 会找到排序结果的第一个 <code>row_count</code> 后立即停止排序, 而不是对整个结果进行排序. 如果使用索引来完成排序, 这将非常快. 如果必须执行文件排序, 则在找到第一个 <code>row_count</code> 行之前, 选择所有与查询匹配但不包括 <code>LIMIT</code> 子句的行, 并对其中大部分或所有行进行排序. 一旦找到第一个 <code>row_count</code> 之后, MySQL 不会对结果集的任何剩余部分进行排序</p><p>这种行为的一种表现形式是,  一个 <code>ORDER BY</code> 查询带或者不带 <code>LIMIT</code> 可能返回行的顺序是不一样的</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在 <code>order by</code> 子句中包含其他列以使顺序具有确定性.</p><p>例如: 假如 id 的值是唯一的, 则可以通过下面的方法解决此问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category, id;</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| id | category | rating |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">|  2 |        3 |    5.0 |</span><br><span class="line">|  7 |        3 |    2.7 |</span><br><span class="line">+----+----------+--------+</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM ratings ORDER BY category, id LIMIT 5;</span><br><span class="line">+----+----------+--------+</span><br><span class="line">| id | category | rating |</span><br><span class="line">+----+----------+--------+</span><br><span class="line">|  1 |        1 |    4.5 |</span><br><span class="line">|  5 |        1 |    3.2 |</span><br><span class="line">|  3 |        2 |    3.7 |</span><br><span class="line">|  4 |        2 |    3.5 |</span><br><span class="line">|  6 |        2 |    3.5 |</span><br><span class="line">+----+----------+--------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库, mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hashtable 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/hashtable/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/hashtable/</url>
      
        <content type="html"><![CDATA[<h1 id="hashtable"><a href="#hashtable" class="headerlink" title="hashtable"></a>hashtable</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p><code>hashtable</code> 实现一个关联容器, 其在插入, 删除等操作都可以做到 <code>O(1)</code> 实现</p><h2 id="哈希表概念"><a href="#哈希表概念" class="headerlink" title="哈希表概念"></a>哈希表概念</h2><h3 id="哈希方法"><a href="#哈希方法" class="headerlink" title="哈希方法"></a>哈希方法</h3><ol><li><p><strong>直接定址法</strong>：取关键字或关键字的某个线性函数值为散列地址。（这种散列函数叫做自身函数）</p></li><li><p><strong>数字分析法</strong>：假设关键字是以r为基的数，并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。</p></li><li><p><strong>平方取中法</strong>：取关键字平方后的中间几位为哈希地址。通常在选定哈希函数时不一定能知道关键字的全部情况，取其中的哪几位也不一定合适，而一个数平方后的中间几位数和数的每一位都相关，由此使随机分布的关键字得到的哈希地址也是随机的。取的位数由表长决定。</p></li><li><p><strong>折叠法</strong>：将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址。</p></li><li><p><strong>随机数法</strong> </p></li><li><p><strong>除留余数法</strong>：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。不仅可以对关键字直接取模，也可在折叠法、平方取中法等运算之后取模。对p的选择很重要，一般取素数或m，若p选择不好，容易产生冲突。</p></li></ol><p><em>hashtable解决冲突的办法就是开链.</em></p><h3 id="冲突处理"><a href="#冲突处理" class="headerlink" title="冲突处理"></a>冲突处理</h3><p>哈希表的冲突处理也有很多种.</p><ol><li>开放定址法<ul><li>线性探测 : 本来的位置被占有(冲突), 重新再往后找到第一个有空的位置插入进去</li><li>二次探测 : 本来的位置被占有(冲突), 每次有冲突就平方一次重新查找</li></ul></li><li>开链 : 本来的位置被占有(冲突), 形成一个链表插入到链表中</li></ol><p><strong>装载因子 : 装入表中的元素 / 表的实际大小.</strong> 装载因子越大说明冲突的可能性就越大. </p><h2 id="hashtable-分析"><a href="#hashtable-分析" class="headerlink" title="hashtable 分析"></a>hashtable 分析</h2><p><strong>hashtable 前置声明</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_const_iterator</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>,</span></span><br><span class="line"><span class="class">          <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="hashtable-基础定义"><a href="#hashtable-基础定义" class="headerlink" title="hashtable 基础定义"></a>hashtable 基础定义</h3><p><code>hashtable</code> 采用开链法来处理 <code>hash</code> 冲突, 所以需要有一个桶 <code>bucket</code> 以及每一个节点 <code>node</code></p><p><strong>桶 bucket:</strong> 定义的哈希表的小大, 采用 <code>vector </code> 为桶的容器</p><p>关于桶的, 通常采用质数来作为桶的大小. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> __stl_num_primes = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_prime_list[__stl_num_primes] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">53</span>,         <span class="number">97</span>,           <span class="number">193</span>,         <span class="number">389</span>,       <span class="number">769</span>,</span><br><span class="line">  <span class="number">1543</span>,       <span class="number">3079</span>,         <span class="number">6151</span>,        <span class="number">12289</span>,     <span class="number">24593</span>,</span><br><span class="line">  <span class="number">49157</span>,      <span class="number">98317</span>,        <span class="number">196613</span>,      <span class="number">393241</span>,    <span class="number">786433</span>,</span><br><span class="line">  <span class="number">1572869</span>,    <span class="number">3145739</span>,      <span class="number">6291469</span>,     <span class="number">12582917</span>,  <span class="number">25165843</span>,</span><br><span class="line">  <span class="number">50331653</span>,   <span class="number">100663319</span>,    <span class="number">201326611</span>,   <span class="number">402653189</span>, <span class="number">805306457</span>, </span><br><span class="line">  <span class="number">1610612741</span>, <span class="number">3221225473ul</span>, <span class="number">4294967291ul</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在后续的 <code>sgi_STL</code> 版本后, 会根据编译器版本以及平台, 选择不同的质数数量以更好的适应不同平台.</p><p>由于涉及到 hashtable 后续的扩容问题, 所以提供了 <code> unsigned long __stl_next_prime(unsigned long n)</code> 函数来找到一个满足条件的质数. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> __stl_next_prime(<span class="keyword">unsigned</span> <span class="keyword">long</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* first = __stl_prime_list;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* last = __stl_prime_list + __stl_num_primes;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>* pos = <span class="built_in">lower_bound</span>(first, last, n);</span><br><span class="line">  <span class="keyword">return</span> pos == last ? *(last - <span class="number">1</span>) : *pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于扩容:</strong> 在这里设计者依旧采用了一个通过经验得到的判断,  当桶 <code>bucket</code> 中元素容量 &gt; 当前桶的大小时, 就要在上述的质数数组中寻找第一个不小于元素容量的质数重新作为桶的大小</p><p><strong>节点 node:</strong> 在桶的每一个位置采用链表的结构进行存储, 所以节点为链表节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  __hashtable_node* next;</span><br><span class="line">  Value val;</span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h3 id="hashtable-迭代器"><a href="#hashtable-迭代器" class="headerlink" title="hashtable 迭代器"></a>hashtable 迭代器</h3><p><code>hashtable</code> 迭代器是 <code>forward_iterator_tag</code> 类型, 正向迭代器, 所以不提供回退的功能, 也就是说它没有重载 <code>operator--</code></p><p><code>__hashtable_const_iterator</code> 和 <code>__hashtable_iterator</code> 除了内部数据设置为 const 外, 其他结构都是相同的, 这里只对后者进行分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">hashtable_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> hashtable&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;  hashtable;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">          iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn,  ExtractKey, EqualKey, Alloc&gt;</span><br><span class="line">          const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> forward_iterator_tag iterator_category;<span class="comment">// 正向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> Value* pointer;</span><br><span class="line"></span><br><span class="line">  node* cur;<span class="comment">// 定义节点</span></span><br><span class="line">  hashtable* ht;<span class="comment">// 定义哈希表指针</span></span><br><span class="line"></span><br><span class="line">  __hashtable_iterator(node* n, hashtable* tab) : <span class="built_in">cur</span>(n), <span class="built_in">ht</span>(tab) &#123;&#125;</span><br><span class="line">  __hashtable_iterator() &#123;&#125;</span><br><span class="line">  <span class="comment">// 重载指针</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur-&gt;val; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"><span class="comment">// 重在++, 因为是正向迭代器, 所以没有--</span></span><br><span class="line">  iterator&amp; <span class="keyword">operator</span>++();</span><br><span class="line">  iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == it.cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; it) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur != it.cur; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 <code>hashtable</code>  采用的是开链法来处理哈希冲突, 所以迭代器在找完一条链之后, 如何再进行 <code>operator++</code>, 这时就需要回到 <code>hashtable</code> , 所以在 hashtable 迭代器中需要有一个指向 <code>hashtable</code> 的指针</p><h3 id="hashtable-1"><a href="#hashtable-1" class="headerlink" title="hashtable"></a>hashtable</h3><p><strong>hashtable 类型定义</strong></p><p>模板参数含义:</p><ol><li>Value: 节点的实值类型</li><li>Key:    节点的键值类型</li><li>HashFcn: hash function 的类型</li><li>ExtractKey: 从节点中取出键值的方法 (函数或者仿函数)</li><li>EqualKey: 判断键值是否相同的方法 (函数或者仿函数)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> HashFcn hasher;</span><br><span class="line">  <span class="keyword">typedef</span> EqualKey key_equal;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>            size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>         difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type*       pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp;       reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里返回的都是仿函数</span></span><br><span class="line">  <span class="function">hasher <span class="title">hash_funct</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> hash; &#125;</span><br><span class="line">  <span class="function">key_equal <span class="title">key_eq</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> equals; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 这里定义的都是函数或者仿函数</span></span><br><span class="line">  hasher hash;</span><br><span class="line">  key_equal equals;</span><br><span class="line">  ExtractKey get_key;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_node&lt;Value&gt; node;</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;node, Alloc&gt; node_allocator;</span><br><span class="line"></span><br><span class="line">  vector&lt;node*,Alloc&gt; buckets;<span class="comment">// 以vector作为桶, node*</span></span><br><span class="line">  size_type num_elements;<span class="comment">// 哈希表中元素个数的计数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; iterator;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __hashtable_const_iterator&lt;Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt; const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器定义为友元</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  __<span class="title">hashtable_iterator</span>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  __<span class="title">hashtable_const_iterator</span>&lt;</span>Value, Key, HashFcn, ExtractKey, EqualKey, Alloc&gt;;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造与析构函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数, 没有定义默认构造函数</span></span><br><span class="line">  <span class="built_in">hashtable</span>(size_type n, <span class="keyword">const</span> HashFcn&amp;  hf,<span class="keyword">const</span> EqualKey&amp;   eql,<span class="keyword">const</span> ExtractKey&amp; ext)</span><br><span class="line">    : <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(ext), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">hashtable</span>(size_type n, <span class="keyword">const</span> HashFcn&amp;  hf, <span class="keyword">const</span> EqualKey&amp;   eql)</span><br><span class="line">    : <span class="built_in">hash</span>(hf), <span class="built_in">equals</span>(eql), <span class="built_in">get_key</span>(<span class="built_in">ExtractKey</span>()), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">initialize_buckets</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 拷贝构造函数</span></span><br><span class="line">  <span class="built_in">hashtable</span>(<span class="keyword">const</span> hashtable&amp; ht)</span><br><span class="line">    : <span class="built_in">hash</span>(ht.hash), <span class="built_in">equals</span>(ht.equals), <span class="built_in">get_key</span>(ht.get_key), <span class="built_in">num_elements</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">copy_from</span>(ht);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">hashtable</span>() &#123; <span class="built_in">clear</span>(); &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>基本属性获取</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> num_elements; &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size</span>() == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换, 并不是交换所有数据, 只是交换了其指针指向和个数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(hashtable&amp; ht)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    __STD::<span class="built_in">swap</span>(hash, ht.hash);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(equals, ht.equals);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(get_key, ht.get_key);</span><br><span class="line">    buckets.<span class="built_in">swap</span>(ht.buckets);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(num_elements, ht.num_elements);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (size_type n = <span class="number">0</span>; n &lt; buckets.<span class="built_in">size</span>(); ++n)</span><br><span class="line">    <span class="comment">// 从头遍历桶, 如果有不空的链表存在, 就返回该链表的第一个元素</span></span><br><span class="line">      <span class="keyword">if</span> (buckets[n])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">iterator</span>(buckets[n], <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 没有元素就返回end.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// end返回0</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">iterator</span>(<span class="number">0</span>, <span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type n = <span class="number">0</span>; n &lt; buckets.<span class="built_in">size</span>(); ++n)</span><br><span class="line">      <span class="keyword">if</span> (buckets[n])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_iterator</span>(buckets[n], <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">end</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">const_iterator</span>(<span class="number">0</span>, <span class="keyword">this</span>); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回桶的大小</span></span><br><span class="line">  <span class="function">size_type <span class="title">bucket_count</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buckets.<span class="built_in">size</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">size_type <span class="title">max_bucket_count</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> __stl_prime_list[__stl_num_primes - <span class="number">1</span>]; &#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// 返回指定位置的节点的个数</span></span><br><span class="line">  <span class="function">size_type <span class="title">elems_in_bucket</span><span class="params">(size_type bucket)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (node* cur = buckets[bucket]; cur; cur = cur-&gt;next)</span><br><span class="line">      result += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="hashtable-具体方法"><a href="#hashtable-具体方法" class="headerlink" title="hashtable 具体方法"></a>hashtable 具体方法</h3><p><strong>重载操作符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  hashtable&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> hashtable&amp; ht)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (&amp;ht != <span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="built_in">clear</span>();<span class="comment">// 清除原表中的数据</span></span><br><span class="line">      <span class="comment">// 重新进行赋值</span></span><br><span class="line">      hash = ht.hash;</span><br><span class="line">      equals = ht.equals;</span><br><span class="line">      get_key = ht.get_key;</span><br><span class="line">      <span class="built_in">copy_from</span>(ht);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span></span><br><span class="line">  <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> hashtable&amp;, <span class="keyword">const</span> hashtable&amp;);</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 iterator++ 操作需要使用到 hashtable 的成员, 所以只能在定义完成 hashtable 时才能</span></span><br><span class="line"><span class="comment">// 实现 operator++</span></span><br><span class="line"><span class="comment">// 重载++</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">ExK</span>, <span class="keyword">class</span> <span class="title">EqK</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;&amp;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> node* old = cur;</span><br><span class="line">  cur = cur-&gt;next;</span><br><span class="line">    <span class="comment">// cur指向了NULL</span></span><br><span class="line">  <span class="keyword">if</span> (!cur) &#123;</span><br><span class="line">    size_type bucket = ht-&gt;<span class="built_in">bkt_num</span>(old-&gt;val);</span><br><span class="line">      <span class="comment">// 寻找桶中下一个链表不为空的链表的第一个元素</span></span><br><span class="line">    <span class="keyword">while</span> (!cur &amp;&amp; ++bucket &lt; ht-&gt;buckets.<span class="built_in">size</span>())</span><br><span class="line">      cur = ht-&gt;buckets[bucket];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">ExK</span>, <span class="keyword">class</span> <span class="title">EqK</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> __hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;</span><br><span class="line">__hashtable_iterator&lt;V, K, HF, ExK, EqK, A&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">  iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">  ++*<span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;&amp; ht1,</span><br><span class="line">                <span class="keyword">const</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;&amp; ht2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::node node;</span><br><span class="line">    <span class="comment">// 先判断桶的大小</span></span><br><span class="line">  <span class="keyword">if</span> (ht1.buckets.<span class="built_in">size</span>() != ht2.buckets.<span class="built_in">size</span>())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 其次比较桶中每个指向的链表</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; ht1.buckets.<span class="built_in">size</span>(); ++n) &#123;</span><br><span class="line">    node* cur1 = ht1.buckets[n];</span><br><span class="line">    node* cur2 = ht2.buckets[n];</span><br><span class="line">      <span class="comment">// 比较链表中的元素也是否相等</span></span><br><span class="line">    <span class="keyword">for</span> ( ; cur1 &amp;&amp; cur2 &amp;&amp; cur1-&gt;val == cur2-&gt;val;</span><br><span class="line">          cur1 = cur1-&gt;next, cur2 = cur2-&gt;next)</span><br><span class="line">      &#123;&#125;</span><br><span class="line">      <span class="comment">// 有一个链表还有剩余的元素就表示不相等</span></span><br><span class="line">    <span class="keyword">if</span> (cur1 || cur2)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>重新分配 resize(int)</strong></p><p>由于上文中说到,  当 <strong>hashtable</strong> 中的元素个数超过 <strong>桶 bucket</strong> 大小时, 会重新给 hashtable 分配更大的容量并将所有元素重新分配到新的 <strong>bucket</strong> 里, 对于设计者来说, 这是一个经验之谈. </p><p>但是扩容也带来了性能的不稳定性, 一旦出现大量重复插入的数据, 将导致对于内存和时间的浪费,  如果打过 <code>codeforces</code> 的同学可以知道, <code>unordered_map</code> 会被 hack 掉.  所以对于特定的数据或者场景, 还是慎用 <code>hashtable</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">resize</span>(size_type num_elements_hint)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> size_type old_n = buckets.<span class="built_in">size</span>();</span><br><span class="line">   <span class="comment">// 如果元素个数大于 bucket 最大值, 那么就要扩容并给元素重新分配 bucket</span></span><br><span class="line">  <span class="keyword">if</span> (num_elements_hint &gt; old_n) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type n = <span class="built_in">next_size</span>(num_elements_hint);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; old_n) &#123;</span><br><span class="line">      <span class="function">vector&lt;node*, A&gt; <span class="title">tmp</span><span class="params">(n, (node*) <span class="number">0</span>)</span></span>;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 将原来桶中的元素重新 rehash 到新桶中  </span></span><br><span class="line">        <span class="keyword">for</span> (size_type bucket = <span class="number">0</span>; bucket &lt; old_n; ++bucket) &#123;</span><br><span class="line">          node* first = buckets[bucket];</span><br><span class="line">          <span class="keyword">while</span> (first) &#123;</span><br><span class="line">            size_type new_bucket = <span class="built_in">bkt_num</span>(first-&gt;val, n);</span><br><span class="line">            buckets[bucket] = first-&gt;next;</span><br><span class="line">            first-&gt;next = tmp[new_bucket];</span><br><span class="line">            tmp[new_bucket] = first;</span><br><span class="line">            first = buckets[bucket];          </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buckets.<span class="built_in">swap</span>(tmp);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">      <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">        <span class="keyword">for</span> (size_type bucket = <span class="number">0</span>; bucket &lt; tmp.<span class="built_in">size</span>(); ++bucket) &#123;</span><br><span class="line">          <span class="keyword">while</span> (tmp[bucket]) &#123;</span><br><span class="line">            node* next = tmp[bucket]-&gt;next;</span><br><span class="line">            <span class="built_in">delete_node</span>(tmp[bucket]);</span><br><span class="line">            tmp[bucket] = next;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><p><code>hashtable</code> 也有 <code>insert_equal</code> 和 <code>insert_unique</code> 两种插入方式</p><ul><li>insert_equal: 插入返回的是插入位置的迭代器,  且插入时, 会将所有相同值的节点全部放在一起</li><li>insert_unique: 插入返回的是一个 <code>pair</code> first 为插入后新元素的迭代器, second 为 bool 表示是否插入成功</li></ul><p>同时提供了 <code>ForwardIterator</code> 和 <code>InputIterator</code> 的类型迭代器相对应的不同插入方式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">// 不可重复插入</span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="keyword">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert_unique_noresize</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 可重复插入</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">insert_equal_noresize</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 不可重复插入返回的是pair结构</span></span><br><span class="line">  <span class="function">pair&lt;iterator, <span class="keyword">bool</span>&gt; <span class="title">insert_unique_noresize</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span>;</span><br><span class="line">  <span class="comment">// 可重复插入返回的是迭代器</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal_noresize</span><span class="params">(<span class="keyword">const</span> value_type&amp; obj)</span></span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 以下是insert的各个重载函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="comment">// 针对InputIterator的迭代器</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">insert_unique</span>(f, l, <span class="built_in">iterator_category</span>(f));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(InputIterator f, InputIterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">insert_equal</span>(f, l, <span class="built_in">iterator_category</span>(f));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(InputIterator f, InputIterator l,input_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; f != l; ++f)</span><br><span class="line">      <span class="built_in">insert_unique</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(InputIterator f, InputIterator l,input_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( ; f != l; ++f)</span><br><span class="line">      <span class="built_in">insert_equal</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 针对ForwardIterator类型的迭代器, 一个个进行插入</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(ForwardIterator f, ForwardIterator l,forward_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_unique_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(ForwardIterator f, ForwardIterator l,forward_iterator_tag)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_equal_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(<span class="keyword">const</span> value_type* f, <span class="keyword">const</span> value_type* l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = l - f;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_unique_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type* f, <span class="keyword">const</span> value_type* l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = l - f;</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_equal_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(const_iterator f, const_iterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_unique_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(const_iterator f, const_iterator l)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(f, l, n);</span><br><span class="line">    <span class="built_in">resize</span>(num_elements + n);</span><br><span class="line">    <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n, ++f)</span><br><span class="line">      <span class="built_in">insert_equal_noresize</span>(*f);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/*__STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以发现, 上面所有的方法都调用了 <code>insert_***_noresize</code></p><ul><li><code>insert_unique_noresize</code> 不可重复插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator, <span class="keyword">bool</span>&gt; </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_unique_noresize</span>(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确定插入的桶的具体位置</span></span><br><span class="line">  <span class="keyword">const</span> size_type n = <span class="built_in">bkt_num</span>(obj);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素插入到链表中</span></span><br><span class="line">  <span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next) </span><br><span class="line">      <span class="comment">// 判断该元素在链表中是否已经存在了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)))</span><br><span class="line">      <span class="comment">// 存在pair第二个参数返回false</span></span><br><span class="line">      <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(<span class="built_in">iterator</span>(cur, <span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 元素不存在链表中, 将它插入到链表的头部</span></span><br><span class="line">  node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">  tmp-&gt;next = first;</span><br><span class="line">  buckets[n] = tmp;</span><br><span class="line">  ++num_elements;<span class="comment">// 计数++</span></span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator, <span class="keyword">bool</span>&gt;(<span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>), <span class="literal">true</span>);<span class="comment">// 返回pair结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>insert_equal_noresize</code>可重复插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::iterator </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">insert_equal_noresize</span>(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 确定插入的桶的具体位置</span></span><br><span class="line">  <span class="keyword">const</span> size_type n = <span class="built_in">bkt_num</span>(obj);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将元素插入到链表中</span></span><br><span class="line">  <span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next) </span><br><span class="line">      <span class="comment">// 判断该元素在链表中是否已经存在了, 则将元素插入到重复数据的位置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj))) &#123;</span><br><span class="line">      node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">      tmp-&gt;next = cur-&gt;next;</span><br><span class="line">      cur-&gt;next = tmp;</span><br><span class="line">      ++num_elements;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素不存在链表中, 将它插入到链表的头部</span></span><br><span class="line">  node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">  tmp-&gt;next = first;</span><br><span class="line">  buckets[n] = tmp;</span><br><span class="line">  ++num_elements;<span class="comment">// 计数++</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(tmp, <span class="keyword">this</span>);<span class="comment">// 返回pair结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><ul><li><code>find</code>: 单纯的查找</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="comment">// 找到指定的桶的位置再在链表中进行遍历</span></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">    node* first;</span><br><span class="line">    <span class="comment">// 找到指定的位置并返回</span></span><br><span class="line">    <span class="keyword">for</span> ( first = buckets[n];first &amp;&amp; !<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key);  first = first-&gt;next)</span><br><span class="line">      &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">iterator</span>(first, <span class="keyword">this</span>);</span><br><span class="line">  &#125; </span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>find_or_insert</code>: 如果找到了, 就返回该元素数据, 反之就将指定元素插入到链表的头部, 再返回元素默认数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::reference </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">find_or_insert</span>(<span class="keyword">const</span> value_type&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">resize</span>(num_elements + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  size_type n = <span class="built_in">bkt_num</span>(obj);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line"><span class="comment">// 如果找到了就返回该元素的数据</span></span><br><span class="line">  <span class="keyword">for</span> (node* cur = first; cur; cur = cur-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(cur-&gt;val), <span class="built_in">get_key</span>(obj)))</span><br><span class="line">      <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有找到指定元素就将其插入到链表的头部</span></span><br><span class="line">  node* tmp = <span class="built_in">new_node</span>(obj);</span><br><span class="line">  tmp-&gt;next = first;</span><br><span class="line">  buckets[n] = tmp;</span><br><span class="line">  ++num_elements;</span><br><span class="line">  <span class="keyword">return</span> tmp-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><p>erase有很多个重载函数, 这里就具体分析一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">HashFcn</span>, <span class="keyword">class</span> <span class="title">ExtractKey</span>, <span class="keyword">class</span> <span class="title">EqualKey</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hashtable</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> iterator&amp; it)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> const_iterator&amp; it)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type num_elements_hint)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::size_type </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">erase</span>(<span class="keyword">const</span> key_type&amp; key)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> size_type n = <span class="built_in">bkt_num_key</span>(key);</span><br><span class="line">  node* first = buckets[n];</span><br><span class="line">  size_type erased = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到key具体在哪一个链表</span></span><br><span class="line">  <span class="keyword">if</span> (first) &#123;</span><br><span class="line">    node* cur = first;</span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">      <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span> (next) &#123;</span><br><span class="line">        <span class="comment">// 元素在中间</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(next-&gt;val), key)) &#123;</span><br><span class="line">        cur-&gt;next = next-&gt;next;</span><br><span class="line">        <span class="built_in">delete_node</span>(next);</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        ++erased;</span><br><span class="line">        --num_elements;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 在头部</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = next;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 析构, 释放</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">equals</span>(<span class="built_in">get_key</span>(first-&gt;val), key)) &#123;</span><br><span class="line">      buckets[n] = first-&gt;next;</span><br><span class="line">      <span class="built_in">delete_node</span>(first);</span><br><span class="line">      ++erased;</span><br><span class="line">      --num_elements;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> erased;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">erase_bucket</span>(<span class="keyword">const</span> size_type n, node* last)</span><br><span class="line">&#123;</span><br><span class="line">  node* cur = buckets[n];</span><br><span class="line">  <span class="keyword">while</span> (cur != last) &#123;</span><br><span class="line">    node* next = cur-&gt;next;</span><br><span class="line">    <span class="built_in">delete_node</span>(cur);</span><br><span class="line">    cur = next;</span><br><span class="line">    buckets[n] = cur;</span><br><span class="line">    --num_elements;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    node* cur = buckets[i];</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="number">0</span>) &#123;</span><br><span class="line">      node* next = cur-&gt;next;</span><br><span class="line">      <span class="built_in">delete_node</span>(cur);</span><br><span class="line">      cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    buckets[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  num_elements = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现, 其操作本质还是找到对应的桶后, 进行链表操作.</p><p><strong>复制</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">HF</span>, <span class="keyword">class</span> <span class="title">Ex</span>, <span class="keyword">class</span> <span class="title">Eq</span>, <span class="keyword">class</span> <span class="title">A</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> hashtable&lt;V, K, HF, Ex, Eq, A&gt;::<span class="built_in">copy_from</span>(<span class="keyword">const</span> hashtable&amp; ht)</span><br><span class="line">&#123;</span><br><span class="line">  buckets.<span class="built_in">clear</span>(); <span class="comment">//把元素全部删除</span></span><br><span class="line">  buckets.<span class="built_in">reserve</span>(ht.buckets.<span class="built_in">size</span>());<span class="comment">// 重新调整桶的大小</span></span><br><span class="line">    <span class="comment">// 重新插入</span></span><br><span class="line">  buckets.<span class="built_in">insert</span>(buckets.<span class="built_in">end</span>(), ht.buckets.<span class="built_in">size</span>(), (node*) <span class="number">0</span>);</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">      <span class="comment">// 插入</span></span><br><span class="line">    <span class="keyword">for</span> (size_type i = <span class="number">0</span>; i &lt; ht.buckets.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">const</span> node* cur = ht.buckets[i]) &#123;</span><br><span class="line">        node* copy = <span class="built_in">new_node</span>(cur-&gt;val);</span><br><span class="line">        buckets[i] = copy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (node* next = cur-&gt;next; next; cur = next, next = cur-&gt;next) &#123;</span><br><span class="line">          copy-&gt;next = <span class="built_in">new_node</span>(next-&gt;val);</span><br><span class="line">          copy = copy-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    num_elements = ht.num_elements;</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(<span class="built_in">clear</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><code>hashtbale</code> 选用开链法来处理 hash 冲突</p></li><li><p>采用质数作为桶的容量, 并在元素个数大于桶大小时扩容并进行 rehash</p></li><li><p>与 <code>RB-tree</code>:</p><ol><li>再插入过程中, 前者平均是 O(1), 后者为 O(nlogn)</li><li>前者插入是无序的, 后者是有序的</li><li>前者桶满后效率很低, 后者不会考虑到满</li><li>两者都实现了可重复和不可重复</li><li>前者正向迭代器, 没有 <code>operator--</code>, 后者迭代器实现了 <code>operator--</code></li></ol></li><li><p>至于 <strong>hash function</strong> ,  又其他头文件定义, hashtable 只是进行调用, 并不属于 hashtable 容器, 所以不再进行</p><p>分析, 且对于一些类型, 标准库并没有提供 <code>hash function</code> <strong>(标准库不可能提前知道你要建立的类型是什么)</strong> 需要用户自己去定义 <code>hash function</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL, hashtable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>POST 和 GET 的区别</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/POST%20%E5%92%8C%20GET%20%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/POST%20%E5%92%8C%20GET%20%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="POST-和-GET-的区别"><a href="#POST-和-GET-的区别" class="headerlink" title="POST 和 GET 的区别"></a>POST 和 GET 的区别</h1><p><a href="https://juejin.cn/post/7001782277063573518">转自</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>无论是 POST 还是 GET 请求, 都是基于 HTTP 的, 而 HTTP 协议是 TCP/IP 协议族的应用层协议</p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><ul><li><strong>GET: 获取资源</strong>, 用来请求访问已被 URI (同意资源标识符, 和 URL 是包含和被包含关系) 识别的资源</li><li><strong>POST:  用来传输实体的主体</strong>, GET 也可以实现, 但是一般不使用</li><li>**PUT: 传输文件, ** 但是鉴于 PUT 方法本身不带验证机制, 任何人都可以上传文件, 存在安全性问题, 因此网站一般都不使用该方法</li><li><strong>HEAD: 获得报文首部</strong>, 和 GET 请求一样, 只是不返回报文主体部分.</li><li><strong>DELETE: 删除文件</strong>, 同样不带验证机制, 存在安全性问题</li><li><strong>OPTIONS: 询问指定的请求 URI 支持哪些方法</strong></li><li><strong>CONNECT: 要求在与代理服务器通信时建立隧道</strong>, 实现隧道协议进行 TCP 通信</li></ul><h2 id="GET-和-POST"><a href="#GET-和-POST" class="headerlink" title="GET 和 POST"></a>GET 和 POST</h2><ul><li>本质上都 <strong>TCP 连接</strong>, 并无差别</li><li>由于 **HTTP 的规定和浏览器/服务器的限制, ** 导致其在实际应用过程中会体现出一些区别</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>GET 在浏览器回退时是无害的, 而 POST 会再次提交请求</li><li>GET 产生的 URL 地址可以被 Bookmark, 而 POST 不可以</li><li>GET 请求会被浏览器主动 cache, 而 POST 不会, 除非手动设置</li><li>GET 请求只能进行 URL 编码, 而 POST 支持多种编码方式.</li><li>GET 请求的参数会被完整保留在浏览器历史记录里, 而 POST 中的参数不会被保留</li><li><strong>GET 请求在 URL 中传送的参数是有长度限制的, 而 POST 没有</strong></li><li>对参数的数据类型, GET 只接受 ASCII 字符, 而 POST 没有限制</li><li><strong>GET 比 POST 更不安全</strong>, 因为参数直接暴露在 URL 上, 所以不能用来传递敏感信息</li><li>GET 参数通过 URL 传递, POST 则放在 Request body 中</li></ul><h3 id="参数长度"><a href="#参数长度" class="headerlink" title="参数长度"></a>参数长度</h3><p>GET 请求长度最多 <strong>1024kb</strong>, POST 对请求数据<strong>没有限制</strong></p><p>HTTP 协议没有 Body 和 URL 的长度限制, POST 对请求数据<strong>没有限制</strong></p><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>POST 比 GET 安全, 因为数据在地址栏上不可见, 然而, 从传输的角度来说, 其都是不安全的, 因为 HTTP 在网络上都是明文传输, 只要在网络节点上抓包,  就可以完整地获取数据报文.</p><p>只有使用 HTTPS 才能加密安全</p><h2 id="POST-与-GET-小结"><a href="#POST-与-GET-小结" class="headerlink" title="POST 与 GET 小结"></a>POST 与 GET 小结</h2><ul><li><p><strong>参数长度:</strong> GET 请求长度最多 1024 kb, POST 对请求数据没有限制</p></li><li><p>**请求参数: ** GET 请求参数是通过 URL 传递的, 多个参数以 &amp; 连接, POST 请求放在 request body 中</p></li><li><p><strong>请求缓存:</strong>  GET 会请求缓存, 而 POST 请求不会, 除非手动设置</p></li><li><p><strong>收藏为书签:</strong> GET 请求支持, POST 请求不支持</p></li><li><p><strong>安全性:</strong> POST 比 GET 安全, GET 请求在浏览器回退时是无害的, 而 POST 会再次请求</p></li><li><p><strong>历史记录:</strong> GET 请求参数会被完整保留在浏览器历史记录里, 而 POST 中的参数不会被保留</p></li><li><p><strong>编码方式:</strong> GET 请求只能进行 URL 编码, 而 POST 支持多种编码方式</p></li><li><p>对参数的数据类型: GET 只接受 ASCII 字符, 而 POST 没有限制</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> post, get </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 编译器中的优化</title>
      <link href="/C/C++-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>/C/C++-%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="C-编译器中的优化"><a href="#C-编译器中的优化" class="headerlink" title="C++ 编译器中的优化"></a>C++ 编译器中的优化</h1><ul><li><p>原文 <a href="https://queue.acm.org/detail.cfm?id=3372264">Optimizations in C++ Compilers</a></p></li><li><p>作者 <a href="https://www.linkedin.com/in/godbolt/">Matt Godbolt</a></p></li><li><p>翻译 <a href="https://fuzhe1989.github.io/">Fu Zhe’s Blog</a></p></li></ul><p>在将上层容易写的代码转换为高效的由计算机去执行的机器码的过程中，编译器必不可少。但它们在其中完成的复杂工作却常常被人忽视。你也许会花许多时间来慎重考虑算法和解决错误，但可能没有足够的时间关注编译器能做什么。</p><p>本文介绍了一些编译器和代码生产方面的概念，之后着重介绍一些你的编译器为你所做的令人印象深刻的转换工作，以及我最喜欢的优化方式的一些实际例子。希望你能了解编译器可以做哪些优化，以及如何进一步探索该主题。最重要的是，你可能也会爱上看汇编输出，并开始对编译器的工程质量肃然起敬。</p><p>本文举的都是C/C++的例子，这是我最有经验的语言。但其中的许多优化方法也适用于其它编译语言。事实上，像LLVM这样的前端不可见的编译器工具包的出现意味着多数优化方法都会以相同方式作用在Rust/Swift/D语言等语言上。</p><h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>我一直着迷于编译器能做什么。我曾经花了10年去制作一款视频游戏，并力争在相同CPU周期数下得到比竞争对手更多的精灵（sprite）、爆炸效果，或更复杂的场景。因此手写汇编和直接看汇编输出就成了我的基本技能。</p><p>5年后，我当时在一家交易公司工作，精灵和多边形换成了快速处理金融数据。和以前一样，知道编译器对代码的处理有助于了解我们如何去写代码。</p><p>显然，写得好的，容易测的代码非常重要——尤其是如果这些代码可能一秒完成几千笔金融交易。跑得快很重要，但不出bug更重要。</p><p>2012年时，我们在讨论可以把C++11的哪个新特性加入可接受的编码实践标准。当每一纳秒都很重要时，最好能给出不伤害性能的编码建议。在试验如何使用如<code>auto</code>、lambda、<code>range-for</code>时，我写了一个shell来持续编译并显示过滤后的输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ /tmp/test.cc -O2 -c -S -o - -masm=intel \</span><br><span class="line">    | c++filt \</span><br><span class="line">    | grep -vE <span class="string">&#x27;\s+\.&#x27;</span></span><br></pre></td></tr></table></figure><p>事实证明，这个脚本对于回答所有的“what if”问题都很有用，我当天晚上回家就写了Compiler Explorer。</p><p>这些年我一直惊讶于编译器为了将我们的代码转换为如艺术品般的汇编指令所做的工作。为了了解编译器做的事情，我建议所有用编译语言的程序员都学一点汇编语言。即使你自己不写，能读懂汇编也很有用。</p><p>本文中的所有汇编代码都是针对X86-64处理器的，这是我最熟悉的CPU，也是最常见的架构之一。一些例子只用于X86,但事实上许多优化方法很容易应用到其它架构上。另外，我只用到了GCC和Clang两种编译器，但Microsoft Visual Studio和Intel的编译器也有同样聪明的优化方法。</p><h2 id="优化入门"><a href="#优化入门" class="headerlink" title="优化入门"></a>优化入门</h2><p>不需要深入编译器的优化，只了解一些编译器会用到的概念就很有用。</p><p>许多优化方法属于<strong>强度降低（strenth reduction）</strong>的范畴：将昂贵的操作转换为代价更低的操作。一个非常简单的例子是在循环中对循环变量使用乘法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func</span>(i * <span class="number">1234</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里强度降低法将使用了乘法的循环转换为了只用加法的循环。</p><p>后面的实际示例将会显示更多的强度降低方法。</p><p>另一个关键优化是<strong>内联（inlining）</strong>，即编译器将函数调用替换为函数体本身。它可以去掉调用的开销，因为编译器能将组合在一起的代码优化为一个编译单元，经常还能解锁进一步的优化。稍后你会看到大量这方面的例子。</p><p>其它优化类别包括：</p><ul><li>常量折叠（constant folding）。编译器将编译期能计算为常量的表达式直接替换为计算结果。</li><li>常量传播（constant propagation）。编译器追踪到一个值的源头，发现它是常量后，会将所有地方出现的这个值替换为常量。</li><li>公共子表达式消除（common subexpression elimination）。将重复的计算过程重写掉，只算一次，其它地方复制结果。</li><li>移除死代码（dead code removal）。用许多其它方法优化后，可能有些代码对输出不产生影响，就可以移除这些代码。这里包含了对没用到的值的读写操作，以及完全没用到的整个函数或表达式。</li><li>指令选择（instruction selection）。这个不算是通常意义的优化，但既然编译器会将程序转换为它的内部表示形式，并生成CPU指令，编译器通常有一个庞大的等效指令序列的集合可供选择。编译需要知道目标处理器架构的细节以作出正确选择。</li><li>移动循环中的不变代码（loop invariant code movement）。编译器能识别一块代码在循环过程中值不变，并将这块代码移出循环。其于此，编译器还能将循环中不变的条件检查移出循环外，再将循环体复制两次：一次针对条件为真，一次针对条件为假。之后还能做进一步优化。</li><li>窥孔优化（peephole optimization）。编译器取一小段指令序列并做局部优化。</li><li>尾调用移除（tail call removal）。一个在结尾处调用自身的递归函数通常可被重写为循环，从而降低函数调用开销，并减小栈溢出的可能。</li></ul><p>帮助编译器进行优化的要点就是保证它能获得尽可能多地信息，从而做出正确的优化决定。其中一个信息源就是你的代码：编译器能看到的代码越多，能做的决定越优。另一个信息源是你用的编译器配置：告诉编译器准确的目标CPU架构就能带来大不同。当然，编译器拥有的信息越多，编译时间越长，因此这里还要保持平衡。</p><p>我们看个例子，统计一个<code>vector</code>中通过测试的元素个数（GCC -O3编译，<a href="https://godbolt.org/z/acm19_count1%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_count1）：</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numPassed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">testFunc</span>(vec[i]))</span><br><span class="line">            numPassed++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numPassed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果编译器对<code>testFunc</code>一无所知，它会产生这样的内循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.L4:</span><br><span class="line">  mov edi, DWORD PTR [rdx+rbx*4] ; read rbx&#x27;th element of vec</span><br><span class="line">                                 ; (inlined vector::operator [])</span><br><span class="line">  call testFunc(int)             ; call test function</span><br><span class="line">  mov rdx, QWORD PTR [rbp+0]     ; reread vector base pointer</span><br><span class="line">  cmp al, 1                      ; was the result of test true?</span><br><span class="line">  mov rax, QWORD PTR [rbp+8]     ; reread the vector end pointer</span><br><span class="line">  sbb r12d, -1                   ; add 1 if true, 0 if false</span><br><span class="line">  inc rbx                        ; increment loop counter</span><br><span class="line">  sub rax, rdx                   ; subtract end from begin...</span><br><span class="line">  sar rax, 2                     ; and divide by 4 to get size()</span><br><span class="line">                                 ; (inlined vector::size())</span><br><span class="line">  cmp rbx, rax                   ; does loop counter equal size()?</span><br><span class="line">  jb .L4                         ; loop if not</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了理解这段代码，知道<code>std::vector</code>包含一些指针会很有用：一个指向数据的开始，一个指向数据的结尾，一个指定当前分配的存储空间的结尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> _<span class="title">Vector_impl</span> &#123;</span></span><br><span class="line">  T *_M_start;</span><br><span class="line">  T *_M_finish;</span><br><span class="line">  T *_M_end_of_storage;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>ector不直接存储它的大小，而是依赖<code>begin()</code>和<code>end()</code>的差值计算得到。注意<code>vector&lt;&gt;::size()</code>和<code>vector&lt;&gt;::operator[]</code>已经被彻底内联掉了。</p><p>在上面的汇编代码中，<code>ebp</code>指向vector对象，<code>begin()</code>和<code>end()</code>指针因此分别是<code>QWORD PTR [rbp+0]</code>和<code>QWORD PTR [rpb+8]</code>。</p><p>另一个编译器用到的技巧是移除分支：你也许有理由地期望<code>if (testFunc(...))</code>会变成比较和分支。这里编译器会用<code>cmp al, 1</code>进行比较，如果<code>testFunc()</code>返回<code>false</code>，<code>cmp</code>指令会设置CPU的进位标志，否则清除进位标志。之后<code>sbb r12d, -1</code>指令会带借位地减-1。减法等效于进位，也会用到进位标志。这会产生编译器想要的副作用：如果进位标志被清除了（<code>testFunc()</code>返回了<code>true</code>），它就会减-1,相当于加1；如果进位标志被设置了，它会减-1再加1，不改变原值。在一些CPU不好预测分支的情况下，避免分支会有帮助。</p><p>编译器每次循环都会重新载入<code>begin()</code>和<code>end()</code>指针，这可能令人惊讶，事实上它每次还会重新去拿<code>size()</code>。但编译器必须这么做：它不知道<code>testFunc()</code>会做什么，必须假设最坏情况。也就是，它必须假设调用<code>testFunc()</code>可能导致<code>vec</code>被修改。因为以下原因，这里<code>const</code>引用不会开启进一步的优化：<code>testFunc()</code>可能持有<code>vec</code>的非<code>const</code>引用，或者<code>testFunc()</code>会使用<code>const_cast</code>。</p><p>但如果编译器能看到<code>testFunc()</code>的函数体，因此得知它不会修改<code>vec</code>，故事就很不一样了（<a href="https://godbolt.org/z/acm19_count2%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_count2）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.L6:</span><br><span class="line">  mov edi, DWORD PTR [rdx]  ; read next value</span><br><span class="line">  call testFunc(int)        ; call testFunc with it</span><br><span class="line">  cmp al, 1                 ; check return code</span><br><span class="line">  sbb r8d, -1               ; add 1 if true, 0 otherwise</span><br><span class="line">  add rdx, 4                ; move to next element</span><br><span class="line">  cmp rcx, rdx              ; have we hit the end?</span><br><span class="line">  jne .L6                   ; loop if not</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时编译器已经知道了<code>vector</code>的<code>begin()</code>和<code>end()</code>在循环过程中是不变的。它也因此知道了<code>size()</code>的值是不变的。因此编译器可以将这些常量的计算移出循环，再将索引操作（<code>vec[i]</code>）重写为从<code>begin()</code>开始，每次移动一个<code>int</code>，直到<code>end()</code>的指针遍历。这极大简化了生成的汇编代码。</p><p>这个例子中我提供了一个<code>testFunc</code>函数，但将其标记为不可内联（GNU扩展）来单独展示这一优化。在更实际的代码库中，如果编译器觉得有好处，它是可以内联掉<code>testFunc</code>的。</p><p>另一个不暴露函数体就能启用这一优化的方法是标记<code>testFunc</code>为<code>[[gnu:pure]]</code>（另一个语言扩展）。它是向编译器保证这是个纯函数——功能只与它的参数有关，不带任何副作用。</p><p>有趣的是，第一个例子中如果我们使用<code>range-for</code>，编译器就算不知道<code>testFunc</code>会不会修改<code>vec</code>，也会生成优化版本的汇编代码（<a href="https://godbolt.org/z/acm19_count3%EF%BC%89%E3%80%82%E8%BF%99%E6%98%AF%E5%9B%A0%E4%B8%BA%60range-for%60%E8%A2%AB%E5%AE%9A%E4%B9%89%E4%B8%BA%E4%BA%86%E5%B0%86%60begin()%60%E5%92%8C%60end()%60%E4%BF%9D%E5%AD%98%E5%88%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%98%E6%8D%A2%EF%BC%9A">https://godbolt.org/z/acm19_count3）。这是因为`range-for`被定义为了将`begin()`和`end()`保存到局部变量的代码变换：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (auto val : vec)</span><br><span class="line">&#123;</span><br><span class="line">    if (testFunc(val))</span><br><span class="line">        numPassed++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被解释为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> __begin = <span class="built_in">begin</span>(vec);</span><br><span class="line">    <span class="keyword">auto</span> __end == <span class="built_in">end</span>(vec);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> __it = __begin; __it != __end; ++__it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">testFunc</span>(*__it))</span><br><span class="line">            numPassed++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑各种因素，如果你需要裸写循环，推荐使用现代的<code>range-for</code>：它在编译器看不到函数体时也能生成优化代码，且更清晰。但更好的方法是用STL的<code>count_if</code>完成所有工作：编译器也会生成优化代码（<a href="https://godbolt.org/z/acm19_count4%EF%BC%89%E3%80%82">https://godbolt.org/z/acm19_count4）。</a></p><p>在传统的一次一个编译单元的编译模型下，函数调用处通常看不到函数体，只能看到函数声明。LTO（链接时优化，也称作LTCG，链接时代码生成）允许编译器看到跨编译单元的代码。在LTO中，单个编译单元会被编译为中间代码，而不是机器码。在链接时——整个程序（或动态链接库）都可见时——再去生成机器码。编译器可以利用这点跨编译单元内联，或至少能知道被调用的函数有没有副作用，从而进行优化。</p><p>通常在需要优化的构建中启用LTO是不错的选择，这样编译器就能看到整个程序了。我现在依赖于LTO将更多的函数体移出头文件，从而减少耦合程序、编译时间、debug构建和测试中的依赖，且还能在最终构建产物中达到想要的性能。</p><p>尽管LTO已经是很成熟的技术了（我在21世纪初的XBOX上就用过了LTCG），我仍然惊讶于只有很少的项目使用了LTO。部分原因可能是程序员无意间依赖了编译器的未定义行为，这种行为（优化）只有在编译器有更高的可见性（看到更多代码）时才会变得更明显：我知道我犯了这样的错误。</p><h2 id="我最喜欢的优化示例"><a href="#我最喜欢的优化示例" class="headerlink" title="我最喜欢的优化示例"></a>我最喜欢的优化示例</h2><p>过去这些年我收集了不少有趣的真实世界中的优化示例，既有来自我自己代码的第一手经验，也有来自在Compiler Explorer上帮助其他人理解代码的经验。下面是我最喜欢的，展示了编译器有多聪明的几个例子。</p><h3 id="除数为常量的整数除法"><a href="#除数为常量的整数除法" class="headerlink" title="除数为常量的整数除法"></a>除数为常量的整数除法</h3><p>（直到最近）我们可能惊讶于整数除法是现代CPU能执行的最昂贵的操作。除法比加法慢50倍以上，比乘法慢10倍以上。（这一说法直到Intel的Cannon Lake之前都成立，Cannon Lake将64位整数除法的最大延时从96个周期降为了18个周期。这样除法就只比加法慢20倍，比乘法慢5倍。）</p><p>庆幸的是，当除数为常量时，编译器作者有一些降低强度的技巧。我相信大家都知道当除数为2的整数次幂时，除法可以替换为逻辑右移——请放心，编译器会帮你做的。我建议不要在代码里写<code>&lt;&lt;</code>做除法；让编译器帮你做。这样会更清晰，编译器也知道怎么正确处理有符号数：整数除法朝0的方向截断，而负数自身移位会朝着负无穷的方向截断。</p><p>但是，如果你除的不是2的整数幂呢？你会失去运气吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">divideByThree</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>幸运的是编译器又一次站在了你身后。这段代码被编译为（<a href="https://godbolt.org/z/acm19_div3%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_div3）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">divideByThree(unsigned int):</span><br><span class="line">  mov eax, edi          ; eax = edi</span><br><span class="line">  mov edi, 2863311531   ; edi = 0xaaaaaaab</span><br><span class="line">  imul rax, rdi         ; rax = rax * 0xaaaaaaab</span><br><span class="line">  shr rax, 33           ; rax &gt;&gt;= 33</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>其中看不到除法指令。只是一次移位，以及乘一个奇怪的巨大的常数：输入的32位无符号整数乘上<code>0xaaaaaaab</code>，结果是一个64位整数，再右移33位。编译器将除法替换为了更廉价的定点乘法逆运算。这里的定点是33位，常数是这种形式下的1/3（实际是0.33333333337213844）。编译器有种算法来决定合适的定点和常数值，同时在输入范围内以相同的精度保留与真正的除法运算相同的四舍五入。有时这需要一些额外的运算——例如除以1023（<a href="https://godbolt.org/z/acm19_div1023%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_div1023）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">divideBy1023(unsigned int):</span><br><span class="line">  mov eax, edi</span><br><span class="line">  imul rax, rax, 4198405</span><br><span class="line">  shr rax, 32</span><br><span class="line">  sub edi, eax</span><br><span class="line">  shr edi</span><br><span class="line">  add eax, edi</span><br><span class="line">  shr eax, 9</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>该算法广为人知，在《<a href="https://book.douban.com/subject/1784887/">Hacker’s Delight</a>》中有大量记录。</p><p>简而言之，你可以依靠编译器通过编译期已知的常量来很好地优化除法。</p><p>你可能在想：这为什么是如此重要的优化方法？我们执行除法的频率是多少？它不光与除法本身有关，还与相关的取余操作有关，后者常被用于hash-map实现中将hash值映射到hash桶数范围的操作中。</p><p>知道这里编译器能做什么可以通往有趣的hash-map实现。一种方法是使用固定数量的桶以允许编译器产生完美的不使用昂贵的除法指令的取余。</p><p>大多数hash-map支持rehash到不同数量的桶。朴素的实现会用运行期才知道的数字去取余，导致编译器只能用慢的除法指令。事实上gcc的libstdc++实现中的<code>std::unordered_map</code>就是这么做的。</p><p>Clang的libc++往前走了一步：它会检查桶的数量是否是2的幂，如果是的话就跳过除法指令，转而使用逻辑与。桶数量是2的幂的想法很诱人，因为它使模运算变快了，但它要依靠好的hash函数实现来避免频繁冲突。而质数个桶可以在非常简单的hash函数时也能很好地避免冲突。</p><p>诸如<code>boost::multi_index</code>这样的库又往前走了一步：与其保存实际的桶数，不如使用固定的质数作为桶数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">reduce</span><span class="params">(<span class="keyword">size_t</span> hash, <span class="keyword">int</span> bucketCountIndex)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (tableSizeIndex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> hash % <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> hash % <span class="number">17</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> hash % <span class="number">37</span>;</span><br><span class="line">        <span class="comment">// and so on...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样编译器对于所有可能的hash-map大小都能产生完美的取余代码，仅有的额外开销就是<code>switch</code>中的分派代码。</p><p>gcc9有一个技巧来检查是否可被非2的幂整除（<a href="https://godbolt.org/z/acm19_multof3%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_multof3）：</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">divisibleBy3</span><span class="params">(<span class="keyword">unsigned</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;          </span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">divisibleBy3(unsigned int):</span><br><span class="line">  imul edi, edi, -1431655765    ; edi = edi * 0xaaaaaaab</span><br><span class="line">  cmp edi, 1431655765 ; compare with 0x55555555</span><br><span class="line">  setbe al                      ; return 1 if edi &lt;= 0x55555555</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>Daniel Lemire的<a href="https://lemire.me/blog/2019/02/08/faster-remainders-when-the-divisor-is-a-constant-beating-compilers-and-libdivide/">博客</a>中很好地解释了这种表面上的巫术。另外，运行时也有可能用到这些整数除法的技巧。如果你需要用相同的除数去除很多数字，你可以用像<a href="https://libdivide.com/"><code>libdivide</code></a>这样的库。</p><h3 id="统计为1的位数"><a href="#统计为1的位数" class="headerlink" title="统计为1的位数"></a>统计为1的位数</h3><p>有多少次你想知道，一个整数中有多少位是1？也许没那么频繁。但事实证明，这种简单的操作在许多情况下非常有用。例如，计算两个位集合的hamming距离，处理稀疏矩阵的紧凑表示，或处理向量运算的结果。</p><p>你可能会写这样的函数来统计1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSetBits</span><span class="params">(<span class="keyword">unsigned</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        a &amp;= (a - <span class="number">1</span>); <span class="comment">// clears the bottom set bit</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是其中的位运算技巧<code>a &amp;= (a - 1)</code>，它会清除最低位的1。在纸上证明这一点很有意思，试一下吧。</p><p>目标架构是Haswell时，gcc8.2会产生这样的汇编（<a href="https://godbolt.org/z/acm19_bits%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_bits）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">countSetBits(unsigned int):</span><br><span class="line">  xor eax, eax      ; count = 0</span><br><span class="line">  test edi, edi     ; is a == 0?</span><br><span class="line">  je .L4            ; if so, return</span><br><span class="line">.L3:</span><br><span class="line">  inc eax           ; count ++</span><br><span class="line">  blsr edi, edi     ; a &amp;= (a - 1);</span><br><span class="line">  jne .L3           ; jump back to L3 if a != 0</span><br><span class="line">  ret  </span><br><span class="line">.L4:</span><br><span class="line">  Ret</span><br></pre></td></tr></table></figure><p>请注意gcc如何巧妙地找到了<code>BLSR</code>指令来去掉最低位的1。很干净，但还是不如Clang7.0聪明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">countSetBits(unsigned int):</span><br><span class="line">  popcnt eax, edi     ; count = number of set bits in a</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>这个操作足够通用，大多数CPU都有一条指令可以一次完成：<code>POPCNT</code>（population count）。Clang聪明到将C++中的整个循环简化为一条指令。这是良好的指令选择的非常棒的例子：Clang的代码生成器认出了这个模式，并能选出最好的指令。</p><p>前面我对gcc有点不公平，gcc9也实现了这种方法，但还有点区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">countSetBits(unsigned int):</span><br><span class="line">  xor eax, eax          ; count = 0</span><br><span class="line">  popcnt eax, edi       ; count = number of set bits in a</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>第一眼看上去不够优化：为什么要写一个马上被<code>POPCNT</code>指令的返回值覆盖的0呢？</p><p>简单研究之后，我们找到了Intel CPU的勘误SKL029：“<code>POPCNT</code>指令的执行时间可能比预期要长”——这是CPU的bug！尽管<code>POPCNT</code>指令的输出会完全覆盖<code>eax</code>寄存器，它被错误地标记为依赖于<code>eax</code>之前的值。这会限制CPU将<code>POPCNT</code>指令调度到它前面的对<code>eax</code>写操作完成后执行——尽管它们完全没关系。</p><p>gcc的解法是破除对<code>eax</code>的依赖：CPU将<code>xor eax, eax</code>视作打破依赖的惯用法。不会有<code>POPCNT</code>之前指令可以在<code>xor eax, eax</code>之后还影响到<code>eax</code>的值了，因此<code>POPCNT</code>可以在它的输入<code>edi</code>准备好后立即执行。</p><p>这只会影响Intel的CPU，而且看起来在Cannon Lake中已经修复了，但gcc在目标为Cannon Lake时仍然会产生<code>xor</code>指令。</p><h3 id="链式条件"><a href="#链式条件" class="headerlink" title="链式条件"></a>链式条件</h3><p>也许你从未需要统计一个整数中1的数量，但你也许写过这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isWhitespace</span><span class="params">(<span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27; &#x27;</span></span><br><span class="line">      || c == <span class="string">&#x27;\r&#x27;</span></span><br><span class="line">      || c == <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">      || c == <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我本能地以为生成的代码会充满比较和分支，但Clang和gcc都用了一个技巧令这段代码非常高效。下面是gcc9.1的输出（<a href="https://godbolt.org/z/acm19_conds%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_conds）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">isWhitespace(char):</span><br><span class="line">  xor eax, eax              ; result = false</span><br><span class="line">  cmp dil, 32               ; is c &gt; 32</span><br><span class="line">  ja .L4                    ; if so, exit with false</span><br><span class="line">  movabs rax, 4294977024    ; rax = 0x100002600</span><br><span class="line">  shrx rax, rax, rdi        ; rax &gt;&gt;= c</span><br><span class="line">  and eax, 1                ; result = rax &amp; 1</span><br><span class="line">.L4:</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>编译器将一系列比较转换为了查表。加载到<code>rax</code>中的魔数是一个33位的查找表，表中为1的位置是你需要返回<code>true</code>的情况（下标为32、13、10、9，分别对应<code> </code>、<code>\r</code>、<code>\n</code>、<code>\t</code>）。之后移位和<code>&amp;</code>就可以取到第<code>c</code>位并返回。Clang生成的代码与之有细微差别，但大体上等价。这是另一个强度降低的例子。</p><p>我被这种优化惊到了。在使用Compiler Explorer调查问题之前，我会假设我比编译器更懂，因此会手写这样的代码。</p><p>但在试验时我发现一件不幸的事（至少对于gcc）：比较的顺序可以影响编译器能不能做这种优化。如果你交换了<code>\r</code>和<code>\n</code>的顺序，gcc会生成如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isWhitespace(char):</span><br><span class="line">  cmp dil, 32   ; is c == 32?</span><br><span class="line">  sete al       ; al = 1 if so, else 0</span><br><span class="line">  cmp dil, 10   ; is c == 10?</span><br><span class="line">  sete dl       ; dl = 1 if so, else 0</span><br><span class="line">  or al, dl     ; al |= dl</span><br><span class="line">  jne .L3       ; if al is non-zero return it (c was ` ` or `\n`)</span><br><span class="line">  and edi, -5   ; clear bit 2 (the only bit that differs between</span><br><span class="line">                ;              `\r` and `\t`)</span><br><span class="line">  cmp dil, 9    ; compare with `\t`</span><br><span class="line">  sete al       ; dl = 1 if so, else 0</span><br><span class="line">.L3:</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>用<code>and</code>将对<code>\r</code>和<code>\n</code>的比较合并到一起绝对是非常巧妙的，但看起来它会导致生成比之前的例子更差的代码。<a href="http://quick-bench.com/0TbNkJr6KkEXyy6ixHn3ObBEi4w">Quick Bench上的一个简化测试</a>表明，在可预测的紧凑循环中，基于比较的版本可能会稍快一点点。是谁说这东西简单的？</p><h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><p>有时你需要将一堆东西加起来。编译器非常擅长利用大多数现代CPU都支持的向量指令来加速求和，因此下面这段非常直接的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumSquared</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        res += i * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转化后的核心循环长这样（<a href="https://godbolt.org/z/acm19_sum%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_sum）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.loop:</span><br><span class="line">  vmovdqu ymm2, YMMWORD PTR [rax]   ; read 32 bytes into ymm2</span><br><span class="line">  add rax, 32                       ; advance to the next element</span><br><span class="line">  vpmulld ymm0, ymm2, ymm2          ; square ymm2, treating as</span><br><span class="line">                                    ;   8 32-bit values</span><br><span class="line">  vpaddd ymm1, ymm1, ymm0           ; add to sub-totals</span><br><span class="line">  cmp rax, rdx                      ; have we reached the end?</span><br><span class="line">  jne .loop                         ; if not, keep looping</span><br></pre></td></tr></table></figure><p>通过将总和分成8个部分和，编译器每条指令能处理8个值。最后它再将所有部分和汇总为最终的总和。这相当于把代码重写成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res_[] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (; index &lt; v.<span class="built_in">size</span>(); index += <span class="number">8</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// This can be performed by parallel instructions without</span></span><br><span class="line">    <span class="comment">// an actual loop. The following boils down to a couple</span></span><br><span class="line">    <span class="comment">// of vector instructions:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> val = v[index + j];</span><br><span class="line">        res_[j] += val * val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">res = res_[<span class="number">0</span>] + res_[<span class="number">1</span>]</span><br><span class="line">    + res_[<span class="number">2</span>] + res_[<span class="number">3</span>]</span><br><span class="line">    + res_[<span class="number">4</span>] + res_[<span class="number">5</span>]</span><br><span class="line">    + res_[<span class="number">6</span>] + res_[<span class="number">7</span>];</span><br></pre></td></tr></table></figure><p>只要简单地将编译器的优化级别设置得足够高，并设置合适的目标CPU架构，向量化就自己完成了。太棒了！</p><p>这要依赖于一个事实，将总和分成若干个部分和，最终再加起来，等效于按顺序累加。显然对于整数这是对的，但对于浮点数就不一定了。浮点数是不可结合的：<code>(a+b)+c</code>不等价于<code>a+(b+c)</code>，因为浮点加法的结果精度依赖于两个输入的相对量级。</p><p>这就意味着，很不幸，将<code>vector&lt;int&gt;</code>改为<code>vector&lt;float&gt;</code>得不到你想要的代码。编译器可以用一些向量指令（它可以一次算8个值的平方），但必须按顺序累加这些值（<a href="https://godbolt.org/z/acm19_sumf%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_sumf）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">.loop:</span><br><span class="line">  vmovups ymm4, YMMWORD PTR [rax]   ; read 32 bytes into ymm4</span><br><span class="line">  add rax, 32                       ; advance</span><br><span class="line">  vmulps ymm1, ymm4, ymm4           ; square 8 floats</span><br><span class="line">                                    ; (the one parallel operation)</span><br><span class="line">  vaddss xmm0, xmm0, xmm1           ; accumulate the first value</span><br><span class="line">  vshufps xmm3, xmm1, xmm1, 85      ; shuffle things around</span><br><span class="line">                                    ; (permutes the 8 floats</span><br><span class="line">                                    ;  within the register)</span><br><span class="line">  vshufps xmm2, xmm1, xmm1, 255     ; ...</span><br><span class="line">  vaddss xmm0, xmm0, xmm3           ; accumulate the second value</span><br><span class="line">  vunpckhps xmm3, xmm1, xmm1        ; more shuffling</span><br><span class="line">  vextractf128 xmm1, ymm1, 0x1      ; ...</span><br><span class="line">  vaddss xmm0, xmm0, xmm3           ; accumulate third...</span><br><span class="line">  vaddss xmm0, xmm0, xmm2           ; and fourth value</span><br><span class="line">  vshufps xmm2, xmm1, xmm1, 85      ; shuffling</span><br><span class="line">  vaddss xmm0, xmm0, xmm1           ; accumulate fifth</span><br><span class="line">  vaddss xmm0, xmm0, xmm2           ; and sixth</span><br><span class="line">  vunpckhps xmm2, xmm1, xmm1        ; shuffle some more...</span><br><span class="line">  vshufps xmm1, xmm1, xmm1, 255     ; ...</span><br><span class="line">  vaddss xmm0, xmm0, xmm2           ; accumulate the seventh</span><br><span class="line">  vaddss xmm0, xmm0, xmm1           ; and final value</span><br><span class="line">  cmp rax, rcx                      ; are we done?</span><br><span class="line">  jne .loop                         ; if not, keep going</span><br></pre></td></tr></table></figure><p>不幸的是还没有简单的方法绕过这个限制。如果你保证这种情况下加法的顺序不重要，你可以启用gcc的一个危险的（但名字很有趣）标志：<code>-funsafe-math-optimizations</code>。这样gcc就能生成漂亮的内循环了（<a href="https://godbolt.org/z/acm19_sumf_unsafe%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_sumf_unsafe）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.loop:</span><br><span class="line">  vmovups ymm2, YMMWORD PTR [rax]   ; read 8 floats</span><br><span class="line">  add rax, 32                       ; advance</span><br><span class="line">  vfmadd231ps ymm0, ymm2, ymm2      ; for the 8 floats:</span><br><span class="line">                                    ;   ymm0 += ymm2 * ymm2</span><br><span class="line">  cmp rax, rcx                      ; are we done?</span><br><span class="line">  jne .loop                         ; if not, keep going</span><br></pre></td></tr></table></figure><p>令人吃惊：一次处理8个浮点数，用一条指令完成累加和平方。缺点是可能有无上限的精度损失。另外gcc不允许你只对你需要的函数打开这个功能——它是编译单元粒度的标志。Clang至少允许你在代码中用<code>#pragma Clang fp contract</code>来控制开关。</p><p>在尝试这些优化时，我发现编译器还有更多的花招：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumToX</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        result += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc会很直接地翻译这些代码，配上合适的设置后它就会像上面一样用上向量指令。而Clang会生成下面这样的代码（<a href="https://godbolt.org/z/acm19_sum_up%EF%BC%89%EF%BC%9A">https://godbolt.org/z/acm19_sum_up）：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sumToX(int): # @sumToX(int)</span><br><span class="line">  test edi, edi             ; test x</span><br><span class="line">  jle .zeroOrBelow          ; skip if x &lt;= 0</span><br><span class="line">  lea eax, [rdi - 1]        ; eax = x - 1</span><br><span class="line">  lea ecx, [rdi - 2]        ; ecx = x - 2</span><br><span class="line">  imul rcx, rax             ; rcx = ecx * eax</span><br><span class="line">  shr rcx                   ; rcx &gt;&gt;= 1</span><br><span class="line">  lea eax, [rcx + rdi]      ; eax = rcx + x</span><br><span class="line">  add eax, -1               ; return eax - 1</span><br><span class="line">  ret                      </span><br><span class="line">.zeroOrBelow:</span><br><span class="line">  xor eax, eax              ; answer is zero</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>首先，请注意这里完全没有循环。通过生成的代码，你发现Clang返回了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x-1) * (x-2) / 2 + x - 1</span><br></pre></td></tr></table></figure><p>它将循环换成了封闭形式的通用求和解法。这种解法与我自己会写出来的朴素代码不同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x * (x - 1) / 2</span><br></pre></td></tr></table></figure><p>这大概是Clang使用的通用算法的结果。</p><p>进一步的试验显示Clang聪明到能优化很多种类似的循环。Clang和gcc追踪循环变量的方式都能做这类优化，但只有Clang选择生成这种封闭形式的代码。但它不保证总是降低工作量：对于很小的<code>x</code>，封闭形式的开销也许比直接循环要大。Krister Walfridsson在<a href="https://kristerw.blogspot.com/2019/04/how-llvm-optimizes-geometric-sums.html">他的博客</a>中详细介绍了如何实现这种优化。</p><p>同样值得注意的是，为了做这种优化，编译器可能要依赖于“有符号整数溢出是未定义行为”。这样它就能假设你的代码不会传入可能会使结果溢出（这个例子中是65536）的<code>x</code>。如果Clang不能做这个假设，有时候它没办法找到封闭形式的解（<a href="https://godbolt.org/z/acm19_sum_fail%EF%BC%89%E3%80%82">https://godbolt.org/z/acm19_sum_fail）。</a></p><h3 id="去虚拟化"><a href="#去虚拟化" class="headerlink" title="去虚拟化"></a>去虚拟化</h3><p>尽管传统的基于虚函数的多态看起来有点过气了，但它仍然有一定的市场。无论是需要真正的多态行为，还是要为可测性增加“接缝”，或是允许未来的扩展，基于虚函数的多态都是不错的选择。</p><p>但如我们所知，虚函数很慢。是不是呢？我们看它们是怎么影响前面的平方和例子吧——有这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Transform</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * x; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumTransformed</span><span class="params">(<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt; &amp;v,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="keyword">const</span> Transform &amp;transform)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">    &#123;</span><br><span class="line">        res += <span class="built_in">transform</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然现在它还没有多态。快速用编译器跑一下可以看到它生成了相同的高度向量化的汇编（<a href="https://godbolt.org/z/acm19_poly1%EF%BC%89%E3%80%82">https://godbolt.org/z/acm19_poly1）。</a></p><p>现在我们为<code>int operator()</code>加上<code>virtual</code>，就会得到一个慢得多的实现，被填进了间接调用，对吧？当然，有点（<a href="https://godbolt.org/z/acm19_poly2%EF%BC%89%E3%80%82%E7%94%9F%E6%88%90%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A6%81%E6%AF%94%E4%B9%8B%E5%89%8D%E6%9B%B4%E5%A4%9A%EF%BC%8C%E4%BD%86%E6%A0%B8%E5%BF%83%E5%BE%AA%E7%8E%AF%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%AE%A9%E4%BD%A0%E6%83%B3%E4%B8%8D%E5%88%B0%EF%BC%9A">https://godbolt.org/z/acm19_poly2）。生成的代码要比之前更多，但核心循环可能会让你想不到：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  ; rdx points to the vtable</span><br><span class="line">.L8:</span><br><span class="line">  mov rax, QWORD PTR [rdx]  ; read the virtual function pointer</span><br><span class="line">  mov esi, DWORD PTR [rbx]  ; read the next int element</span><br><span class="line">  ; compare the function pointer with the address of the only</span><br><span class="line">  ; known implementation...</span><br><span class="line">  cmp rax, Transform::operator()(int) const</span><br><span class="line">  jne .L5                   ; if it&#x27;s not the only known impl,</span><br><span class="line">                            ; then jump off to a more complex case</span><br><span class="line">  imul esi, esi             ; square the number</span><br><span class="line">  add rbx, 4                ; move to next</span><br><span class="line">  add r12d, esi             ; accumulate the square</span><br><span class="line">  cmp rbp, rbx              ; finished?</span><br><span class="line">  jne .L8                   ; if not, loop</span><br></pre></td></tr></table></figure><p>这里gcc赌了一把。已知它只看到了<code>Transform</code>的一个实现，这里用到的很可能就是这个实现。相比无脑通过虚表间接跳转，将虚表指针与已知的唯一实现做比较只需要一点点时间。如果相同，编译器就知道该做什么了：它会内联掉<code>Transform::operator()</code>的函数体，并原地平方。</p><p>是的：编译器内联掉了一个虚函数调用。棒极了，我第一次发现这个的时候非常吃惊。这种优化叫做推测性去虚拟化（speculative devirtualization），是编译器作者不断研究和改进的源泉。编译器也能在LTO时做去虚拟化，能在整个程序范围内确定可能的函数实现。</p><p>但编译器漏掉了一个技巧。注意到每次循环入口它都重新从虚表中载入虚函数指针。如果编译器能发现这个值在被调函数不会修改<code>Transform</code>的动态类型时保持不变，这次检查就可以移出循环，这样在循环内就完全没有动态检查了。编译器可以用移动循环不变量的方法将虚表检查移出循环。此时其它优化方法就可以介入了，在虚表检查通过时，整段代码可以替换为之前的向量化循环。</p><p>你可能以为对象的动态类型不可能变化，但这是标准允许的：对象可以对自身调用placement new，析构时再变回原来的类型。但建议你别这么做。Clang有选项承诺你不会这么做：<code>-fstrict-vtable-pointers</code>。</p><p>在我用的编译器中，gcc是仅有的这么做的一个，但Clang正在重构它的类型系统，从而更多利用上这类优化。</p><p>C++11增加了<code>final</code>限定符以允许标记类和虚函数不可重写。这就给了编译器更多的关于哪些方法能受益于这类优化的信息了，在某些情况下甚至允许编译器完全避免虚函数调用（<a href="https://godbolt.org/z/acm19_poly3%EF%BC%89%E3%80%82%E5%8D%B3%E4%BD%BF%E6%B2%A1%E6%9C%89%60final%60%EF%BC%8C%E6%9C%89%E6%97%B6%E5%88%86%E6%9E%90%E9%98%B6%E6%AE%B5%E4%B9%9F%E8%83%BD%E8%AF%81%E6%98%8E%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84%E6%98%AF%E7%89%B9%E5%AE%9A%E7%9A%84%E5%85%B7%E4%BD%93%E7%B1%BB%EF%BC%88https://godbolt.org/z/acm19_poly4%EF%BC%89%E3%80%82%E8%BF%99%E7%B1%BB%E9%9D%99%E6%80%81%E5%8E%BB%E8%99%9A%E6%8B%9F%E5%8C%96%E6%93%8D%E4%BD%9C%E8%83%BD%E5%B8%A6%E6%9D%A5%E6%98%8E%E6%98%BE%E7%9A%84%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E3%80%82">https://godbolt.org/z/acm19_poly3）。即使没有`final`，有时分析阶段也能证明代码中用到的是特定的具体类（https://godbolt.org/z/acm19_poly4）。这类静态去虚拟化操作能带来明显的性能提升。</a></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>希望在读完本文以后，你能欣赏编译器为确保生成高效代码所付出的努力。我希望其中一些优化能让你感到惊喜，帮助你决定写出清晰的、意图明显的代码，将优化工作留给编译器去做。我再次强调，编译器知道的越多，它能做得越好。这包括允许编译器一次看到更多代码，以及将你的目标平台信息交给编译器。在给编译器更多信息时你要做一些权衡：这会让编译更慢。LTO之类的优化能让你兼顾两者。</p><p>编译器中的优化一直在提高，即将到来的间接调用和虚函数分派上的提高也许很快带来更快的多态。我为编译器优化技术的未来而感到兴奋。快去看看你的编译器的输出吧。</p><h3 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h3><p>The author would like to extend his thanks to Matt Hellige, Robert Douglas, and Samy Al Bahra, who gave feedback on drafts of this article.</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol><li>Godbolt, M. 2012. Compiler explorer; <a href="https://godbolt.org/">https://godbolt.org/</a>.</li><li>Lemire, D. 2019. Faster remainders when the divisor is a constant: beating compilers and libdivide. <a href="https://lemire.me/blog/2019/02/08/faster-remainders-when-the-divisor-is-a-constant-beating-compilers-and-libdivide/">https://lemire.me/blog/2019/02/08/faster-remainders-when-the-divisor-is-a-constant-beating-compilers-and-libdivide/</a>.</li><li>LLVM. 2003. The LLVM compiler infrastructure.; <a href="https://llvm.org/">https://llvm.org</a>.</li><li>Padlewski, P. 2018. RFC: Devirtualization v2. LLVM; <a href="http://lists.llvm.org/pipermail/llvm-dev/2018-March/121931.html">http://lists.llvm.org/pipermail/llvm-dev/2018-March/121931.html</a>.</li><li>ridiculous_fish. 2010. Libdivide; <a href="https://libdivide.com/">https://libdivide.com/</a>.</li><li>Uops. Uops.info Instruction Latency Tables; <a href="https://uops.info/table.html">https://uops.info/table.html</a>.</li><li>Walfridsson, K. 2019. How LLVM optimizes power sums; <a href="https://kristerw.blogspot.com/2019/04/how-llvm-optimizes-geometric-sums.html">https://kristerw.blogspot.com/2019/04/how-llvm-optimizes-geometric-sums.html</a>.</li><li>Warren, H. S. 2012. Hacker’s Delight. 2nd edition. Addison-Wesley Professional.</li></ol><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li><a href="https://queue.acm.org/detail.cfm?id=3212479">C Is Not a Low-level Language</a> Your computer is not a fast PDP-11. - David Chisnall</li><li><a href="https://queue.acm.org/detail.cfm?id=3041020">Uninitialized Reads</a> Understanding the proposed revisions to the C language - Robert C. Seacord</li><li><a href="https://queue.acm.org/detail.cfm?id=2088916">You Don’t Know Jack about Shared Variables or Memory Models</a> Data races are evil. - Hans-J. Boehm, Sarita V. Adve</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++, 优化, 编译器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出离</title>
      <link href="/%E7%94%9F%E6%B4%BB/%E6%96%87%E7%AB%A0/%E5%87%BA%E7%A6%BB/"/>
      <url>/%E7%94%9F%E6%B4%BB/%E6%96%87%E7%AB%A0/%E5%87%BA%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="出离"><a href="#出离" class="headerlink" title="出离"></a>出离</h1><h2 id="作者：许嵩"><a href="#作者：许嵩" class="headerlink" title="作者：许嵩"></a>作者：许嵩</h2><p>这几个月，走过了不少地方。</p><p>每到一处，采访我的媒体通常会有这么一问：你的音乐理想是什么？而当答案是“我从来没有理想”时，我迎接那些错愕的眼神。</p><p>年轻的时候，拥有一些世俗的念想（比如声名远播？）、一些物质上的期待（比如大房子好车子？）、一些精神上的憧憬（比如寻得佳偶？）、一些相对崇高的目标（比如造福子孙？！），似乎的确能让一些人更有动力的过活每一天。但如果，岁月在你脸上已然留下不少年轮——你坐船的动机仍然只是到达一座岛，别人把岛上的一切美妙和宝藏说给你听就可以让你划船划的更带劲儿——那我能对你说些什么呢？</p><p>平日里花费极多的时间在音乐上，无论是作词，作曲，制作，还是今年开始的演出，为此我已经感到体力不支（特别是最近一个月）。但仍然乐此不疲，并且不断研究着提升体能的方法。但这绝对不代表我有什么理想。那真是一种侮辱。</p><p>你一定试过非常入戏的观看一部电影吧？是了，电影非常精彩，你感受主角的悲喜，在影院里为它落泪或鼓掌——甚至为它憋住尿。但一旦事情严重到你觉得快要尿出来了，你还是可以毫无负担的起身奔向厕所。只因你知道，戏毕竟是戏。戏的发展和结局，毕竟和自己无关。你很清楚，你是你，戏是戏。你享受它，但你的心能够随时出离。</p><p>我一直不断提醒自己，将这种出离的能力运用在生活里一切通常被认为“重要”的事情。——很认真很投入。但心随时能够出离。因着深知一切都在究竟上无意义。一只萤火虫最大的悲哀是，自以为能照亮全世界。我们周遭有多少这样的萤火虫？</p><p>然而你我，纵然经过了世俗意义上的“努力”、成为了人们眼中的“人才”、大幅度提高了自身的光亮度——就可以因为自己是霓虹灯就沾沾自喜并开始张罗起理想了？拜托，太阳会笑的。</p><p>最后。也许你一直怀揣理想，那也不是什么了不得的坏事，没什么了不得的，只管去实现好了。只不过你应知道，坐船的意义就仅仅是坐船，如果坐船是为了到达目的地，那所有人最终的目的地都是死亡——你看，非要树立目标，那面对着这个终极目标，是不是比没有目标更绝望得多？</p><p>保持出离心。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文章 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/acm/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><h2 id="前置问题"><a href="#前置问题" class="headerlink" title="前置问题"></a>前置问题</h2><p>在认识前缀和之前, 首先提出万恶的需求:  <strong>对于一个数组, 并给出 q 次询问, 每一次都询问这个数组在 [l, r] 范围内的和</strong></p><p>我们最开始的思路是, 每一次询问, 都去遍历一遍 [l, r] 区间去进行求和, 得到如下代码. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum = 0;</span><br><span class="line">while (q--)</span><br><span class="line">for (int i = l; i &lt;= r; i++)</span><br><span class="line">sum += arry[i];</span><br></pre></td></tr></table></figure><p>Easy! 当我们以为问题解决的时候, 问题升级了, 希望你在 **1s 内求出答案, 并且 ${n * q}$ 的值处于 10^6^ ** , 再去使用上面的方法, 就会喜提 <strong>TLE</strong> , 这时我们认识到,  每一个询问都进行区间求和的时间复杂度是 $O(nq)$ 的, 纯粹的暴力在升级的问题中是不可行的.</p><h2 id="思考优化"><a href="#思考优化" class="headerlink" title="思考优化"></a>思考优化</h2><p>我们进一步思考, 突然发现一个有趣的性质, 如果要去求出<strong>区间 [l, r]</strong> 内的和, 只需要使用 <code>sum([1, R]) - sum([1, L - 1]) (Ⅰ)</code>就可以轻松得到, 而不再需要去进行遍历, 最重要的是我们只需要对整个数组求一次和, 即利用 <code>sum([1, x]) = sum([1, x - 1]) + arry[x](Ⅱ)</code> 即可, 这样每一次询问, 我们只需要去利用式子 (Ⅰ)</p><p>进行 $O(1)$ 的运算就可以了, 那么总共我们只需要花费 $O(n + q)$ 的时间复杂度就完美的实现了对升级问题的优化.</p><h2 id="前缀和-1"><a href="#前缀和-1" class="headerlink" title="前缀和"></a>前缀和</h2><p>通过对问题的思考优化, 这时候我们引出前缀和的概念, 相信你就应该可以理解了.</p><p>**前缀和指一个数组的某下标之前的所有数组元素的和 ( 包含其自身 ) **</p><p>比如我们有一个数组 <code>[1, 2, 3, 4, 5]</code>, 那么其对应的<strong>前缀和数组</strong>就是 <code>[1, 3, 6, 10, 15]</code></p><p>用表达式来表示的话就是 <code>sum([1, x]) = sum([1, x - 1]) + arry[x] 当 x == 1 时 sum([1, x]) = arry[x]</code></p><p><strong>代码实现则是:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[N], arry[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;= N; i++) </span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + arry[i];</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">    cout &lt;&lt; sum[r] - sum[l - <span class="number">1</span>] &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="一维前缀和的总结"><a href="#一维前缀和的总结" class="headerlink" title="一维前缀和的总结"></a>一维前缀和的总结</h2><p>那么对于前缀和只能解决加法问题吗? 当然不是, 它还可以解决像区间异或的情况, 也即 <code>xor(l, r) =  xor([1, R]) ^ xor([1, L - 1])</code></p><p>我们可以总结一下, 如果需要<strong>求出区间 [l, r] 中元素操作为 x 的结果</strong>时, 只要<strong>操作 x</strong> 满足 <code>X(l, r) = X([1, r]) X X([1, l - 1])</code> 就可以使用前缀和的思想进行优化</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><ul><li><p><a href="https://www.luogu.com.cn/problem/U69096">洛谷 U69096</a></p></li><li><p><a href="https://atcoder.jp/contests/joi2007ho/tasks/joi2007ho_a"><strong>最大の和</strong></a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P6067"> [USACO05JAN]Moo Volume S</a></p></li><li><p><a href="https://www.luogu.com.cn/problem/P3131">[USACO16JAN]Subsequences Summing to Sevens S</a></p></li></ul><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>对于一维前缀和, 我们已经有一定了解了. 那么我们开始加速.</p><p>我们给出一个数字矩阵 $a$, 可以将其视为二维数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 3</span><br><span class="line">5 1 2 4</span><br><span class="line">6 3 5 9</span><br></pre></td></tr></table></figure><p>现在要求我们去求出任意一个子矩阵的和, 有了一维前缀和的经验, 我们会想到记录任意一个点到 $(1, 1)$ 的矩阵的和, 也即 $sum_{x, y} = \sum_{i = 1} ^ {x} \sum_{y = 1} ^ {y} a_{i, j}$ </p><p>于是我们可以得到下面的 $sum$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  3  7  10</span><br><span class="line">6  9  15 22</span><br><span class="line">12 18 29 45</span><br></pre></td></tr></table></figure><p>思路是很清晰的, 不过我们下面遇到了两个问题:</p><ol><li><p>递推求 $sum_{i, j}$ 的过程:  $sum_{i, j} = sum_{i - 1, j} + sum_{i, j - 1} + a_{i, j}$ 如果不理解可以对着下面这个图理解一下</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://img-blog.csdn.net/20180921215152309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTkwNzMx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p>由于添加了 $sum_{i - 1, j}, sum_{i, j - 1}$  故对于 $sum_{i - 1, j - 1}$ 重复添加了, 所以需要减去</p></li><li><p>我们如何通过 $sum$ 矩阵求出 $(x_1, y_1) - (x_2, y_2)$ 子矩阵的和</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://img-blog.csdn.net/20180922161308238?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0OTkwNzMx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><p>根据类似的思考, 再根据图看一下, 可以发现答案为 $sum_{x_1, y_1} - sum_{x_1 - 1, y_2} - sum_{x_2, y_1 - 1} + sum_{x_1 - 1, y_1 - 1}$</p></li></ol><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><ul><li><a href="https://www.luogu.com.cn/problem/P1387">洛谷P1378最大正方形</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
          <category> 基础算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 基础算法 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP1.0 / HTTP1.1</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP1.0%20%E5%92%8C%20HTTP1.1/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/HTTP1.0%20%E5%92%8C%20HTTP1.1/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP1-0-HTTP1-1"><a href="#HTTP1-0-HTTP1-1" class="headerlink" title="HTTP1.0 / HTTP1.1"></a>HTTP1.0 / HTTP1.1</h1><p>大部分都摘自 小伙伴 <a href="https://www.tang7o.cn/2022/03/08/HTTP1-0-1-1/">Tang7O</a></p><p>本文将在以下几个方面来对于 <strong>HTTP1.0</strong> 和 <strong>HTTP1.1</strong></p><ul><li>响应状态码</li><li>缓存处理</li><li>链接方式</li><li>Host 头处理</li><li>带宽优化</li></ul><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p><strong>HTTP1.0</strong> 仅定义了 16 种状态码.  <strong>HTTP1.1</strong> 中新加入了大量的状态码, 光是错误响应状态码就新增了 24 种.</p><p>比如说:</p><ul><li>100 (Continue) : 在请求大资源前的预热请求.</li><li>206 (Partial Content) : 范围请求的标识码.</li><li>409 (Conflict) : 请求与当前资源的规定冲突.</li><li>410 (Gone) : 资源已被永久转移, 而且没有任何已知的转发地址.</li></ul><h2 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h2><p>缓存技术通过避免用户与资源服务器频繁交互, 节约了大量的网络带宽, 降低了用户接受信息的延迟.</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p><strong>HTTP 1.0</strong> 提供的缓存机制非常简单. 服务器端使用 <code>Expires</code> 标签来标志 (时间) 一个响应体, 在 <code>Expire</code> 标志时间内的请求, 都会获得该响应体缓存. 服务器端在初次返回给客户端的响应体种, 有一个 <code>Last-Modified</code> 标签, 该标签标记了被请求资源在服务器的最后一次修改. 在请求头种, 使用 <code>If-Modified-Since</code> 标签, 该标签标志了一个时间, 意为客户端向服务器进行问询: “该时间之前, 我要请求的数据是否有被修改过 ? “ 通常情况下, 请求头中的 <code>If-Modifiend-Since</code> 的值即为上一次获得该资源时, 响应体中的 <code>Last-Modified</code>  的值.</p><p>如果服务器即收到了请求头, 并判断 <code>If-Modified-Since</code> 时间后, 资源确实没有被修改过, 则返回给客户端一个 <code>304 not modified</code> 响应头, 表示 “缓存可用, 你从浏览器中拿吧”.</p><p>如果判断 <code>If-Modified-Since</code> 时间后, 资源被修改过, 则返回给客户端一个 <code>200 OK</code> 的响应体, 并附带全新的资源内容,  表示 “资源被修改过了, 我给你一份新的”</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://www.tang7o.cn/2022/03/08/HTTP1-0-1-1/1.png" alt="img"></p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://www.tang7o.cn/2022/03/08/HTTP1-0-1-1/2.png" alt="img"></p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3><p><strong>HTTP 1.1</strong> 的缓存机制在 <strong>HTTP 1.0</strong> 的基础上, 大大增加了灵活性和扩展性. 基本工作原理和 <strong>HTTP 1.0</strong> 保持不变,  而是增加了更多细致的特性. 其中, 请求头中最常见的特性就是 <code>Cache-Control</code>,  详见 <strong>MDN Web</strong> 文档  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a> </p><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p><strong>HTTP/1.0 默认使用短链接</strong>, 也就是说, 客户端和服务器每进行一次 HTTP 操作, 就建立一次连接, 任务结束就中断连接. 当客户端浏览器访问的某个 HTML 或者其他类型的 Web 页中包含有其他 Web 资源, 浏览器就会重新建立一个 TCP 连接,  这样就会导致有大量的 “握手报文” 和 “挥手报文” 占用了带宽.</p><p><strong>为了解决 HTTP/1.0 存在的资源浪费问题，HTTP/1.1 优化为默认长连接模式</strong>. 采用长连接模式的请求报文会通知服务端: “我会向你请求连接, 并且连接成功后, 请不要关闭”. 因此, 该 TCP 连接将持续打开, 为后续的客户端服务端的数据交互服务. 也就是说在使用长连接的情况下, 当一个网页打开完成后, 客户端和服务端之间用与传输 HTTP 数据的 TCP 连接不会关闭, 客户端再次访问这个服务器时, 会继续使用这一条已经建立的连接.</p><p>如果 TCP 连接一直保持的话也是对资源的浪费, 因此, 一些服务器软件还会支持超时时间的时间. 在超时时间之内没有新的请求达到, TCP 连接才会被关闭.</p><p>有必要说明的是, HTTP/1.0 仍提供了长连接选项, 在请求头中加入 <code>Connection: Keep-alive</code>. 同样的, 在HTTP 1.1中, 如果不希望使用长连接选项, 也可以在请求头中加入 <code>Connection: close</code>, 这样会通知服务器端: “我不需要长连接, 连接成功后即可关闭”.</p><p><strong>HTTP 协议的长连接和短连接, 实质上是 TCP 协议的长连接和短连接.</strong></p><p><strong>实现长连接需要客户端和服务端都支持长连接.</strong></p><h2 id="Host-头处理"><a href="#Host-头处理" class="headerlink" title="Host 头处理"></a>Host 头处理</h2><p>域名系统 (DNS) 允许多个主机名绑定到同一个 IP 地址上, 但是 HTTP1.0 并没有考虑这个问题, 假设我们有一个资源 URL 是 <code>https://cu1universe.icu/index.html</code> ,  HTTP/1.0 的请求报文中, 将会请求的是 <code>GET /index.html HTTP/1.0</code> 也就是不会加入主机名. 这样的报文发送到服务器端,  服务端理解不了客户端想请求的真正网址.</p><p>因此, HTTP 1.1 在请求头中加入了 <code>Host</code> 字段. </p><p>加入 <code>Host</code> 字段的报文头部将会是:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Host: tang7o.cn</span><br></pre></td></tr></table></figure><p>这样, 服务器就可以确定客户端想要请求的真正网址了.</p><h2 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h2><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p><strong>HTTP/1.1</strong> 引入了范围请求 <strong>(range request)</strong> 机制, 以避免带宽的浪费. 当客户端想请求一个文件的一部分, 或者需要继续下载一个已经下载了部分但被终止的文件, <strong>HTTP/1.1</strong> 可以在请求头中加入 <code>Range</code> 头部, 以请求 (并只能请求字节型数据) 数据的一部分. 服务器可以忽略 <code>Range</code> 头部, 而可以返回若干 <code>Range</code> 响应.</p><p>如果一个响应包括部分数据的话, 那么将带有 <code>206 (Partial Content)</code> 状态码. 该状态码的意义在于避免了 <strong>HTTP/1.1</strong> 代理缓存错误的把该响应认为是一个完整的数据响应, 从而把他当作一个请求的响应缓存.</p><p>在范围响应中, <code>Content-Range</code> 头部标志指示出了该数据块的偏移量和数据块长度</p><h3 id="状态码-100"><a href="#状态码-100" class="headerlink" title="状态码 100"></a>状态码 100</h3><p><strong>HTTP/1.0</strong> 中新加了<strong>状态码 100</strong>. 该状态码的使用场景为, 存在某些比较大的文件请求, 服务器可能不愿意响应这种请求, 此时 <strong>状态码 100</strong> 可以作为指示请求是否被正常响应.</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://www.tang7o.cn/2022/03/08/HTTP1-0-1-1/3.png" alt="img"></p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://www.tang7o.cn/2022/03/08/HTTP1-0-1-1/4.png" alt="img"></p><p>然而在 <strong>HTTP/1.0</strong> 中没有 <code>100(Continue)</code> 状态码, 要想触发这一机制, 可以发送一个 <code>Expect</code> 头部, 其中包含一个 <code>100-continue</code> 的值.</p><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>许多格式的数据在传输时都会做压缩处理. 数据的压缩可以大幅优化带宽的利用. 然而, <strong>HTTP/1.0</strong> 对数据压缩的选项提供的不多, 不支持压缩细节的选择, 也无法区分端到端压缩或者是逐跳压缩.</p><p><strong>HTTP/1.1</strong> 则对内容编码和传输编码做了区分, 内容编码总是端到端的, 传输编码总是逐跳的.</p><p><strong>HTTP/1.0</strong> 包含了 <code>Content-Encoding</code> 头部, 对消息进行端到端编码. <strong>HTTP/1.1</strong> 加入了 <code>Transfer-Encoding</code> 头部可以对消息进行逐跳传输编码. <strong>HTTP/1.1</strong> 还加入了 <code>Accept-Encoding</code> 头部, 时客户端来指示它能处理什么样的内容编码.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>连接方式:</strong> HTTP/1.0 默认短链接, HTTP/1.1 默认长连接</li><li><strong>状态响应码:</strong> HTTP/1.1 中新加了大量的状态码, 光是错误响应状态码就新增了 24 种.</li><li><strong>缓存处理:</strong> 在 HTTP/1.0 中主要使用 <strong>header</strong> 里面的 <code>If-Modified-Since, Expires</code> 来作为缓存判断的标准, HTTP/1.1 则引入了更多的缓存控制策略, 例如  <code>Entity tag, If-Unmod-Since, If-Match, If-None-Match</code> 等更多可供选择的缓存头来控制缓存策略.</li><li><strong>带宽优化以及网络连接的使用:</strong> 在 HTTP/1.0 中, 存在一些浪费带宽的现象, 例如客户端只是需要某个对象一部分, 而服务器却将整个对象送过来了, 并且不支持断点续传功能, HTTP/1.1 则在请求头引入了 <code>Range</code> 头域, 它允许之请求资源的某个部分, 即返回码是 <code>206 (Partial Content)</code> 这样就方便了开发者自由的选择以便于充分利用带宽和连接.</li><li>**Host 头处理: **HTTP/1.1 在请求头中加入了 <code>Host</code> 字段</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 基础知识</title>
      <link href="/C/C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/C/C++%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础知识点"><a href="#C-基础知识点" class="headerlink" title="C++ 基础知识点"></a>C++ 基础知识点</h1><h2 id="C-中四种-cast-转换"><a href="#C-中四种-cast-转换" class="headerlink" title="C++ 中四种 cast 转换"></a>C++ 中四种 cast 转换</h2><p>C++ 中四种类型转换是:  <strong>static_cast, dynamic_cast,  const_cast, reinterpret_cast</strong></p><ol><li><p>const_cast</p><p>用于将 <strong>const</strong> 变量转为非 <strong>const 变量</strong></p></li><li><p>static_cast</p><p>用于各种<strong>隐式</strong>转换, 比如非 const 转 const, void* 转指针等, static_cast 能用于<strong>多态向上</strong>转化, 如果<strong>向下转能成功但是不安全, 结果未知</strong></p></li><li><p>dynamic_cast</p><p>用于动态类型转换. <strong>只能用于含有虚函数的类</strong>, 用于层次间的向上和向下转化. <strong>只能转指针或引用</strong>. 向下转化时, 如果时非法的对于指针返回 null, 对于引用抛异常. </p><p>其中:</p><ul><li>向上转换: 指的是子类向基类的转换</li><li>向下转换: 指的是基类向子类的转换</li></ul><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够向下转换</p></li><li><p>reinterpret_cast</p><p>几乎什么都可以转, 比如将 int 转换为指针, 可能会出问题, 建议尽量不要使用此类转换</p></li></ol><p>C 的强制转换表面上看起来功能强大什么都可以进行转型, 但是转换不够明确, 不能进行错误检查, 容易出错</p><h2 id="C-C-中指针和引用的区别"><a href="#C-C-中指针和引用的区别" class="headerlink" title="C/C++ 中指针和引用的区别"></a>C/C++ 中指针和引用的区别</h2><ol><li>指针有自己的一块空间, 而引用只是一个别名</li><li>使用 sizeof 看一个指针的大小是 4, 而引用则是被引用对象的大小</li><li>指针可以被初始化为 null, 而引用必须被初始化且必须是一个已有对象的引用</li><li>作为参数传递时, 指针需要解引用才可以对对象进行操作,  而直接对引用的修改都会改变引用所指向的对象</li><li>可以有 const 指针, 但是没有 const 引用</li><li>指针在使用中可以指向其它对象, 但是引用只能是一个对象的引用, 不能被改变</li><li>指针可以有多级指针 (**p), 而引用只有一级</li><li>指针和引用使用 ++ 原算符的意义不一样</li><li>如果返回动态分配的对象或者内存, 必须使用指针, 引用可能引起内存泄漏</li></ol><h2 id="C-中的智能指针"><a href="#C-中的智能指针" class="headerlink" title="C++ 中的智能指针"></a>C++ 中的智能指针</h2><p>C++ 里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr, 其中后三个是 C++11 支持的, 并且第一个已经被 11 弃用</p><h3 id="为什么要使用智能指针"><a href="#为什么要使用智能指针" class="headerlink" title="为什么要使用智能指针:"></a>为什么要使用智能指针:</h3><p>智能指针的作用是管理一个指针, 因为存在以下这种情况: 申请的空间在函数结束时忘记释放, 造成内存泄漏. 使用智能指针可以很大程度上避免这个问题, 因为智能指针就是一个对象, 当对象的生命周期结束时, 对象会自动调用自己的析构函数, 而析构函数会自动释放所持有的资源.所以智能指针的作用原理就是在函数(方法)结束后自动释放内存空间, 不需要手动释放申请的内存空间</p><ol><li><p>auto_ptr (C++ 98 的方案, cpp11 已经弃用)</p><p>采用所有权模式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;string&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;string&gt; p2;</span><br><span class="line">p2 = p1 <span class="comment">// auto_prt 不会报错</span></span><br></pre></td></tr></table></figure><p>此时不会报错, p2 剥夺了 p1 所指向对象的所有权, 此时 p1 为空, 所以当程序运行时访问 p1 将会报错. 所以 <code>auto_ptr</code>的缺点是: 存在潜在的内存崩溃问题</p></li><li><p>**unique_ptr ** (替换 auto_ptr)</p><p><code>unique_prt</code> 实现独占式拥有或严格拥有概念, 保证同一时间内只有一个智能指针可以指向该对象. 它对于避免资源泄漏(例如 <strong>“以 new 创建对象后因为发生异常而忘记调用 delete”</strong>) </p><p>采用<strong>所有权模式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;auto&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; p4;</span><br><span class="line">p4 = p3; <span class="comment">// 此时会报错</span></span><br></pre></td></tr></table></figure><p>编译器认为 <code>p4 = p4</code> 非法, 避免了 p3 不再指向有效数据的问题. 因此 <code>unique_ptr</code> 比 <code>auto_ptr</code> 更安全</p><p>另外 <code>unique_ptr</code> 还有更聪明的地方: 当一个程序试图将一个 <code>unique_ptr</code> 赋值给另一个时, 如果原 <code>unique_ptr</code> 是一个临时右值, 那么编译器允许那么做; 如果源 <code>unique_ptr</code> 将存在一段时间, 编译器将禁止那么做, 比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello world&quot;</span>))</span></span>;</span><br><span class="line">unique_ptr&lt;string&gt; pu2;</span><br><span class="line">pu2 = pu1; <span class="comment">// #1 not allowed</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3;</span><br><span class="line">pu3 = unique_ptr&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;You&quot;</span>)); <span class="comment">// #2 allowed</span></span><br></pre></td></tr></table></figure><p>其中 #1 留下的悬挂的 <code>unique_ptr(pu1)</code> , 这可能带来危害. 而 #2 不会留下悬挂的 <code>unique_ptr</code> , 因为它调用 <code>unique_ptr</code> 的构造函数, 该构造函数创建的临时对象在其所有权让给 pu3 后就会被销毁. 这种随情况而已的行为表明, <code>unique_ptr</code> 优于允许两种赋值的 <code>auto_ptr</code></p><p>注: 如果确实想执行类似像 #1 的操作, 要安全的重用这种指针, 可以给它重新赋值. C++ 提供了一个标准库 <code>std::move()</code> 让你能够将一个 <code>unique_ptr</code> 赋值给另一个. 例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;string&gt;ps1, ps2;</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">ps2 = std::<span class="built_in">move</span>(ps1);</span><br><span class="line">ps1 = <span class="built_in">demo</span>(<span class="string">&quot;alexia&quot;</span>);</span><br><span class="line">cout &lt;&lt; *ps2 &lt;&lt; *ps1 &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li><li><p><strong>shared_ptr</strong> </p><p>shared_ptr 实现共享式拥有概念. 多个智能指针可以指向相同对象, 该对象和其相关资源会在 “最后一个引用被销毁” 的时候释放. 从名字就可以看出了资源可以被多个指针共享, 它使用计数机制来表明资源被几个指针共享. 可以通过成员方法 <code>use_count()</code> 来查看资源所有者的个数, 除了通过 <code>new</code> 来构造, 还可以通过传入 <code>auto_ptr</code>, <code>unique_ptr</code>, <code>weak_ptr</code> 来构造. 当我们调用 <code>release()</code> 时, 当前指针会释放资源所有权, 计数减一. 当<strong>计数等于 0</strong> 时, 资源会被释放.</p><p><code>shared_ptr</code> 是为了解决 <code>auto_ptr</code> 在对象所有权上的局限性**(auto_ptr 是独占的)**, 在使用引用计数的机制上提供了可以共享所有权的智能指针</p><p><strong>成员方法:</strong></p><ul><li><p>use_count() 返回引用计数的个数</p></li><li><p>unique() 返回是否独占所有权( use_count 为 1)</p></li><li><p>swap() 交换两个 shared_ptr 所拥有的对象</p></li><li><p>reset() 放弃内部对象的所有权或者拥有对象的变更, 会引起原有对象的引用计数减少</p></li><li><p>get() 返回内部对象(指针), 由于已经重载了方法, 因此和直接使用对象是一样的. 如</p><p><code>shared_ptr&lt;int&gt;sp(new int(1))</code>;  sp 和 sp.get() 是等价的</p></li></ul><p><strong>shared_ptr 的实现:</strong></p><p>核心要理解引用计数, 什么时候销毁底层指针, 还有赋值, 拷贝构造的时候的引用计数的变化, 析构的时候要判断底层指针的引用计数为 0 了才能真正释放底层指针的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* ptr; <span class="comment">// 底层真实指针</span></span><br><span class="line">    <span class="keyword">int</span>* use_count; <span class="comment">// 保存当前对象被多少指针引用</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmartPtr</span>(T* p); <span class="comment">//SmartPtr&lt;int&gt;p(new int(2))</span></span><br><span class="line">    <span class="built_in">SmartPtr</span>(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; other); <span class="comment">// SmartPtr&lt;int&gt;q(p)</span></span><br><span class="line">    SmartPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; rhs); <span class="comment">// q = p;</span></span><br><span class="line">    ~<span class="built_in">SmartPtr</span>();</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*(); <span class="comment">// 为了能把智能指针当成普通指针操作定义解引用</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;();</span><br><span class="line">    T* <span class="keyword">operator</span>+(<span class="keyword">int</span>); <span class="comment">// 定义指针加一个常数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; rhs); <span class="comment">// 获得两指针相减获得其距离</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *use_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ptr - rhs.ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SmartPtr&lt;T&gt;::<span class="built_in">SmartPtr</span>(T* p)</span><br><span class="line">&#123;</span><br><span class="line">    ptr = p;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        use_count = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr; <span class="comment">// 申请失败释放真实指针和引用计数的内存</span></span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> use_count;</span><br><span class="line">        use_count = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SmartPtr&lt;T&gt;::<span class="built_in">SmartPtr</span>(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 引用计数保存在一块内存, 所有的 SmartPtr 对象的引用计数都指向这里</span></span><br><span class="line">    use_count = other.use_count; </span><br><span class="line">    prt = other.ptr;</span><br><span class="line">    ++(*use_count); <span class="comment">// 当前对象的引用计数 + 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SmartPtr&lt;T&gt;&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr&lt;T&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 重载=运算符, 例如 SmartPtr&lt;int&gt;p, q; p = q; 这个语句中, 首先给 q 指向的对象的引用计数</span></span><br><span class="line">    <span class="comment">// 加 1, 因为 p 重新指向了 q 所指的对象, 所有 p 需要先给原来的对象的引用计数减 1,如果减 1</span></span><br><span class="line">    <span class="comment">// 后为 0, 先释放掉 p 原来指向的内存, 然后将 q 指向的对象的引用计数加 1 后赋值给 p;</span></span><br><span class="line">    ++(*rhs.use_count);</span><br><span class="line">    <span class="keyword">if</span> ((--(*use_count)) == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> use_count;</span><br><span class="line">        use_count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr = rhs.ptr;</span><br><span class="line">    use_count = rhs.use_count;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">SmartPtr&lt;T&gt;::~<span class="built_in">SmartPtr</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--(*use_count) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ptr;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> use_count;</span><br><span class="line">        use_count = ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; SmartPtr&lt;T&gt;::<span class="keyword">operator</span>*() &#123; <span class="keyword">return</span> *ptr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> ptr;&#125;</span><br><span class="line"></span><br><span class="line">T* SmartPtr&lt;T&gt;::<span class="keyword">operator</span>+(<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> ptr + i; &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>weak_ptr</strong></p><p>weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 <code>shared_ptr</code> 管理的对象, 进行该对象的内存管理的是那个强引用的 <code>shared_ptr</code> .  <code>weak_ptr</code> 只是提供了对管理对象的一个访问手段. <code>weak_ptr</code> 设计的目的是为配合 <code>shared_ptr</code> 而引入的一种智能指针来协助 <code>shared_ptr</code> 或另一个 <code>weak_ptr</code> 对象构造, 它的构造和析构不会引起计数的增加或者减少. <code>weak_ptr</code> 是用来解决 <code>shared_ptr</code> 相互引用时的死锁问题, 如果说两个 <code>shared_ptr</code> 相互引用, 那么这两个指针的引用计数永远不可能下降为 0, 资源永远不会释放. 它是对对象的弱引用, 不会增加对象计数, 和 <code>shared_ptr</code> 之间可以相互转化, <code>share_ptr</code> 可以直接赋值给它, 它可以通过调用 <code>lock</code> 方法来获得 <code>shared_ptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;B&gt; pb_;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;A&gt; pa_;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B delete&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;B&gt; <span class="title">pb</span><span class="params">(<span class="keyword">new</span> B())</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;A&gt; <span class="title">pa</span><span class="params">(<span class="keyword">new</span> A())</span></span>;</span><br><span class="line">    pb-&gt;pa_ = pa;</span><br><span class="line">    pa-&gt;pb_ = pb;</span><br><span class="line">    cout &lt;&lt; pb.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; pa.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>fun()</code> 函数中 pa, pb 之间相互引用, 两个资源的引用计数为 2, 当要跳出函数时. 智能指针 pa, pb 析构时两个资源的引用计数会减一, 但是两者的引用计数还是为 1, 导致函数结束时没有释放在堆空间内申请的内存 (A, B 的析构函数没有被调用), 如果把其中一个改为 <code>weak_ptr</code> 就可以了, 我们把 A 类里面的 <code>shared_ptr</code>; 改为 <code>weak_ptr</code>;这样的话, 资源 B 的引用开始就只有 1, 当 pb 析构时, B 的计数变为 0, B 得到释放, B 释放的同时也会使 A 的计数减一, 同时 pa 析构时使 A 的计数减一, 那么 A 的计数为 0, A 得到释放</p><p>**注意:**p</p><p>​    我们不能够通过 <code>weak_ptr</code> 直接访问对象的方法, 比如 B 对象中有一个方法 <code>print()</code> , 我们不能这样访问, <code>pa-&gt;pb_&gt;print()</code> 因为 pb_ 是一个 <code>weak_ptr</code> , 应该先把它转换为<code>shared_ptr</code>, 如: <code>shared_ptr p = pa-&gt;pb_.lock(); p-&gt;print();</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Strategy 策略模式</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Strategy-策略模式"><a href="#Strategy-策略模式" class="headerlink" title="Strategy 策略模式"></a>Strategy 策略模式</h1><h2 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题:"></a>要解决的问题:</h2><p>在软件按的构建过程中, 一些对象使用的方法可能多种多样, 经常会出现变动, 如果将这个方法都编码到对象方法中, 将会高频率的修改对象方法, 使其变得异常复杂, 同时也破坏了代码尽量不去变动的准则, 并且有时候支持不会去使用的一些方法也是一个性能负担</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义:"></a>模式定义:</h2><p>定义一系列算法, 将它们一个个封装起来, 并且使它们可互相替(变化). 该模式使得算法可独立于使用它的客户程序(稳定)而变化(扩展, 子类化)</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>当要实现一个计算税务的需求时, 没有进行优化前的代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TaxBase</span> &#123;</span></span><br><span class="line">CN_Tax,</span><br><span class="line">US_Tax,</span><br><span class="line">DE_Tax,</span><br><span class="line">FR_Tax       <span class="comment">//每一个国家的税务计算</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line">    TaxBase tax;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (tax == CN_Tax)&#123;</span><br><span class="line">            <span class="comment">//CN***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == US_Tax)&#123;</span><br><span class="line">            <span class="comment">//US***********</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tax == DE_Tax)&#123;</span><br><span class="line">            <span class="comment">//DE***********</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tax == FR_Tax)&#123;  <span class="comment">// 如果是法国, 该如何计算税收</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到, 如果要新增国家的话, 那么就要在原来的代码上进行改动, 通过增加 <code>else if</code> 的形式进行源码级改动, 如果这种改动逐渐增多了之后, 将会使得可维护性大大降低, 而且一次增加将会影响大量的代码,</p><h2 id="使用-Strategy-策略模式进行重构"><a href="#使用-Strategy-策略模式进行重构" class="headerlink" title="使用 Strategy 策略模式进行重构"></a>使用 Strategy 策略模式进行重构</h2><p>考虑将计算税收的方法抽象出来, 通过继承的方式来对可能会增加的税收方式进行扩展, 这样只需要将不同计算税收的指针赋给父类的指针, 就可以利用多态来实现不同国家的税收计算</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p> <img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s1.ax1x.com/2022/03/09/bWOpse.png"></p><h3 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaxStrategy</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TaxStrategy</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">USTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DETax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line">        <span class="comment">//***********</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//*********************************</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRTax</span> :</span> <span class="keyword">public</span> TaxStrategy&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">Calculate</span><span class="params">(<span class="keyword">const</span> Context&amp; context)</span></span>&#123;</span><br><span class="line"><span class="comment">//.........</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalesOrder</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TaxStrategy* strategy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SalesOrder</span>(StrategyFactory* strategyFactory)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;strategy = strategyFactory-&gt;<span class="built_in">NewStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SalesOrder</span>()&#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>-&gt;strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateTax</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="function">Context <span class="title">context</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> val = </span><br><span class="line">            strategy-&gt;<span class="built_in">Calculate</span>(context);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><ul><li><strong>Strategy</strong> 及其子类为组件提供了一系列可重用的方法, 从而使得类型在运行时方便地根据需要在各个算法之间进行切换</li><li><strong>Strategy 模式</strong>提供了用条件判断语句外的另一种选择, 消除条件判断语句, 就是在解耦合. 含有许多条判断语句的代码通常都需要 <strong>Strategy 模式</strong></li><li>如果 <strong>Strategy</strong> 对象没有实例变量, 那么各个上下文可以共享一个 <strong>Strategy</strong> 对象, 从而节省对象开销</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RB-tree 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/RB-tree/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/RB-tree/</url>
      
        <content type="html"><![CDATA[<h1 id="RB-tree"><a href="#RB-tree" class="headerlink" title="RB-tree"></a>RB-tree</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>红黑树是一颗非严格均衡的二叉树, 它的平衡性并没有 <strong>AVL</strong> 树那么好, 但是其在调整树结构时所需要的调整的次数是小于 <strong>AVL</strong> 的, 所以对于频繁的插入删除等操作上是由于 <strong>AVL</strong> 树. 如果没有了解过红黑树的话, 建议先去看一下</p><p> <a href="https://www.cnblogs.com/skywang12345/p/3245399.html">红黑树(一)之 原理和算法详细介绍 </a>, 否则对于下面的内容理解起来将会较为困难</p><p><strong>红黑树的特性</strong>:<br><strong>（1）每个节点或者是黑色，或者是红色。</strong><br><strong>（2）根节点是黑色。</strong><br><strong>（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]</strong><br><strong>（4）如果一个节点是红色的，则它的子节点必须是黑色的。</strong><br><strong>（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong></p><p><strong>红黑节点的定义</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 红黑定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bool</span> __rb_tree_color_type;</span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_red = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> __rb_tree_color_type __rb_tree_black = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>下面将 <strong>RB-tree</strong> 分为如下几个部分进行分析</p><ul><li>基本结构</li><li>调整红黑树结构以及颜色的策略</li><li>RB-tree 的插入 删除 以及查找</li></ul><h2 id="RB-tree-节点以及迭代器结构"><a href="#RB-tree-节点以及迭代器结构" class="headerlink" title="RB-tree 节点以及迭代器结构"></a>RB-tree 节点以及迭代器结构</h2><p>RB-tree 的节点分为两部分, 通过 <code>__rb_tree_node_base</code> 来设置指针, <code>__rb_tree_node</code> 通过继承的方式来添加节点数据,  来实现一个 <strong>RB-tree</strong> 节点的功能</p><p><strong>__rb_tree_node_base</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;</span><br><span class="line"></span><br><span class="line">  color_type color; <span class="comment">// 定义节点颜色</span></span><br><span class="line">  base_ptr parent;<span class="comment">// 定义父节点</span></span><br><span class="line">  base_ptr left;<span class="comment">// 定义左孩子</span></span><br><span class="line">  base_ptr right;<span class="comment">// 定义右孩子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找以当前节点为根的子树的最小节点 </span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">minimum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;left != <span class="number">0</span>) x = x-&gt;left;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找最大节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> base_ptr <span class="title">maximum</span><span class="params">(base_ptr x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x-&gt;right != <span class="number">0</span>) x = x-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>__rb_tree_node</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_node</span> :</span> <span class="keyword">public</span> __rb_tree_node_base</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line">  Value value_field;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>RB-tree 迭代器</strong></p><p><strong>RB-tree</strong> 迭代器属于双向迭代器, 支持前进和后退操作, 但是不具有随机访问元素的能力, 并分为 <code>__rb_tree_base_iterator</code> 和 <code>__rb_tree_iterator</code> 两部分</p><p><strong>__rb_tree_base_iterator</strong> 基本结构 </p><p>其中 <code>__rb_tree_base_iterator</code> 利用 <code>increment</code> 方法实现 ++, <code>decrement</code> 方法实现 - - 功能, 本质就是求出当前节点的前驱与后继</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_base_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base::base_ptr base_ptr;</span><br><span class="line">    <span class="comment">//定义其迭代器是一种双向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  base_ptr node; <span class="comment">//指向节点的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求该节点的前驱 后继操作</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="comment">//如果右节点不为空就选择右子树中最多侧的节点作为前驱</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="number">0</span>) &#123;</span><br><span class="line">      node = node-&gt;right;</span><br><span class="line">      <span class="keyword">while</span> (node-&gt;left != <span class="number">0</span>)</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果右子树为空, 就寻找该节点的父节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">      <span class="comment">// 如果该节点是父节点的右孩子就继续往上找, 直到y节点是父节点的左孩子</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;right) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node-&gt;right != y)</span><br><span class="line">        node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求当前节点后继</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">decrement</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">     <span class="comment">//该种情况为 node == header 时也即 end() 时出现</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;color == __rb_tree_red &amp;&amp;</span><br><span class="line">        node-&gt;parent-&gt;parent == node)</span><br><span class="line">      node = node-&gt;right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;left != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果左子树不为空, 就找左子树的最右侧节点</span></span><br><span class="line">      base_ptr y = node-&gt;left;</span><br><span class="line">      <span class="keyword">while</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">        y = y-&gt;right;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找出父节点</span></span><br><span class="line">      base_ptr y = node-&gt;parent;</span><br><span class="line">     <span class="comment">// 如果当前 node 是 y 节点的左孩子, 那么就一直向上找到第一个非父亲节左孩子的节点</span></span><br><span class="line">      <span class="keyword">while</span> (node == y-&gt;left) &#123;</span><br><span class="line">        node = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      node = y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>__rb_tree_iterator</strong> 迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rb_tree_iterator</span> :</span> <span class="keyword">public</span> __rb_tree_base_iterator<span class="comment">// 继承__rb_tree_base_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Value&amp;, Value*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, <span class="keyword">const</span> Value&amp;, <span class="keyword">const</span> Value*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt;                   self;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt;* link_type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">  __rb_tree_iterator() &#123;&#125;</span><br><span class="line">  __rb_tree_iterator(link_type x) &#123; node = x; &#125;<span class="comment">// 初始化node节点</span></span><br><span class="line">  __rb_tree_iterator(<span class="keyword">const</span> iterator&amp; it) &#123; node = it.node; &#125;<span class="comment">// 初始化node节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载指针</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">link_type</span>(node)-&gt;value_field; &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载++与--操作, 调用 increment 和 decrement 方法</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123; <span class="built_in">increment</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">increment</span>();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; <span class="built_in">decrement</span>(); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="built_in">decrement</span>();</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>重载操作符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==与!= 比较两个tree的node是相同</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> __rb_tree_base_iterator&amp; x,</span><br><span class="line">                       <span class="keyword">const</span> __rb_tree_base_iterator&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.node == y.node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> __rb_tree_base_iterator&amp; x,</span><br><span class="line">                       <span class="keyword">const</span> __rb_tree_base_iterator&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.node != y.node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RB-tree</strong> 的迭代器也提供了 <strong>traits</strong> 编程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> bidirectional_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> __rb_tree_base_iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bidirectional_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> __rb_tree_base_iterator::difference_type*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> __rb_tree_base_iterator&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (__rb_tree_base_iterator::difference_type*) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Value* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> __rb_tree_iterator&lt;Value, Ref, Ptr&gt;&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Value*) <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br></pre></td></tr></table></figure><h2 id="红黑树调整结构以及节点颜色策略"><a href="#红黑树调整结构以及节点颜色策略" class="headerlink" title="红黑树调整结构以及节点颜色策略"></a>红黑树调整结构以及节点颜色策略</h2><h3 id="旋转操作"><a href="#旋转操作" class="headerlink" title="旋转操作"></a><strong>旋转操作</strong></h3><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/03/03/btyPtf.png" alt="image-20220303214005392"></p><p>由于左右旋转的方式是基本相同的, 所以这里只对右旋转进行分析</p><p>观察上图, 当对一个节点进行右旋转的时候, 需要以下几步</p><ol><li>若 A 节点的左孩子不为空, 则将A 的左孩子指向自己左孩子的右孩子</li><li>将 原来 A 左孩子(B) 的右孩子的父亲指向 A 的左孩子</li><li>将之前左孩子(B) 的右孩子指向 A 节点</li><li>将 A 之前左孩子(B) 的父亲节点指向 A 的父亲节点</li><li>A 节点的父亲节点重新指向远左孩子(B)</li></ol><p><strong>右旋转代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__rb_tree_rotate_right(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//y 为 x 的左孩子节点</span></span><br><span class="line">  __rb_tree_node_base* y = x-&gt;left;</span><br><span class="line">    <span class="comment">// x 的左孩子节点指向 y 的右孩子节点</span></span><br><span class="line">  x-&gt;left = y-&gt;right;</span><br><span class="line">    <span class="comment">// 如何 y 的右孩子节点不为 0 就将其父节点指向 x</span></span><br><span class="line">  <span class="keyword">if</span> (y-&gt;right != <span class="number">0</span>)</span><br><span class="line">    y-&gt;right-&gt;parent = x;</span><br><span class="line">    <span class="comment">//y 的父亲节点指向 x 的父亲节点</span></span><br><span class="line">  y-&gt;parent = x-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果旋转的是根节点, 那么 y 就作为新的根节点</span></span><br><span class="line">  <span class="keyword">if</span> (x == root)</span><br><span class="line">    root = y;</span><br><span class="line">    <span class="comment">// x 作为父节点的右孩子, x 的父亲节点的右孩子节点指向 y</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (x == x-&gt;parent-&gt;right)</span><br><span class="line">     <span class="comment">// x 的父节点的右孩子节点指向 y</span></span><br><span class="line">    x-&gt;parent-&gt;right = y;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">      <span class="comment">//否则 x 的父亲节点的左孩子节点指向 y</span></span><br><span class="line">    x-&gt;parent-&gt;left = y;</span><br><span class="line">    <span class="comment">// y 的右孩子节点指向 x</span></span><br><span class="line">  y-&gt;right = x;</span><br><span class="line">    <span class="comment">// x 的父亲节点指向 y</span></span><br><span class="line">  x-&gt;parent = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="调整红黑树节点颜色"><a href="#调整红黑树节点颜色" class="headerlink" title="调整红黑树节点颜色"></a><strong>调整红黑树节点颜色</strong></h3><p><strong>注: 该部分图片都引用自开头提供的文章链接</strong></p><p>只有在<strong>添加</strong>和<strong>删除</strong>红黑树节点时才需要对红黑树的节点颜色进行调整</p><h4 id="添加"><a href="#添加" class="headerlink" title="添加"></a><strong>添加</strong></h4><p>这里只讨论添加完成后如何调整颜色, 对于插入操作会在分析删除插入以及查询时进行分析</p><p>首先规定, 当插入一个节点后, 给新插入节点着色为红色, 然后调整红黑树来使其依旧满足所有性质</p><p><strong>对于新插入节点后的调整, 有下面几种情况:</strong></p><ol><li> 当前节点的父亲节点为红色, 且当前节点的叔叔节点也是红色</li></ol><p>   <strong>处理策略:</strong></p><p>   ​    Ⅰ 将父亲节点变为黑色</p><p>   ​    Ⅱ 将叔叔节点变为黑色</p><p>   ​    Ⅲ 将祖父节点变为红色</p><p>   ​    Ⅳ 将祖父节点设置为<strong>当前节点</strong>, 并对新的<strong>当前节点</strong>进行操作</p><p>   <img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://images0.cnblogs.com/i/497634/201403/251759273578917.jpg" alt="case 1"></p><ol start="2"><li><p>当前节点以及父亲节点为红色, 叔叔节点为黑色且当前节点为父节点的右儿子</p><p><strong>处理策略</strong></p><p>​    Ⅰ 将父节点作为<strong>当前节点</strong>, 对父节点进行左旋操作</p><p>​    Ⅱ 将新的<strong>当前节点</strong>进行左旋</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://images0.cnblogs.com/i/497634/201403/251801031546918.jpg" alt="case2"></p></li><li><p>当前节点以及父亲节点为红色, 叔叔节点为黑色且当前节点为父节点的左儿子    </p><p><strong>处理策略:</strong></p><p>​    Ⅰ 将父亲节点设置为黑色</p><p>​    Ⅱ 将当前节点的祖父节点设置为红色</p><p>​    Ⅲ 将祖父节点进行右旋</p><p><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://images0.cnblogs.com/i/497634/201404/170945094945387.jpg" alt="case 3"></p></li></ol><p>通过上图可以发现其实 <strong>Case 2</strong> 后会转化为 <strong>Case 3</strong> 的情况, 所以在源码实现时可以将 <strong>Case2</strong> 和 <strong>Case3</strong> 合并起来, 事实上源码也是这样进行操作的, 并且如果父节点是祖父节点的右儿子, 操作步骤是一样的, 不过有关旋转的方向反一下就可以. 在最后由于旋转到根节点时, 根节点可能会是红色, 所以需要判断一下根节点是不是红色, 如果是红色, 那么就将根节点变为黑色</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> </span><br><span class="line">__rb_tree_rebalance(__rb_tree_node_base* x, __rb_tree_node_base*&amp; root)</span><br><span class="line">&#123;</span><br><span class="line">  x-&gt;color = __rb_tree_red;</span><br><span class="line">  <span class="keyword">while</span> (x != root &amp;&amp; x-&gt;parent-&gt;color == __rb_tree_red) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;parent == x-&gt;parent-&gt;parent-&gt;left) &#123;</span><br><span class="line">      __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;right;</span><br><span class="line">      <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red) &#123;</span><br><span class="line">        x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">        y-&gt;color = __rb_tree_black;</span><br><span class="line">        x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">        x = x-&gt;parent-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">// 如果不存在 y 也说明 y 是黑色 (默认空节点为黑色节点)</span></span><br><span class="line">        <span class="keyword">if</span> (x == x-&gt;parent-&gt;right) &#123;</span><br><span class="line">          x = x-&gt;parent;</span><br><span class="line">          __rb_tree_rotate_left(x, root);</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">        x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">        __rb_tree_rotate_right(x-&gt;parent-&gt;parent, root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __rb_tree_node_base* y = x-&gt;parent-&gt;parent-&gt;left;</span><br><span class="line">      <span class="keyword">if</span> (y &amp;&amp; y-&gt;color == __rb_tree_red) &#123;</span><br><span class="line">        x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">        y-&gt;color = __rb_tree_black;</span><br><span class="line">        x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">        x = x-&gt;parent-&gt;parent;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == x-&gt;parent-&gt;left) &#123;</span><br><span class="line">          x = x-&gt;parent;</span><br><span class="line">          __rb_tree_rotate_right(x, root);</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;parent-&gt;color = __rb_tree_black;</span><br><span class="line">        x-&gt;parent-&gt;parent-&gt;color = __rb_tree_red;</span><br><span class="line">        __rb_tree_rotate_left(x-&gt;parent-&gt;parent, root);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  root-&gt;color = __rb_tree_black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>由于删除操作和调整操作是在一起实现的, 所以这里就一起进行分析</p><p>首先看删除节点, 删除就和其他 <strong>BinarySearchTree</strong> 一样</p><ol><li> 如果是最多只有一个节点, 直接删除该节点, 并将子节点接到其在父节点原来的位置上</li><li>如果有两个子节点, 则找到该节点的后继, 并利用后继去替换当前要删除的节点, 这时问题转化为了删除后继节点问题, 又由于<strong>后继只可能会拥有右儿子</strong>, 所以就转化为了<strong>情况1</strong> 进行删除 </li></ol><p>在删除后将进行调整红黑树的颜色</p><p><strong>删除</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> __rb_tree_node_base*</span><br><span class="line">__rb_tree_rebalance_for_erase(__rb_tree_node_base* z,</span><br><span class="line">                              __rb_tree_node_base*&amp; root,</span><br><span class="line">                              __rb_tree_node_base*&amp; leftmost,</span><br><span class="line">                              __rb_tree_node_base*&amp; rightmost)</span><br><span class="line">&#123;</span><br><span class="line">  __rb_tree_node_base* y = z;</span><br><span class="line">  __rb_tree_node_base* x = <span class="number">0</span>; </span><br><span class="line">  __rb_tree_node_base* x_parent = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">if</span> (y-&gt;left == <span class="number">0</span>)             <span class="comment">// z has at most one non-null child. y == z.</span></span><br><span class="line">    x = y-&gt;right;               <span class="comment">// x might be null.</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;right == <span class="number">0</span>)          <span class="comment">// z has exactly one non-null child.  y == z.</span></span><br><span class="line">      x = y-&gt;left;              <span class="comment">// x is not null.</span></span><br><span class="line">    <span class="keyword">else</span> &#123;                      <span class="comment">// z has two non-null children.  Set y to</span></span><br><span class="line">      y = y-&gt;right;             <span class="comment">//   z&#x27;s successor.  x might be null.</span></span><br><span class="line">      <span class="keyword">while</span> (y-&gt;left != <span class="number">0</span>)</span><br><span class="line">        y = y-&gt;left;</span><br><span class="line">      x = y-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果是两非空子节点的情况, 此时 y 为 要删除节点的后继</span></span><br><span class="line">    <span class="comment">// 这里的替换其实是将 z 原来的父子节点关系全部接入到后继 y 的父子关系上, 然后再对 z 进行删除</span></span><br><span class="line">  <span class="keyword">if</span> (y != z) &#123;               </span><br><span class="line">      <span class="comment">// relink y in place of z.  y is z&#x27;s successor</span></span><br><span class="line">    <span class="comment">// 先将要删除节点的左儿子的父节点指向后继 y</span></span><br><span class="line">    z-&gt;left-&gt;parent = y; </span><br><span class="line">    y-&gt;left = z-&gt;left;</span><br><span class="line">    <span class="comment">// 如果 y 不是要删除节点 z 的右儿子</span></span><br><span class="line">    <span class="keyword">if</span> (y != z-&gt;right) &#123;</span><br><span class="line">      x_parent = y-&gt;parent;</span><br><span class="line">      <span class="keyword">if</span> (x) x-&gt;parent = y-&gt;parent;</span><br><span class="line">      y-&gt;parent-&gt;left = x;      <span class="comment">// y must be a left child</span></span><br><span class="line">      y-&gt;right = z-&gt;right;</span><br><span class="line">      z-&gt;right-&gt;parent = y;</span><br><span class="line">    &#125; <span class="comment">// 如果 y 是要删除节点 z 的右儿子</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="comment">//那么就没有把 x 接给后继 y 父亲节点的需要</span></span><br><span class="line">      x_parent = y;  </span><br><span class="line">    <span class="keyword">if</span> (root == z)</span><br><span class="line">      root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;parent-&gt;left == z)</span><br><span class="line">      z-&gt;parent-&gt;left = y;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      z-&gt;parent-&gt;right = y;</span><br><span class="line">    y-&gt;parent = z-&gt;parent;</span><br><span class="line">    __STD::<span class="built_in">swap</span>(y-&gt;color, z-&gt;color); <span class="comment">// 把 y 原来的颜色替换为要删除节点的颜色以保证平衡性</span></span><br><span class="line">    y = z;</span><br><span class="line">    <span class="comment">// y now points to node to be actually deleted</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">else</span> &#123;                        <span class="comment">// y == z</span></span><br><span class="line">    x_parent = y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (x) x-&gt;parent = y-&gt;parent;   </span><br><span class="line">    <span class="keyword">if</span> (root == z)</span><br><span class="line">      root = x;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">if</span> (z-&gt;parent-&gt;left == z)</span><br><span class="line">        z-&gt;parent-&gt;left = x;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        z-&gt;parent-&gt;right = x;</span><br><span class="line">    <span class="keyword">if</span> (leftmost == z) </span><br><span class="line">      <span class="keyword">if</span> (z-&gt;right == <span class="number">0</span>)        <span class="comment">// z-&gt;left must be null also</span></span><br><span class="line">        leftmost = z-&gt;parent; <span class="comment">//如果删除的是最小节点, 那么如果没有右子节点, 就说明其父节点为最小节点</span></span><br><span class="line">    <span class="comment">// makes leftmost == header if z == root</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">// 反之就去其原右子树中寻找最小节点, (此时右子树为要删除父亲节点的左子树)</span></span><br><span class="line">        leftmost = __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">    <span class="keyword">if</span> (rightmost == z)  </span><br><span class="line">      <span class="keyword">if</span> (z-&gt;left == <span class="number">0</span>)         <span class="comment">// z-&gt;right must be null also</span></span><br><span class="line">        rightmost = z-&gt;parent;  </span><br><span class="line">    <span class="comment">// makes rightmost == header if z == root</span></span><br><span class="line">      <span class="keyword">else</span>                      <span class="comment">// x == z-&gt;left</span></span><br><span class="line">        rightmost = __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">  &#125; </span><br><span class="line">.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调整</strong></p><p>在进行上面删除操作时, 我们发现其实  <strong>x_parent</strong> 这个变量在删除的时候并没有什么实际作用, 只是在记录一些值, 这个值在进行删除的时候确实没有什么作用, 其是用于进行调整时所使用的, 记录的实际是在后继被替换到要删除节点后其原右子节点的新父亲节点</p><p>对于调整, 我们先来回顾一下红黑树的 5 条性质</p><blockquote><p>(1) 每个节点或者是黑色，或者是红色。<br>(2) 根节点是黑色。<br>(3) 每个叶子节点是黑色。 [注意：这里叶子节点，是指为空的叶子节点！]<br>(4) 如果一个节点是红色的，则它的子节点必须是黑色的。<br>(5) 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</p></blockquote><p>当从红黑树中删除了一个节点后, 可能会<strong>违反特性 (2), (4), (5)</strong> , 所以在调整阶段, 需要解决上面的三个问题, 使得调整后的树满足红黑树的全部特性.</p><p>在看过<strong>红黑树的删除</strong>操作后, 我们知道, 在删除了节点 y 后, 其右儿子节点 x 占据原来 y 的位置, 如果删除的节点是一个黑色节点, 意味着在其他节点到这个节点的子树中, 黑色节点的数量将减一, 那么, 可以通过在该位置再次添加一个黑色, 这样就保证了 <strong>“特性(5)”</strong> 不会被破坏.</p><p>如此做, x 现在就不仅包含其原有颜色, 还多包含一个额外的黑色. 也即它的节点颜色为 <strong>“红加黑”</strong>, 或者 <strong>“黑加黑”</strong>, 其违反了 <strong>“特性(1)”</strong> </p><p>现在, 成功将问题从破坏了 <strong>特性(2), (4), (5)</strong> 转变为了破坏 <strong>特性(1), (2), (4)</strong>. 而下面的调整策略 **__rb_tree_rebalance ** 的思想为: 将 x 所包含的额外的黑色沿树不断上移(即向根方向移动), 直到出现了下面的情况:</p><ul><li><p>情况一:  x 此时为一个 <strong>“黑 + 红”</strong> 节点</p><p>处理方式: 直接将 x 设置为黑色. 至此红黑树性质全部恢复</p></li><li><p>情况二: x 是 <strong>“黑 + 黑”</strong> 节点, 且 x 是<strong>根节点</strong>.</p><p>处理方式: 什么都不做, 结束. 此时红黑树的性质全部恢复</p></li><li><p>情况三: x 是 <strong>“黑 + 黑”</strong> 节点, 且 x 不是根</p><p>处理方式: 这种情况可以划分为 4 种情况, 但是在 <code>RB-tree</code> 的实现中进行了精简, 所以下面只介绍源码中的实现, 如果想了解上面的 4 种情况, 可以去文章开头提供的<strong>红黑树原理分析</strong></p><p>==这里只以 x 为父节点左儿子, 右儿子的操作于左儿子的操作方向相反.==   w 是 x 的<strong>兄弟节点</strong></p><ol><li> x 是 <strong>“黑 + 黑”</strong> 节点, w 是<strong>红色</strong>节点(此时x的父节点和x的兄弟节点的子节点都是黑节点)</li></ol><p>   <strong>处理方式:</strong></p><ul><li>将 w 节点染为黑色</li><li>将 x 的父亲节点染为<strong>红色</strong></li><li>将 x 的父亲节点进行<strong>左旋</strong></li><li>重新设置 x 的兄弟节点 w</li></ul><ol start="2"><li>  x 是 <strong>“黑 + 黑”</strong> 节点,  w 是<strong>黑色</strong>节点(如果是空节点则默认黑色),  w 的两个儿子都是<strong>黑色</strong></li></ol><p>   <strong>处理方式:</strong></p><ul><li>将 w 染为<strong>红色</strong>, 将 x 的父亲设置为 x 节点, 也即将额外的一个<strong>黑色</strong>传递给其父亲</li></ul><p><strong>注: 源码在实现中, 1, 2步骤之间没有使用else 分开, 而是 if 之后就是另一种情况的 if, 在我的浅略分析来看, 如果其中一种情况处理完后, 一定会满足下一步中的 w 节点为黑的情况, 如果不满足第一个条件, 说明w本身就是==黑色==, 所以经过第一种情况之后, w一定是黑色的, 故只需要判断其他条件即可</strong> </p><ol start="3"><li> x是 <strong>“黑+黑” <strong>节点，w 节点是</strong>黑色</strong>, 且 w 的右儿子<strong>为空</strong>或者<strong>为红色</strong></li></ol><p>   <strong>处理方式:</strong></p><ul><li>如果 w 有左儿子, 就将 w 的左儿子染为<strong>黑色</strong></li><li>将 w 染为<strong>红色</strong></li><li>对 w 进行<strong>右旋</strong></li><li>重新设置 x 的兄弟节点 w</li></ul><p>   接下来就是上文中提到的 <strong>第四种情况</strong> , 但是在实现中, 可能是保证了在对第三种情况处理完之后一定会处于第四种情况, 所以将其并入到第三种情况的操作之中, 这里补充一下这种情况: </p><p>   ​    x 是 <strong>“黑+黑”</strong> 节点，w 是<strong>黑色</strong>；w 的右儿子是<strong>红色</strong>的，w 的左儿子<strong>任意颜色</strong></p><ul><li>将 w 的颜色染为 x 的父亲节点的颜色</li><li>将 x 的父亲节点的颜色染为<strong>黑色</strong></li><li>如果 w 的右儿子存在, 则将其染为<strong>黑色</strong> </li><li>将 x 的父节点左旋</li></ul><p>   在执行完<strong>情况四</strong>的处理之后, 此时红黑树的性质就全部修正好, 此时退出循环就可以了(我并不能明白上面步骤的正确性… 如果有能力且有兴趣的同学可以去看一下证明, 在此我就只介绍如何进行修正操作了…)</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (y-&gt;color != __rb_tree_red) &#123; </span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; (x == <span class="number">0</span> || x-&gt;color == __rb_tree_black))</span><br><span class="line">      <span class="keyword">if</span> (x == x_parent-&gt;left) &#123;</span><br><span class="line">        __rb_tree_node_base* w = x_parent-&gt;right;</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;color == __rb_tree_red) &#123;</span><br><span class="line">          w-&gt;color = __rb_tree_black;</span><br><span class="line">          x_parent-&gt;color = __rb_tree_red;</span><br><span class="line">          __rb_tree_rotate_left(x_parent, root);</span><br><span class="line">          w = x_parent-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((w-&gt;left == <span class="number">0</span> || w-&gt;left-&gt;color == __rb_tree_black) &amp;&amp;</span><br><span class="line">            (w-&gt;right == <span class="number">0</span> || w-&gt;right-&gt;color == __rb_tree_black)) &#123;</span><br><span class="line">          w-&gt;color = __rb_tree_red;</span><br><span class="line">          x = x_parent;</span><br><span class="line">          x_parent = x_parent-&gt;parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (w-&gt;right == <span class="number">0</span> || w-&gt;right-&gt;color == __rb_tree_black) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;left) w-&gt;left-&gt;color = __rb_tree_black;</span><br><span class="line">            w-&gt;color = __rb_tree_red;</span><br><span class="line">            __rb_tree_rotate_right(w, root);</span><br><span class="line">            w = x_parent-&gt;right;</span><br><span class="line">          &#125;</span><br><span class="line">          w-&gt;color = x_parent-&gt;color;</span><br><span class="line">          x_parent-&gt;color = __rb_tree_black;</span><br><span class="line">          <span class="keyword">if</span> (w-&gt;right) w-&gt;right-&gt;color = __rb_tree_black;</span><br><span class="line">          __rb_tree_rotate_left(x_parent, root);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;                  <span class="comment">// same as above, with right &lt;-&gt; left.</span></span><br><span class="line">        __rb_tree_node_base* w = x_parent-&gt;left;</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;color == __rb_tree_red) &#123;</span><br><span class="line">          w-&gt;color = __rb_tree_black;</span><br><span class="line">          x_parent-&gt;color = __rb_tree_red;</span><br><span class="line">          __rb_tree_rotate_right(x_parent, root);</span><br><span class="line">          w = x_parent-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((w-&gt;right == <span class="number">0</span> || w-&gt;right-&gt;color == __rb_tree_black) &amp;&amp;</span><br><span class="line">            (w-&gt;left == <span class="number">0</span> || w-&gt;left-&gt;color == __rb_tree_black)) &#123;</span><br><span class="line">          w-&gt;color = __rb_tree_red;</span><br><span class="line">          x = x_parent;</span><br><span class="line">          x_parent = x_parent-&gt;parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (w-&gt;left == <span class="number">0</span> || w-&gt;left-&gt;color == __rb_tree_black) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w-&gt;right) w-&gt;right-&gt;color = __rb_tree_black;</span><br><span class="line">            w-&gt;color = __rb_tree_red;</span><br><span class="line">            __rb_tree_rotate_left(w, root);</span><br><span class="line">            w = x_parent-&gt;left;</span><br><span class="line">          &#125;</span><br><span class="line">          w-&gt;color = x_parent-&gt;color;</span><br><span class="line">          x_parent-&gt;color = __rb_tree_black;</span><br><span class="line">          <span class="keyword">if</span> (w-&gt;left) w-&gt;left-&gt;color = __rb_tree_black;</span><br><span class="line">          __rb_tree_rotate_right(x_parent, root);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (x) x-&gt;color = __rb_tree_black;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RB-tree-1"><a href="#RB-tree-1" class="headerlink" title="RB-tree"></a>RB-tree</h2><h3 id="RB-tree-基本类型定义"><a href="#RB-tree-基本类型定义" class="headerlink" title="RB-tree 基本类型定义"></a>RB-tree 基本类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node_base* base_ptr;<span class="comment">// 定义节点指针</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_node&lt;Value&gt; rb_tree_node;<span class="comment">// 定义节点</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;rb_tree_node, Alloc&gt; rb_tree_node_allocator;<span class="comment">// 定义空间配置器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_color_type color_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 满足traits编程</span></span><br><span class="line">  <span class="keyword">typedef</span> Key key_type;</span><br><span class="line">  <span class="keyword">typedef</span> Value value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> rb_tree_node* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  size_type node_count; <span class="comment">// keeps track of size of tree</span></span><br><span class="line">  link_type header;  <span class="comment">// 头节点, 不是根节点, 头节点是指向根节点</span></span><br><span class="line">  Compare key_compare;<span class="comment">// 伪函数</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 定义迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, reference, pointer&gt; iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __rb_tree_iterator&lt;value_type, const_reference, const_pointer&gt; </span><br><span class="line">          const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,</span><br><span class="line">                                         difference_type&gt;</span><br><span class="line">          reverse_iterator; </span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,</span><br><span class="line">                                         const_reference, difference_type&gt;</span><br><span class="line">          const_reverse_iterator;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="获取节点属性"><a href="#获取节点属性" class="headerlink" title="获取节点属性"></a>获取节点属性</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">link_type&amp; <span class="title">root</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;parent; &#125;<span class="comment">// 获取根节点</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">leftmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;left; &#125;<span class="comment">// 最小节点</span></span><br><span class="line">  <span class="function">link_type&amp; <span class="title">rightmost</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;) header-&gt;right; &#125;<span class="comment">// 最大节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前节点的左节点</span></span><br><span class="line"><span class="comment">// 当前节点的右节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">    <span class="comment">//获取父亲节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">    <span class="comment">// 获取节点数据</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> x-&gt;value_field; &#125;\</span><br><span class="line">    <span class="comment">// 从节点数据中获取 key 值</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(x)); &#125;</span><br><span class="line">    <span class="comment">// 获取节点颜色</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(link_type x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(x-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于传入的 base 指针的重载版</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">left</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;left); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">right</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;right); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type&amp; <span class="title">parent</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (link_type&amp;)(x-&gt;parent); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> reference <span class="title">value</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> ((link_type)x)-&gt;value_field; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">KeyOfValue</span>()(<span class="built_in">value</span>(<span class="built_in">link_type</span>(x)));&#125; </span><br><span class="line">  <span class="function"><span class="keyword">static</span> color_type&amp; <span class="title">color</span><span class="params">(base_ptr x)</span> </span>&#123; <span class="keyword">return</span> (color_type&amp;)(<span class="built_in">link_type</span>(x)-&gt;color); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">minimum</span><span class="params">(link_type x)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (link_type)  __rb_tree_node_base::<span class="built_in">minimum</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最大节点</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> link_type <span class="title">maximum</span><span class="params">(link_type x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (link_type) __rb_tree_node_base::<span class="built_in">maximum</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">                                <span class="comment">// accessors:</span></span><br><span class="line">  <span class="function">Compare <span class="title">key_comp</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> key_compare; &#125;</span><br><span class="line">  <span class="comment">// begin() 获取的是最小节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">leftmost</span>(); &#125;</span><br><span class="line">  <span class="comment">// end() 为头节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> header; &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">  &#125; </span><br><span class="line">   <span class="comment">//判断是否树为空</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count == <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="comment">// 返回节点数</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node_count; &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造析构函数"><a href="#构造析构函数" class="headerlink" title="构造析构函数"></a>构造析构函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:                          <span class="comment">// allocation/deallocation</span></span><br><span class="line">  <span class="built_in">rb_tree</span>(<span class="keyword">const</span> Compare&amp; comp = <span class="built_in">Compare</span>())</span><br><span class="line">    : <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(comp) &#123; <span class="built_in">init</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">rb_tree</span>(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x) : <span class="built_in">node_count</span>(<span class="number">0</span>), <span class="built_in">key_compare</span>(x.key_compare)</span><br><span class="line">  &#123; </span><br><span class="line">    header = <span class="built_in">get_node</span>();</span><br><span class="line">      <span class="comment">//头节点默认为红色</span></span><br><span class="line">    <span class="built_in">color</span>(header) = __rb_tree_red;</span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">root</span>() == <span class="number">0</span>) &#123;<span class="comment">// 如果x为根节点</span></span><br><span class="line">      <span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">leftmost</span>() = header;<span class="comment">// 左孩子指向根节点</span></span><br><span class="line">      <span class="built_in">rightmost</span>() = header;<span class="comment">// 右孩子指向根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        <span class="built_in">root</span>() = __copy(x.<span class="built_in">root</span>(), header);</span><br><span class="line">      &#125;</span><br><span class="line">      __STL_UNWIND(<span class="built_in">put_node</span>(header));</span><br><span class="line">      <span class="built_in">leftmost</span>() = <span class="built_in">minimum</span>(<span class="built_in">root</span>());<span class="comment">// 左孩子始终指向最小的节点</span></span><br><span class="line">      <span class="built_in">rightmost</span>() = <span class="built_in">maximum</span>(<span class="built_in">root</span>());<span class="comment">// 右孩子始终指向最大的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    node_count = x.node_count;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 析构函数</span></span><br><span class="line">  ~<span class="built_in">rb_tree</span>() &#123;</span><br><span class="line">    <span class="built_in">clear</span>();<span class="comment">// 清除或有节点</span></span><br><span class="line">    <span class="built_in">put_node</span>(header);<span class="comment">// 释放所有空间</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p><strong>RB-tree</strong> 交换只是交换了<strong>头节点</strong>, <strong>节点数</strong>和用于比较的<strong>仿函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; t)</span> </span>&#123;</span><br><span class="line">    __STD::<span class="built_in">swap</span>(header, t.header);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(node_count, t.node_count);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(key_compare, t.key_compare);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x, </span></span></span><br><span class="line"><span class="params"><span class="function">                 rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y)</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相等比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x, </span><br><span class="line">                       <span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">equal</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x, </span><br><span class="line">                      <span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载=运算符</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line"><span class="keyword">operator</span>=(<span class="keyword">const</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;x) &#123;</span><br><span class="line">                                <span class="comment">// Note that Key may be a constant type.</span></span><br><span class="line"><span class="comment">//删除所有节点</span></span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    node_count = <span class="number">0</span>;</span><br><span class="line">    key_compare = x.key_compare;        </span><br><span class="line"><span class="comment">//给每一个节点进行赋值</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">root</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">root</span>() = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">leftmost</span>() = header;</span><br><span class="line">      <span class="built_in">rightmost</span>() = header;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">root</span>() = __copy(x.<span class="built_in">root</span>(), header);</span><br><span class="line">      <span class="built_in">leftmost</span>() = <span class="built_in">minimum</span>(<span class="built_in">root</span>());</span><br><span class="line">      <span class="built_in">rightmost</span>() = <span class="built_in">maximum</span>(<span class="built_in">root</span>());</span><br><span class="line">      node_count = x.node_count;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RB-tree-操作方法简介"><a href="#RB-tree-操作方法简介" class="headerlink" title="RB-tree 操作方法简介"></a>RB-tree 操作方法简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rb_tree</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  iterator __insert(base_ptr x, base_ptr y, <span class="keyword">const</span> value_type&amp; v);</span><br><span class="line"><span class="comment">//将 x 为根的树赋值给, 父节点指向 p 的根的树</span></span><br><span class="line">  link_type __copy(link_type x, link_type p);</span><br><span class="line">    <span class="comment">// 删除节点 x</span></span><br><span class="line">  <span class="keyword">void</span> __erase(link_type x);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                <span class="comment">// insert/erase</span></span><br><span class="line">    <span class="comment">//只允许插入不存在的数据</span></span><br><span class="line">  <span class="function">pair&lt;iterator,<span class="keyword">bool</span>&gt; <span class="title">insert_unique</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">//寻找要在哪一个节点下插入</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 pos 处插入不重复的数据</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert_unique</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">// 在 pos 处插入可重复的数据</span></span><br><span class="line">  <span class="function">iterator <span class="title">insert_equal</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将两个迭代器之间的数据插入 unique(数据不可重复), equal(数据可以重复)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_unique</span><span class="params">(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(const_iterator first, const_iterator last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert_equal</span><span class="params">(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除 pos 处的节点</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span>;</span><br><span class="line">    <span class="comment">// 删除值为 x 的节点</span></span><br><span class="line">  <span class="function">size_type <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">    <span class="comment">// 删除两个迭代器之间的元素</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">    <span class="comment">// 重载的指针版本</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">const</span> key_type* first, <span class="keyword">const</span> key_type* last)</span></span>;</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                <span class="comment">// set operations:</span></span><br><span class="line">    <span class="comment">// 查询值为 x 的节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">find</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 值为 x 的节点数量</span></span><br><span class="line">  <span class="function">size_type <span class="title">count</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">lower_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">  <span class="function">const_iterator <span class="title">upper_bound</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">pair&lt;iterator,iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span></span>;</span><br><span class="line">  <span class="function">pair&lt;const_iterator, const_iterator&gt; <span class="title">equal_range</span><span class="params">(<span class="keyword">const</span> key_type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">                                <span class="comment">// Debugging.</span></span><br><span class="line">  <span class="keyword">bool</span> __rb_verify() <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里只具体分析插入和删除的情况</p><h3 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h3><h4 id="insert-base-ptr-x-base-ptr-y-const-Value-amp-v"><a href="#insert-base-ptr-x-base-ptr-y-const-Value-amp-v" class="headerlink" title="_insert(base_ptr x, base_ptr y, const Value&amp; v)"></a>_<em><em>insert(base_ptr x</em>, base_ptr y</em>, const Value&amp; v)</h4><p>以 <strong>y</strong> 为父节点插入值为 <strong>v</strong> 的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::</span><br><span class="line">__insert(base_ptr x_, base_ptr y_, <span class="keyword">const</span> Value&amp; v) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// x为要插入的节点</span></span><br><span class="line">    <span class="comment">// y : 插入节点的父节点</span></span><br><span class="line">    <span class="comment">// v : 插入节点的数据</span></span><br><span class="line">  link_type x = (link_type) x_;</span><br><span class="line">  link_type y = (link_type) y_;</span><br><span class="line">  link_type z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果y是头节点, 将插入的节点设置为根节点</span></span><br><span class="line">  <span class="keyword">if</span> (y == header || x != <span class="number">0</span> || <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(y))) &#123;</span><br><span class="line">    z = <span class="built_in">create_node</span>(v);</span><br><span class="line">      <span class="comment">// 左节点指向z</span></span><br><span class="line">    <span class="built_in">left</span>(y) = z;                <span class="comment">// also makes leftmost() = z when y == header</span></span><br><span class="line">      <span class="comment">// y是头节点, 根节点就是z</span></span><br><span class="line">    <span class="keyword">if</span> (y == header) &#123;</span><br><span class="line">      <span class="built_in">root</span>() = z;</span><br><span class="line">      <span class="built_in">rightmost</span>() = z;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 如果y是最小节点, 则把z修改为最小节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="built_in">leftmost</span>())</span><br><span class="line">      <span class="built_in">leftmost</span>() = z;           <span class="comment">// maintain leftmost() pointing to min node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    z = <span class="built_in">create_node</span>(v);</span><br><span class="line">    <span class="built_in">right</span>(y) = z;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="built_in">rightmost</span>())</span><br><span class="line">      <span class="built_in">rightmost</span>() = z;          <span class="comment">// maintain rightmost() pointing to max node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">parent</span>(z) = y;</span><br><span class="line">  <span class="built_in">left</span>(z) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">right</span>(z) = <span class="number">0</span>;</span><br><span class="line">  __rb_tree_rebalance(z, header-&gt;parent);</span><br><span class="line"><span class="comment">// 节点数增加 1</span></span><br><span class="line">  ++node_count;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(z);<span class="comment">// 返回节点z迭代器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中的<strong>参数 x</strong>其实并没有什么实际用处, 只是为了方便函数的重载</p><h4 id="insert-equal-const-Value-amp-v"><a href="#insert-equal-const-Value-amp-v" class="headerlink" title="insert_equal(const Value&amp; v)"></a>insert_equal(const Value&amp; v)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到要在哪一个节点下插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  link_type y = header;</span><br><span class="line">  link_type x = <span class="built_in">root</span>();</span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">    y = x;</span><br><span class="line">    x = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x)) ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __insert(x, y, v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不允许重复插入-pair-lt-iterator-bool-gt-insert-unique-const-Value-amp-v"><a href="#不允许重复插入-pair-lt-iterator-bool-gt-insert-unique-const-Value-amp-v" class="headerlink" title="不允许重复插入 pair&lt;iterator, bool&gt; insert_unique(const Value&amp; v)"></a>不允许重复插入 pair&lt;iterator, bool&gt; insert_unique(const Value&amp; v)</h4><p>第二个参数如果为 <strong>true</strong>, 则说明插入成功, 反之则失败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">pair&lt;<span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator, <span class="keyword">bool</span>&gt;</span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(<span class="keyword">const</span> Value&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">  link_type y = header;</span><br><span class="line">  link_type x = <span class="built_in">root</span>();</span><br><span class="line">  <span class="keyword">bool</span> comp = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 找到合适的节点</span></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">    y = x;</span><br><span class="line">    comp = <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(x));</span><br><span class="line">    x = comp ? <span class="built_in">left</span>(x) : <span class="built_in">right</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  iterator j = <span class="built_in">iterator</span>(y);   </span><br><span class="line">  <span class="keyword">if</span> (comp)</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="built_in">begin</span>())     </span><br><span class="line">      <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      --j;</span><br><span class="line">    <span class="comment">// 找到插入的节点是否已经存在了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(j.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">    <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(__insert(x, y, v), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">return</span> pair&lt;iterator,<span class="keyword">bool</span>&gt;(j, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Val</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::iterator </span><br><span class="line">rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_unique</span>(iterator position,<span class="keyword">const</span> Val&amp; v) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (position.node == header-&gt;left) <span class="comment">// begin()</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(position.node)))</span><br><span class="line">      <span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">  <span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">insert_unique</span>(v).first;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (position.node == header) <span class="comment">// end()</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(<span class="built_in">rightmost</span>()), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">      <span class="keyword">return</span> __insert(<span class="number">0</span>, <span class="built_in">rightmost</span>(), v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">insert_unique</span>(v).first;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iterator before = position;</span><br><span class="line">    --before;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">key_compare</span>(<span class="built_in">key</span>(before.node), <span class="built_in">KeyOfValue</span>()(v))</span><br><span class="line">        &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(position.node)))</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">right</span>(before.node) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> __insert(<span class="number">0</span>, before.node, v); </span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">    <span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">insert_unique</span>(v).first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="允许重复插入-iterator-insert-equal-iterator-position-const-Val-amp-v"><a href="#允许重复插入-iterator-insert-equal-iterator-position-const-Val-amp-v" class="headerlink" title="允许重复插入 iterator insert_equal(iterator position, const Val&amp; v)"></a>允许重复插入 iterator insert_equal(iterator position, const Val&amp; v)</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Val</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::iterator </span><br><span class="line">rb_tree&lt;Key, Val, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">insert_equal</span>(iterator position,</span><br><span class="line">                                                            <span class="keyword">const</span> Val&amp; v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (position.node == header-&gt;left) <span class="comment">// begin()</span></span><br><span class="line">      <span class="comment">// 如果树不为空, 且小于最小值, 就插入到最小值的左儿子</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(position.node)))</span><br><span class="line">      <span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">  <span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">insert_equal</span>(v);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (position.node == header) <span class="comment">// end()</span></span><br><span class="line">      <span class="comment">// 如果当前值大于最大值就插入到最大值的右儿子上</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(<span class="built_in">rightmost</span>())))</span><br><span class="line">      <span class="keyword">return</span> __insert(<span class="number">0</span>, <span class="built_in">rightmost</span>(), v);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">insert_equal</span>(v);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iterator before = position;</span><br><span class="line">    --before;</span><br><span class="line">      <span class="comment">// 如果新插入的值介于要插入节点和要插入节点前驱中间</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">KeyOfValue</span>()(v), <span class="built_in">key</span>(before.node))</span><br><span class="line">        &amp;&amp; !<span class="built_in">key_compare</span>(<span class="built_in">key</span>(position.node), <span class="built_in">KeyOfValue</span>()(v)))</span><br><span class="line">        <span class="comment">// 如果前驱的右儿子节点为空 就插入到前驱的右儿子上</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">right</span>(before.node) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> __insert(<span class="number">0</span>, before.node, v); </span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="comment">// 否则插入到当前节点的左儿子上</span></span><br><span class="line">        <span class="keyword">return</span> __insert(position.node, position.node, v);</span><br><span class="line">    <span class="comment">// first argument just needs to be non-null </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">insert_equal</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="范围的可重复插入以及范围的不可重复插入"><a href="#范围的可重复插入以及范围的不可重复插入" class="headerlink" title="范围的可重复插入以及范围的不可重复插入"></a>范围的可重复插入以及范围的不可重复插入</h4><p>其本质就是重复调用 <code>insert_unique</code> 和 <code>insert_equal</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 范围插入(可以重复)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">KoV</span>, <span class="keyword">class</span> <span class="title">Cmp</span>, <span class="keyword">class</span> <span class="title">Al</span>&gt;</span> <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">II</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> rb_tree&lt;K, V, KoV, Cmp, Al&gt;::<span class="built_in">insert_equal</span>(II first, II last) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="built_in">insert_equal</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围插入(不可重复)</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">KoV</span>, <span class="keyword">class</span> <span class="title">Cmp</span>, <span class="keyword">class</span> <span class="title">Al</span>&gt;</span> <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">II</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> rb_tree&lt;K, V, KoV, Cmp, Al&gt;::<span class="built_in">insert_unique</span>(II first, II last) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="built_in">insert_unique</span>(*first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只列举了一部分重载方法</p><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><ul><li><p>首先定义了单节点删除的方法, 其内部调用了 <code>__rb_tree_rebalance_for_erase</code> 来实现单节点的删除以及解决红黑树在删除后出现的染色规则被打破的问题</p></li><li><p>重载了一个递归删除以 x 为根的子树的删除方法, 这个方法内部是没有调整方法的</p></li><li><p>区间删除方法则是重复调用<strong>单节点删除</strong>方法来实现多节点的删除</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">erase</span>(iterator position) &#123;</span><br><span class="line">  link_type y = (link_type) __rb_tree_rebalance_for_erase(position.node,</span><br><span class="line">                                                          header-&gt;parent,</span><br><span class="line">                                                          header-&gt;left,</span><br><span class="line">                                                          header-&gt;right);</span><br><span class="line">  <span class="built_in">destroy_node</span>(y);<span class="comment">// 释放空间</span></span><br><span class="line">  --node_count;<span class="comment">// 节点数--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__erase(link_type x) &#123;</span><br><span class="line">                                <span class="comment">// erase without rebalancing</span></span><br><span class="line">   <span class="comment">// 递归删除x指向的所有节点</span></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">    __erase(<span class="built_in">right</span>(x));</span><br><span class="line">    link_type y = <span class="built_in">left</span>(x);</span><br><span class="line">    <span class="built_in">destroy_node</span>(x);</span><br><span class="line">    x = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围删除节点</span></span><br><span class="line"><span class="comment">// 调用erase函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">erase</span>(iterator first, </span><br><span class="line">                                                            iterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first == <span class="built_in">begin</span>() &amp;&amp; last == <span class="built_in">end</span>())</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">while</span> (first != last) <span class="built_in">erase</span>(first++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">erase</span>(<span class="keyword">const</span> Key* first, </span><br><span class="line">                                                            <span class="keyword">const</span> Key* last) &#123;</span><br><span class="line">  <span class="keyword">while</span> (first != last) <span class="built_in">erase</span>(*first++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::size_type </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">erase</span>(<span class="keyword">const</span> Key&amp; x) &#123;</span><br><span class="line">  pair&lt;iterator,iterator&gt; p = <span class="built_in">equal_range</span>(x);</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 计算长度, erase进行删除</span></span><br><span class="line">  <span class="built_in">distance</span>(p.first, p.second, n);</span><br><span class="line">  <span class="built_in">erase</span>(p.first, p.second);</span><br><span class="line">  <span class="keyword">return</span> n;<span class="comment">// 返回删除的个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将以 x 为根的树复制 并将其根的父节点指向 p</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">K</span>, <span class="keyword">class</span> <span class="title">V</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;K, V, KeyOfValue, Compare, Alloc&gt;::link_type </span><br><span class="line">rb_tree&lt;K, V, KeyOfValue, Compare, Alloc&gt;::__copy(link_type x, link_type p) &#123;</span><br><span class="line">                                <span class="comment">// structural copy.  x and p must be non-null.</span></span><br><span class="line">  <span class="comment">//复制当前子树的根节点为 top</span></span><br><span class="line">  link_type top = <span class="built_in">clone_node</span>(x);</span><br><span class="line">  <span class="comment">// 将 top 的父节点指向 p  </span></span><br><span class="line">  top-&gt;parent = p;</span><br><span class="line"> </span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="comment">// x 的右子树存在, 就继续递归将 x 的右子树复制并将父节点指向 top</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right)</span><br><span class="line">      top-&gt;right = __copy(<span class="built_in">right</span>(x), top);</span><br><span class="line">    p = top;</span><br><span class="line">    <span class="comment">// 令 x 指向其左儿子</span></span><br><span class="line">    x = <span class="built_in">left</span>(x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要 x 节点存在</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// y 为复制当前 x 的节点</span></span><br><span class="line">      link_type y = <span class="built_in">clone_node</span>(x);</span><br><span class="line">      <span class="comment">// p 的左儿子指向 y, y 的父节点指向 p</span></span><br><span class="line">      p-&gt;left = y;</span><br><span class="line">      y-&gt;parent = p;</span><br><span class="line">      <span class="comment">// x的右儿子存在</span></span><br><span class="line">      <span class="keyword">if</span> (x-&gt;right)</span><br><span class="line">        <span class="comment">// 递归复制右儿子</span></span><br><span class="line">        y-&gt;right = __copy(<span class="built_in">right</span>(x), y);</span><br><span class="line">      p = y;</span><br><span class="line">      x = <span class="built_in">left</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果有节点分配失败就将所有的空间进行释放</span></span><br><span class="line">  __STL_UNWIND(__erase(top));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回复制的当前子树的根节点</span></span><br><span class="line">  <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find-查询方法"><a href="#find-查询方法" class="headerlink" title="find 查询方法"></a>find 查询方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">find</span>(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header;        <span class="comment">// Last node which is not less than k. </span></span><br><span class="line">  link_type x = <span class="built_in">root</span>();        <span class="comment">// Current node. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 像二叉树一样通过节点比较</span></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line">      y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      x = <span class="built_in">right</span>(x);</span><br><span class="line"></span><br><span class="line">  iterator j = <span class="built_in">iterator</span>(y);   </span><br><span class="line">  <span class="keyword">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::const_iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">find</span>(<span class="keyword">const</span> Key&amp; k) <span class="keyword">const</span> &#123;</span><br><span class="line">  link_type y = header; <span class="comment">/* Last node which is not less than k. */</span></span><br><span class="line">  link_type x = <span class="built_in">root</span>(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k))</span><br><span class="line">      y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      x = <span class="built_in">right</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  const_iterator j = <span class="built_in">const_iterator</span>(y);   </span><br><span class="line">  <span class="keyword">return</span> (j == <span class="built_in">end</span>() || <span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(j.node))) ? <span class="built_in">end</span>() : j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="count-方法-计算-RB-tree-中-k-出现的次数"><a href="#count-方法-计算-RB-tree-中-k-出现的次数" class="headerlink" title="count  方法, 计算 RB-tree 中 k 出现的次数"></a>count  方法, 计算 RB-tree 中 k 出现的次数</h3><ul><li>首先其调用了 <code>lower_bound()</code>,  <code>upper_bound()</code> 方法找到树中 k 中不小于 k 的第一个数字, 以及大于 k 的第一个数字</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不小于k的最后一个节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">lower_bound</span>(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header; <span class="comment">/* Last node which is not less than k. */</span></span><br><span class="line">  link_type x = <span class="built_in">root</span>(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果当前根节点大于 k 说明 k 的前驱存在于 x 的左子树, 于是去 x 的左子树找</span></span><br><span class="line">  <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), k)) <span class="comment">//(x &gt;= k)</span></span><br><span class="line">      y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">//(x &lt; k)</span></span><br><span class="line">        <span class="comment">// 若根节点 x 小于 k 说明 k 的前驱要么是 x, 要么是位于 x 的右子树中</span></span><br><span class="line">      x = <span class="built_in">right</span>(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">iterator</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于k的最后一个节点 道理同上</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::iterator </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">upper_bound</span>(<span class="keyword">const</span> Key&amp; k) &#123;</span><br><span class="line">  link_type y = header; <span class="comment">/* Last node which is greater than k. */</span></span><br><span class="line">  link_type x = <span class="built_in">root</span>(); <span class="comment">/* Current node. */</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (x != <span class="number">0</span>) </span><br><span class="line">       <span class="comment">// (k &lt; x) 说明大于 k 的最小值要么是 x 要么在 x 的左子树上</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">key_compare</span>(k, <span class="built_in">key</span>(x)))</span><br><span class="line">       y = x, x = <span class="built_in">left</span>(x);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         <span class="comment">// (k &gt;= x) 说明大于 k 的最小值一定在 x 的右子树上</span></span><br><span class="line">       x = <span class="built_in">right</span>(x);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">iterator</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>利用 <code>distance()</code> 函数求出<strong>不小于 k 的第一个数字</strong>和<strong>大于 k 的第一个数字</strong>的距离, 它们的间距就为 k 在树中出现的次数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算RB-tree中k出现的次数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::size_type </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::<span class="built_in">count</span>(<span class="keyword">const</span> Key&amp; k) <span class="keyword">const</span> &#123;</span><br><span class="line">  pair&lt;const_iterator, const_iterator&gt; p = <span class="built_in">equal_range</span>(k);</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(p.first, p.second, n);</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算当前节点到树根的链上的黑色节点数量"><a href="#计算当前节点到树根的链上的黑色节点数量" class="headerlink" title="计算当前节点到树根的链上的黑色节点数量"></a>计算当前节点到树根的链上的黑色节点数量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算红黑树有多少个黑节点</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> __black_count(__rb_tree_node_base* node, __rb_tree_node_base* root)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (node == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> bc = node-&gt;color == __rb_tree_black ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (node == root)</span><br><span class="line">      <span class="keyword">return</span> bc;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> bc + __black_count(node-&gt;parent, root);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查是否符合-RB-tree"><a href="#检查是否符合-RB-tree" class="headerlink" title="检查是否符合 RB-tree"></a>检查是否符合 RB-tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查是否符合rb-tree</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Key</span>, <span class="keyword">class</span> <span class="title">Value</span>, <span class="keyword">class</span> <span class="title">KeyOfValue</span>, <span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> </span><br><span class="line">rb_tree&lt;Key, Value, KeyOfValue, Compare, Alloc&gt;::__rb_verify() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 空树</span></span><br><span class="line">  <span class="keyword">if</span> (node_count == <span class="number">0</span> || <span class="built_in">begin</span>() == <span class="built_in">end</span>())</span><br><span class="line">    <span class="keyword">return</span> node_count == <span class="number">0</span> &amp;&amp; <span class="built_in">begin</span>() == <span class="built_in">end</span>() &amp;&amp;</span><br><span class="line">      header-&gt;left == header &amp;&amp; header-&gt;right == header;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最左节点到根节点的黑色节点数量为 len</span></span><br><span class="line">  <span class="keyword">int</span> len = __black_count(<span class="built_in">leftmost</span>(), <span class="built_in">root</span>());</span><br><span class="line">    <span class="comment">// 遍历每个节点</span></span><br><span class="line">  <span class="keyword">for</span> (const_iterator it = <span class="built_in">begin</span>(); it != <span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    link_type x = (link_type) it.node;</span><br><span class="line">    link_type L = <span class="built_in">left</span>(x);</span><br><span class="line">    link_type R = <span class="built_in">right</span>(x);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 节点是红色如果子节点也是红色就不满足</span></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;color == __rb_tree_red)</span><br><span class="line">      <span class="keyword">if</span> ((L &amp;&amp; L-&gt;color == __rb_tree_red) ||</span><br><span class="line">          (R &amp;&amp; R-&gt;color == __rb_tree_red))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (L &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">key</span>(x), <span class="built_in">key</span>(L)))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (R &amp;&amp; <span class="built_in">key_compare</span>(<span class="built_in">key</span>(R), <span class="built_in">key</span>(x)))</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!L &amp;&amp; !R &amp;&amp; __black_count(x, <span class="built_in">root</span>()) != len)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">leftmost</span>() != __rb_tree_node_base::<span class="built_in">minimum</span>(<span class="built_in">root</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">rightmost</span>() != __rb_tree_node_base::<span class="built_in">maximum</span>(<span class="built_in">root</span>()))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>本文粗略的分析了 <code>RB-tree</code> 的结构以及主要功能的实现, 其中 <strong>RB-tree</strong> 的主要掌握<strong>插入删除</strong>, 并且由于插入删除对红黑树带来的影响导致破坏了原红黑树的性质, 就要进行<strong>旋转</strong>和<strong>颜色调整</strong>, 其中的插入方法有可重复插入以及不可重复插入这些方法都会在后续对 <strong>set</strong>, <strong>map</strong> 等一些非关联容器中得到使用, </p>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/acm/ACM/"/>
      <url>/acm/ACM/</url>
      
        <content type="html"><![CDATA[<p>占位文章 请忽略</p>]]></content>
      
      
      <categories>
          
          <category> acm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/%E7%94%9F%E6%B4%BB/%E7%94%9F%E6%B4%BB/"/>
      <url>/%E7%94%9F%E6%B4%BB/%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p>这就是生活</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>List 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/List/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/List/</url>
      
        <content type="html"><![CDATA[<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p>之前分析了 <code>vector</code> 的实现, 可以发现<code>vector</code> 的缺点在于处理高频率的插入与删除时的效率很低, 由于其是采用整体移动的方式处理插入与删除, 时间复杂度最坏是 <code>O(n)</code> , 而 <code>list</code> 则在删除与插入上有着优秀的效率</p><p><code>list</code> 是使用链表实现的, 其对于删除和插入的时间复杂度为 <code>O(1)</code>,  有着极其优秀的效率, 但是在于随机访问方面时间复杂度则为 <code>O(n)</code> , <code>list</code> 将具体实现分为了几个部分, 并通过嵌套的方式进行调用, 所以<code>list</code> 的实现也很灵活. 同时, <strong><code>list</code> 在插入和删除后迭代器不会失效</strong></p><h3 id="list-基本结构框架"><a href="#list-基本结构框架" class="headerlink" title="list 基本结构框架"></a>list 基本结构框架</h3><p><code>list</code> 将基本的框架分为 <code>__list_node</code> (链表节点),  <code>__list_iterator</code> (访问迭代器)</p><h3 id="list-node-链表结构"><a href="#list-node-链表结构" class="headerlink" title="__list_node 链表结构"></a>__list_node 链表结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_node</span> &#123;</span></span><br><span class="line">  <span class="comment">//前后指针</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  void_pointer next;</span><br><span class="line">  void_pointer prev;</span><br><span class="line">  <span class="comment">//节点数据</span></span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="list-iterator-结构"><a href="#list-iterator-结构" class="headerlink" title="__list_iterator 结构"></a>__list_iterator 结构</h3><h4 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  <span class="comment">//定义迭代器类型</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator; </span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, Ref, Ptr&gt;           self;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义迭代器为 bidirectional_iterator_tag 类型</span></span><br><span class="line">  <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部使用一个 __list_node&lt;T&gt;* 作为记录 list 中的某个节点信息</span></span><br><span class="line">    <span class="keyword">typedef</span> __list_node&lt;T&gt;* link_type;</span><br><span class="line">    link_type node;</span><br><span class="line">    </span><br><span class="line">__list_iterator(link_type x) : <span class="built_in">node</span>(x) &#123;&#125;</span><br><span class="line">__list_iterator() &#123;&#125;</span><br><span class="line">__list_iterator(<span class="keyword">const</span> iterator&amp; x) : <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">list_iterator</span> &#123;</span></span><br><span class="line">  ....  </span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == x.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != x.node; &#125;</span><br><span class="line">  <span class="comment">//对 * 运算符重载, 模拟指针的取值</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> (*node).data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  <span class="comment">//对 -&gt; 运算符进行重载</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//该迭代器是一个双向迭代器, 支持++, -- 运算符, 又 list 底层实现是由</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123; </span><br><span class="line">    node = (link_type)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123; </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123; </span><br><span class="line">    node = (link_type)((*node).prev);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123; </span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="traits-编程"><a href="#traits-编程" class="headerlink" title="traits 编程"></a>traits 编程</h4><p><code>list</code> 的 <code>iterator </code> 自己实现了 <code>traits</code> 编程, 其迭代器是<code>bidirectional_iterator_tag</code>类型, 并不是一个普通指针. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回 list 迭代器的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> bidirectional_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> __list_iterator&lt;T, Ref, Ptr&gt;&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">bidirectional_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 list 迭代器中的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T*</span></span><br><span class="line"><span class="function"><span class="title">value_type</span><span class="params">(<span class="keyword">const</span> __list_iterator&lt;T, Ref, Ptr&gt;&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">ptrdiff_t</span>*</span></span><br><span class="line"><span class="function"><span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> __list_iterator&lt;T, Ref, Ptr&gt;&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br></pre></td></tr></table></figure><h2 id="list-结构"><a href="#list-结构" class="headerlink" title="list 结构"></a>list 结构</h2><h3 id="list-基础类型定义"><a href="#list-基础类型定义" class="headerlink" title="list  基础类型定义"></a>list  基础类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">void</span>* void_pointer;</span><br><span class="line">  <span class="comment">//定义节点信息</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_node&lt;T&gt; list_node;</span><br><span class="line">  <span class="comment">//节点内存分配</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;list_node, Alloc&gt; list_node_allocator;</span><br><span class="line"><span class="keyword">public</span>:      </span><br><span class="line">  <span class="comment">// 定义嵌套类型</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> list_node* link_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//定义迭代器以及反向迭代器</span></span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __list_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;const_iterator, value_type,</span><br><span class="line">  const_reference, difference_type&gt;</span><br><span class="line">  const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_bidirectional_iterator&lt;iterator, value_type, reference,</span><br><span class="line">  difference_type&gt;</span><br><span class="line">  reverse_iterator; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">    ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="list-构造和析构函数的实现"><a href="#list-构造和析构函数的实现" class="headerlink" title="list 构造和析构函数的实现"></a>list 构造和析构函数的实现</h3><h4 id="构造函数依赖的方法"><a href="#构造函数依赖的方法" class="headerlink" title="构造函数依赖的方法"></a>构造函数依赖的方法</h4><ol><li><code>get_node</code> 分配节点空间</li><li><code>put_node</code> 释放节点空间</li><li><code>create_node</code> 分配并创建节点空间</li><li><code>destroy_node</code> 调用节点内部数据析构函数并释放该节点空间</li><li><code>empty_initialize</code> 对 <code>list</code> 头节点进行初始化</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    .....</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">link_type <span class="title">get_node</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list_node_allocator::<span class="built_in">allocate</span>(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put_node</span><span class="params">(link_type p)</span> </span>&#123; list_node_allocator::<span class="built_in">deallocate</span>(p); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">link_type <span class="title">create_node</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    link_type p = <span class="built_in">get_node</span>();</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">construct</span>(&amp;p-&gt;data, x);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">put_node</span>(p));</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy_node</span><span class="params">(link_type p)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">destroy</span>(&amp;p-&gt;data);</span><br><span class="line">    <span class="built_in">put_node</span>(p);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">empty_initialize</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    node = <span class="built_in">get_node</span>();</span><br><span class="line">    node-&gt;next = node;</span><br><span class="line">    node-&gt;prev = node;</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>list</code> 构造函数从上到下依次为:</p><ol><li><p>空构造函数</p></li><li><p>创建一个长度为 <code>n</code>, 值为 <code>value</code> 的链表</p></li><li><p>4 为 2 的<strong>重载版本</strong></p></li><li><p> 如果允许拥有成员模板, 则提供接收其他 <code>InputIterator</code> 迭代器的类型的数据范围并将该范围内数据创建 <code>list</code></p></li><li><p>反之根据提供的两个 <code>list</code> 迭代器来创建这两个迭代器范围内数据的 <code>list</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    .....</span><br><span class="line">  <span class="built_in">list</span>() &#123; <span class="built_in">empty_initialize</span>(); &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">list</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">list</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">list</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="built_in">list</span>(InputIterator first, InputIterator last) &#123;</span><br><span class="line">    <span class="built_in">range_initialize</span>(first, last);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="built_in">list</span>(<span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last) &#123; <span class="built_in">range_initialize</span>(first, last); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">list</span>(const_iterator first, const_iterator last) &#123;</span><br><span class="line">    <span class="built_in">range_initialize</span>(first, last);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="built_in">list</span>(<span class="keyword">const</span> list&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">    <span class="built_in">range_initialize</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ....</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于前四个版本的构造函数都调用了 <code>fill_initialize</code> 方法, 可以看出其本质是先创建头节点, 然后对元素进行 <code>insert</code>  操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">empty_initialize</span>();</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="built_in">insert</span>(<span class="built_in">begin</span>(), n, value);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(<span class="built_in">clear</span>(); <span class="built_in">put_node</span>(node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>删除头节点以外所有节点, 再删除空节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">list</span>() &#123;</span><br><span class="line">    <span class="comment">// 删除初空节点以外的所有节点</span></span><br><span class="line">  <span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 删除空节点</span></span><br><span class="line">  <span class="built_in">put_node</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本属性获取"><a href="#基本属性获取" class="headerlink" title="基本属性获取"></a>基本属性获取</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (link_type)((*node).next); &#125; <span class="comment">// 获取 list 中第一个元素的迭代器, 没有则返回头节点 (end)</span></span><br><span class="line"><span class="comment">//同上 只不过返回的是 常量迭代器</span></span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (link_type)((*node).next); &#125;</span><br><span class="line"><span class="comment">//返回头节点, 也即尾部 end</span></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> node; &#125;</span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node; &#125;</span><br><span class="line"><span class="comment">//返回反向迭代器</span></span><br><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>());</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//如果 begin == end 那么就为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> node-&gt;next == node; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    size_type result = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最大值就是 unsigned long long 因为指针最多可以记录到 unsigned long long 个数量的地址</span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line"><span class="comment">//返回第一个元素引用</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"><span class="comment">//返回最后一个元素引用</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *(--<span class="built_in">end</span>()); &#125;</span><br></pre></td></tr></table></figure><h3 id="交换函数"><a href="#交换函数" class="headerlink" title="交换函数"></a>交换函数</h3><p>可以看出, 交换两个链表并不是全部交换两个链表内元素, 而是交换头指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(list&lt;T, Alloc&gt;&amp; x)</span> </span>&#123; __STD::<span class="built_in">swap</span>(node, x.node); &#125;</span><br></pre></td></tr></table></figure><h2 id="list-操作"><a href="#list-操作" class="headerlink" title="list 操作"></a>list 操作</h2><p>这里主要介绍 <code>list </code> 的 <code>pop, push</code> 以及一些插入删除等基本操作</p><h3 id="push-和-pop-操作"><a href="#push-和-pop-操作" class="headerlink" title="push 和 pop 操作"></a>push 和 pop 操作</h3><p><code>list</code> 是一个双向链表, 所以对于 <code>push</code> 操作是在头部插入, 而 <code>pop</code> 则是在尾部插入, <code>push</code> 操作都调用了 <code>insert</code> 方法,  <code>pop</code> 操作都调用了 <code>erase</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T, class Alloc = alloc&gt;</span><br><span class="line">class list </span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    // 直接在头部或尾部插入</span><br><span class="line">    void push_front(const T&amp; x) &#123; insert(begin(), x); &#125;</span><br><span class="line">    void push_back(const T&amp; x) &#123; insert(end(), x); &#125;</span><br><span class="line">    // 直接在头部或尾部删除</span><br><span class="line">    void pop_front() &#123; erase(begin()); &#125;</span><br><span class="line">    void pop_back() &#123; </span><br><span class="line">      iterator tmp = end();</span><br><span class="line">      erase(--tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除元素的操作基本都是通过调用 <code>单节点的 erase</code> 方法来实现的, 由于 <code>list</code>  是一个双向链表, 所以 <code>单节点的 erase</code> 方法的操作就是双向链表的操作, 示例如下</p><p><a href="https://imgtu.com/i/H4aT2t"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/17/H4aT2t.png" alt="H4aT2t.png"></a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;   </span><br><span class="line">   </span><br><span class="line">    <span class="comment">//更改节点前驱后继的指针指向, 再释放要删除节点即可 </span></span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">      link_type next_node = <span class="built_in">link_type</span>(position.node-&gt;next);</span><br><span class="line">      link_type prev_node = <span class="built_in">link_type</span>(position.node-&gt;prev);</span><br><span class="line">      prev_node-&gt;next = next_node;</span><br><span class="line">      next_node-&gt;prev = prev_node;</span><br><span class="line">      <span class="built_in">destroy_node</span>(position.node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">iterator</span>(next_node);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 erase 重载删除两个迭代器之间的元素</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">list&lt;T,Alloc&gt;::iterator list&lt;T, Alloc&gt;::<span class="built_in">erase</span>(iterator first, iterator last) </span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//对于范围内的每一个元素都调用删除单节点的 erase 方法</span></span><br><span class="line">  <span class="keyword">while</span> (first != last) </span><br><span class="line">        <span class="built_in">erase</span>(first++);</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用 删除范围内元素的 erase 来清除特定值节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">  iterator first = <span class="built_in">begin</span>();</span><br><span class="line">  iterator last = <span class="built_in">end</span>();</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    iterator next = first;</span><br><span class="line">    ++next;</span><br><span class="line">    <span class="keyword">if</span> (*first == value) <span class="built_in">erase</span>(first);</span><br><span class="line">    first = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>clear</code> 方法为先删除头节点以外所有元素, 只留下头节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除除空节点以外的所有节点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> </span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">clear</span>()</span><br><span class="line">&#123;</span><br><span class="line">  link_type cur = (link_type) node-&gt;next;</span><br><span class="line">    <span class="comment">// 除空节点都删除</span></span><br><span class="line">  <span class="keyword">while</span> (cur != node) &#123;</span><br><span class="line">    link_type tmp = cur;</span><br><span class="line">    cur = (link_type) cur-&gt;next;</span><br><span class="line">    <span class="built_in">destroy_node</span>(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  node-&gt;next = node;</span><br><span class="line">  node-&gt;prev = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断两个list相等</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> list&lt;T,Alloc&gt;&amp; x, <span class="keyword">const</span> list&lt;T,Alloc&gt;&amp; y) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> list&lt;T,Alloc&gt;::link_type link_type;</span><br><span class="line">  link_type e1 = x.node;</span><br><span class="line">  link_type e2 = y.node;</span><br><span class="line">  link_type n1 = (link_type) e1-&gt;next;</span><br><span class="line">  link_type n2 = (link_type) e2-&gt;next;</span><br><span class="line">    <span class="comment">// 将两个链表执行一一的对比来分析是否相等. </span></span><br><span class="line">    <span class="comment">// 这里不把元素个数进行一次比较, 主要获取个数时也要遍历整个数组, 所以就不将个数纳入比较</span></span><br><span class="line">  <span class="keyword">for</span> ( ; n1 != e1 &amp;&amp; n2 != e2 ; n1 = (link_type) n1-&gt;next, n2 = (link_type) n2-&gt;next)</span><br><span class="line">    <span class="keyword">if</span> (n1-&gt;data != n2-&gt;data)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> n1 == e1 &amp;&amp; n2 == e2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="小于比较"><a href="#小于比较" class="headerlink" title="小于比较"></a>小于比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> list&lt;T, Alloc&gt;&amp; x, <span class="keyword">const</span> list&lt;T, Alloc&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赋值操作"><a href="#赋值操作" class="headerlink" title="赋值操作"></a>赋值操作</h4><p><code>list</code> 在赋值时要考虑两个链表的大小关系</p><ol><li>原链表大, 就删除多余元素</li><li>原链表小, 在复制完本身容量后再将剩余元素以插入的形式加入原链表</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">list&lt;T, Alloc&gt;&amp; list&lt;T, Alloc&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> list&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;x) &#123;</span><br><span class="line">    iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">    iterator last1 = <span class="built_in">end</span>();</span><br><span class="line">    const_iterator first2 = x.<span class="built_in">begin</span>();</span><br><span class="line">    const_iterator last2 = x.<span class="built_in">end</span>();</span><br><span class="line">    <span class="comment">//直到两个链表有一个空间用尽</span></span><br><span class="line">    <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2) </span><br><span class="line">    *first1++ = *first2++;</span><br><span class="line">    <span class="comment">//原链表大, 复制完后要删除掉原链表多余的元素</span></span><br><span class="line">    <span class="keyword">if</span> (first2 == last2)</span><br><span class="line">      <span class="built_in">erase</span>(first1, last1);</span><br><span class="line">    <span class="comment">// 原链表小, 复制完后要还要将x链表的剩余元素以插入的方式插入到原链表中</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert</span>(last1, first2, last2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize-操作"><a href="#resize-操作" class="headerlink" title="resize 操作"></a>resize 操作</h3><p>重新修改 <code>list</code> 大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">resize</span>(size_type new_size, <span class="keyword">const</span> T&amp; x);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; <span class="built_in">resize</span>(new_size, <span class="built_in">T</span>()); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">resize</span>(size_type new_size, <span class="keyword">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">  iterator i = <span class="built_in">begin</span>();</span><br><span class="line">  size_type len = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; i != <span class="built_in">end</span>() &amp;&amp; len &lt; new_size; ++i, ++len)</span><br><span class="line">    ;</span><br><span class="line">  <span class="comment">// 如果链表长度大于new_size的大小, 那就删除后面多余的节点</span></span><br><span class="line">  <span class="keyword">if</span> (len == new_size)</span><br><span class="line">    <span class="built_in">erase</span>(i, <span class="built_in">end</span>());</span><br><span class="line">  <span class="keyword">else</span>              </span><br><span class="line">     <span class="comment">//用 x 补充多出的元素</span></span><br><span class="line">    <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - len, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unique-操作"><a href="#unique-操作" class="headerlink" title="unique 操作"></a>unique 操作</h3><p><code>unique</code> 方法是将 <code>list</code> 内连续且重复的节点删除至只剩一个, 注意: <code>unique</code> 并不是将整个 <code>list</code> 进行去重, 而是相同的连续元素,    如果要对整个 <code>list</code> 进行去重, 就要先对 <code>list</code> 进行一个排序, 所以对于 <code>unique</code> 方法, 通常与 <code>sort</code> 方法一起使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">unique</span>() &#123;</span><br><span class="line">  iterator first = <span class="built_in">begin</span>();</span><br><span class="line">  iterator last = <span class="built_in">end</span>();</span><br><span class="line">  <span class="keyword">if</span> (first == last) <span class="keyword">return</span>;</span><br><span class="line">  iterator next = first;</span><br><span class="line">  <span class="keyword">while</span> (++next != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first == *next)</span><br><span class="line">      <span class="built_in">erase</span>(next);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      first = next;</span><br><span class="line">    next = first;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insert-操作"><a href="#insert-操作" class="headerlink" title="insert 操作"></a>insert 操作</h3><p><code>list</code> 提供了多种重载方式的 <code>insert</code> 方法, 但是最核心的还是调用 <code> iterator insert(iterator position, const T&amp; x)</code> 方法, 所有的重载 <code>insert</code> 方法都是基于该方法实现的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 最基本的insert操作, 之插入一个元素</span></span><br><span class="line">    <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将元素插入指定位置的前一个地址</span></span><br><span class="line">      link_type tmp = <span class="built_in">create_node</span>(x);</span><br><span class="line">      tmp-&gt;next = position.node;</span><br><span class="line">      tmp-&gt;prev = position.node-&gt;prev;</span><br><span class="line">      (<span class="built_in">link_type</span>(position.node-&gt;prev))-&gt;next = tmp;</span><br><span class="line">      position.node-&gt;prev = tmp;</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 以下重载函数都是调用iterator insert(iterator position, const T&amp; x)函数</span></span><br><span class="line">   <span class="function">iterator <span class="title">insert</span><span class="params">(iterator position)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">insert</span>(position, <span class="built_in">T</span>()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator position, InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator position,</span></span></span><br><span class="line"><span class="params"><span class="function">        const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, size_type n, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">insert</span>(pos, (size_type)n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">insert</span>(pos, (size_type)n, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> T&amp; x)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, InputIterator first, InputIterator last) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="built_in">insert</span>(position, *first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, <span class="keyword">const</span> T* first, <span class="keyword">const</span> T* last) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="built_in">insert</span>(position, *first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position,</span><br><span class="line">    const_iterator first, const_iterator last) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="built_in">insert</span>(position, *first);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; n &gt; <span class="number">0</span>; --n)</span><br><span class="line">    <span class="built_in">insert</span>(position, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>插入操作是将元素插入到指定位置的前一个位置</p><h3 id="sort-操作"><a href="#sort-操作" class="headerlink" title="sort 操作"></a>sort 操作</h3><p>由于链表的元素空间地址并不是连续的, 所以对于 <code>list</code> 的 sort 操作需要单独实现, 由于该 sort 的实现过于复杂, 我不太能良好的用语言去分析所以引用了别的大佬的文章</p><p>以下部分引用自 <a href="https://github.com/Cu1ii/STL/blob/master/16%20list%20%E4%B8%8B.md">传送门</a></p><p>在分析<code>sort</code>之前先来分析<code>transfer</code>, <code>reverse</code>, <code>merge</code>这几个会被调用的函数.</p><h4 id="transfer函数"><a href="#transfer函数" class="headerlink" title="transfer函数"></a>transfer函数</h4><p><strong><code>transfer</code>函数功能是将一段链表插入到我们指定的位置之前</strong>. 该函数一定要理解, 后面分析的所有函数都是该基础上进行修改的.</p><p><code>transfer</code>函数接受3个迭代器. 第一个迭代器表示链表要插入的位置, <code>first</code>到<code>last</code>最闭右开区间插入到<code>position</code>之前.</p><p>从<code>if</code>下面开始分析(<em>这里我将源码的执行的先后顺序进行的部分调整, 下面我分析的都是调整顺序过后的代码. 当然我也会把源码顺序写下来, 以便参考</em>)</p><ul><li><strong>为了避免待会解释起来太绕口, 这里先统一一下部分名字</strong></li></ul><ol><li><code>last</code>的前一个节点叫<code>last_but_one</code></li><li><code>first</code>的前一个节点叫<code>zero</code></li></ol><ul><li>好, 现在我们开始分析<code>transfer</code>的每一步(<em>最好在分析的时候在纸上画出两个链表一步步来画</em>)</li></ul><ol><li>第一行. <code>last_but_one</code>的<code>next</code>指向插入的<code>position</code>节点</li><li>第二行. <code>position</code>的<code>next</code>指向<code>last_but_one</code></li><li>第三行. 临时变量<code>tmp</code>保存<code>position</code>的前一个节点</li><li>第四行. <code>first</code>的<code>prev</code>指向<code>tmp</code></li><li>第五行. <code>position</code>的前一个节点的<code>next</code>指向<code>first</code>节点</li><li>第六行. <code>zero</code>的<code>next</code>指向<code>last</code>节点</li><li>第七行. <code>last</code>的<code>prev</code>指向<code>zero</code></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(iterator position, iterator first, iterator last)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (position != last) </span><br><span class="line">      &#123;</span><br><span class="line">          (*(<span class="built_in">link_type</span>((*last.node).prev))).next = position.node;</span><br><span class="line">          (*position.node).prev = (*last.node).prev;</span><br><span class="line">          link_type tmp = <span class="built_in">link_type</span>((*position.node).prev);</span><br><span class="line">          (*first.node).prev = tmp;</span><br><span class="line">          (*(<span class="built_in">link_type</span>((*position.node).prev))).next = first.node; </span><br><span class="line">          (*(<span class="built_in">link_type</span>((*first.node).prev))).next = last.node;</span><br><span class="line">          (*last.node).prev = (*first.node).prev; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    void transfer(iterator position, iterator first, iterator last) </span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">      if (position != last) </span></span><br><span class="line"><span class="comment">      &#123;</span></span><br><span class="line"><span class="comment">        (*(link_type((*last.node).prev))).next = position.node;</span></span><br><span class="line"><span class="comment">        (*(link_type((*first.node).prev))).next = last.node;</span></span><br><span class="line"><span class="comment">        (*(link_type((*position.node).prev))).next = first.node;  </span></span><br><span class="line"><span class="comment">        link_type tmp = link_type((*position.node).prev);</span></span><br><span class="line"><span class="comment">        (*position.node).prev = (*last.node).prev;</span></span><br><span class="line"><span class="comment">        (*last.node).prev = (*first.node).prev; </span></span><br><span class="line"><span class="comment">        (*first.node).prev = tmp;</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>splice</strong> 将两个链表进行合并.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp; x)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!x.<span class="built_in">empty</span>()) </span><br><span class="line">        <span class="built_in">transfer</span>(position, x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator i)</span> </span>&#123;</span><br><span class="line">      iterator j = i;</span><br><span class="line">      ++j;</span><br><span class="line">      <span class="keyword">if</span> (position == i || position == j) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">transfer</span>(position, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">splice</span><span class="params">(iterator position, list&amp;, iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (first != last) </span><br><span class="line">        <span class="built_in">transfer</span>(position, first, last);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="merge函数"><a href="#merge函数" class="headerlink" title="merge函数"></a>merge函数</h4><p><code>merge</code>函数接受一个<code>list</code>参数.</p><p><strong><code>merge</code>函数是将传入的<code>list</code>链表x与原链表按从小到大合并到原链表中(前提是两个链表都是已经从小到大排序了)</strong>. 这里<code>merge</code>的核心就是<code>transfer</code>函数.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">merge</span>(list&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">  iterator first1 = <span class="built_in">begin</span>();</span><br><span class="line">  iterator last1 = <span class="built_in">end</span>();</span><br><span class="line">  iterator first2 = x.<span class="built_in">begin</span>();</span><br><span class="line">  iterator last2 = x.<span class="built_in">end</span>();</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1 &amp;&amp; first2 != last2)</span><br><span class="line">    <span class="keyword">if</span> (*first2 &lt; *first1) &#123;</span><br><span class="line">      iterator next = first2;</span><br><span class="line">      <span class="comment">// 将first2到first+1的左闭右开区间插入到first1的前面</span></span><br><span class="line">      <span class="comment">// 这就是将first2合并到first1链表中</span></span><br><span class="line">      <span class="built_in">transfer</span>(first1, first2, ++next);</span><br><span class="line">      first2 = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ++first1;</span><br><span class="line">      <span class="comment">// 如果链表x还有元素则全部插入到first1链表的尾部</span></span><br><span class="line">  <span class="keyword">if</span> (first2 != last2) <span class="built_in">transfer</span>(last1, first2, last2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="reverse函数"><a href="#reverse函数" class="headerlink" title="reverse函数"></a>reverse函数</h4><p><strong><code>reverse</code>函数是实现将链表翻转的功能.</strong> 主要是<code>list</code>的迭代器基本不会改变的特点, 将每一个元素一个个插入到<code>begin</code>之前. 这里注意迭代器不会变, 但是<code>begin</code>会改变, 它始终指向第一个元素的地址.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T, Alloc&gt;::<span class="built_in">reverse</span>() </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (node-&gt;next == node || <span class="built_in">link_type</span>(node-&gt;next)-&gt;next == node) </span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  iterator first = <span class="built_in">begin</span>();</span><br><span class="line">  ++first;</span><br><span class="line">  <span class="keyword">while</span> (first != <span class="built_in">end</span>()) &#123;</span><br><span class="line">    iterator old = first;</span><br><span class="line">    ++first;</span><br><span class="line">      <span class="comment">// 将元素插入到begin()之前</span></span><br><span class="line">    <span class="built_in">transfer</span>(<span class="built_in">begin</span>(), old, first);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p><code>list</code>实现<code>sort</code> 功能本身就不容易, 当我分析了之后就对其表示佩服. 严格的说<code>list</code>排序的时间复杂度应为<code>nlog(n)</code>, 其实现用了归并排序的思想, 将所有元素分成n分, 总共2^n个元素.</p><p>这个sort的分析 :</p><ul><li>这里将每个重要的参数列出来解释其含义<ol><li><code>fill</code> : 当前可以处理的元素个数为2^fill个</li><li><code>counter[fill]</code> : 可以容纳2^(fill+1)个元素</li><li><code>carry</code> : 一个临时中转站, 每次将一元素插入到counter[i]链表中.</li></ol></li></ul><p>在处理的元素个数不足 2^fill 个时，在<code>counter[i](0&lt;i&lt;fill)</code>之前转移元素</p><p>具体是显示步骤是：</p><ol><li>每次读一个数据到 <code>carry</code>中，并将carry的数据转移到 <code>counter[0]</code> 中<ol><li>当<code>counter[0]</code>中的数据个数少于2时，持续转移数据到counter[0]中</li><li>当counter[0]的数据个数等于2时，将counter[0]中的数据转移到counter[1]…从counter[i]转移到counter[i+1],直到counter[fill]中数据个数达到2^(fill+1)个。</li></ol></li><li>++fill, 重复步骤1</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//list 不能使用sort函数，因为list的迭代器是bidirectional_iterator, 而sort</span></span><br><span class="line"><span class="comment">//sort函数要求random_access_iterator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>,<span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> list&lt;T,Alloc&gt;::<span class="built_in">sort</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果元素个数小于等于1，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;next==node||node-&gt;next-&gt;next==node)</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    list&lt;T,Alloc&gt; carry; <span class="comment">//中转站</span></span><br><span class="line">    list&lt;T,Alloc&gt; counter[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> fill=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        carry.<span class="built_in">splice</span>(carry.<span class="built_in">begin</span>(),*<span class="keyword">this</span>,<span class="built_in">begin</span>());  <span class="comment">//每次取出一个元素</span></span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;    </span><br><span class="line">        <span class="keyword">while</span>(i&lt;fill&amp;&amp;!counter[i].<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            counter[i].<span class="built_in">merge</span>(carry);  <span class="comment">//将carry中的元素合并到counter[i]中</span></span><br><span class="line">            carry.<span class="built_in">swap</span>(counter[i++]);  <span class="comment">//交换之后counter[i-1]为空</span></span><br><span class="line">        &#125;</span><br><span class="line">        carry.<span class="built_in">swap</span>(counter[i]);</span><br><span class="line">        <span class="keyword">if</span>(i==fill) </span><br><span class="line">            ++fill;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将counter数组链表的所有节点按从小到大的顺序排列存储在counter[fill-1]的链表中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;fill;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        counter[i].<span class="built_in">merge</span>(counter[i<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将couter与carry交换, 实现排序</span></span><br><span class="line">    <span class="built_in">swap</span>(counter[fill<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sort</code>用了一个数组链表用来存储2^i个元素, 当上一个元素存储满了之后继续往下一个链表存储, 最后将所有的链表进行<code>merge</code>归并(合并), 从而实现了链表的排序.</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>本节我们分析了<code>list</code>最难的<code>transfer</code>和<code>sort</code>实现, 当然<code>transfer</code>函数是整个实现的核心. 我在将本节分析的函数在进行一个归纳.</p><ol><li><code>transfer</code> : 将两个<em>段</em>链表进行合并(两段可以是来自同一个链表, 但不交叉).</li><li><code>merge</code> : 前提两个段链表都已经排好序. 将两段链表按从小到大的顺序进行合并, 主要是<code>sort</code>实现调用.</li><li><code>reverse</code> : 调用<code>transfer</code>函数将元素一个个调整到<code>begin</code>之前, 实现链表的转置.</li><li><code>sort</code> : 运用归并思想将链表分段排序.</li></ol>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deque 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/deque-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/deque-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="deque-源码分析"><a href="#deque-源码分析" class="headerlink" title="deque 源码分析"></a>deque 源码分析</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h2><p><code>deque</code> 所提供的功能相较于其他顺序容器, 拥有较为强大的功能, 在实现上相对于 <code>list</code> , <code>vector</code> 更复杂, <code>deque</code>  的迭代器是属于 <code>random_access_iterator_tag</code> 类型,  在分析 <code>vector</code> 时, 可以发现, 在某些极端情况下, 由于 <code>vector</code> 采用连续的空间储存元素, 会出现头插入以及扩容时进行大量元素的复制, 导致复杂度很高, 且对于空间的要求也是相对较高的. <code>deque</code> 则是 <strong>相对连续的</strong> 即它将多个数组按照顺序排序, 这样即使每个数组的头地址并不是连续的, 但是并不影响元素是<strong>连续</strong>的, 这里的连续指的是逻辑上是连续, 而不是地址连续, <code>deque</code> 是一个双向开口的容器, 头尾插入和删除都是 O(1) 复杂度的, 空间也是可扩展的, 且扩展时不经常对已有的元素进行移动. </p><h2 id="deque-iterator迭代器结构"><a href="#deque-iterator迭代器结构" class="headerlink" title="__deque_iterator迭代器结构"></a>__deque_iterator迭代器结构</h2><p><code>deque</code> 的 <code>iterator</code> 和 <code>vector</code> 类似, 但是由于其结构为<strong>相对连续</strong>所以对于 <code>iterator</code> 的设计要比 <code>vector</code> 的 <code>iterator</code> 更为复杂</p><h3 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h3><p>用来计算每一个数组的大小</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">size_t</span> __deque_buf_size(<span class="keyword">size_t</span> n, <span class="keyword">size_t</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> ? n : (sz &lt; <span class="number">512</span> ? <span class="built_in">size_t</span>(<span class="number">512</span> / sz) : <span class="built_in">size_t</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><p><code>deque</code> 的 <code>iterator</code> 是 <code>random_access_iterator_tag</code> 类型, 满足 <code>traits</code> 编程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"><span class="comment">// 迭代器定义</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*, BufSiz&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in"><span class="keyword">sizeof</span></span>(T)); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_NON_TYPE_TMPL_PARAM_BUG */</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*&gt;             iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt; const_iterator;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> __deque_buf_size(<span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(T)); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">// deque是random_access_iterator_tag类型</span></span><br><span class="line">  <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">  <span class="comment">// 基本类型的定义, 满足traits编程</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> Ptr pointer;</span><br><span class="line">  <span class="keyword">typedef</span> Ref reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line">  <span class="comment">// node</span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">  map_pointer node;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator self;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>满足 <code>traits</code> 编程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 满足traits编程</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> random_access_iterator_tag</span></span><br><span class="line"><span class="function"><span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> __deque_iterator&lt;T, Ref, Ptr, BufSiz&gt;&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">random_access_iterator_tag</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> T* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> __deque_iterator&lt;T, Ref, Ptr, BufSiz&gt;&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">ptrdiff_t</span>* <span class="title">distance_type</span><span class="params">(<span class="keyword">const</span> __deque_iterator&lt;T, Ref, Ptr, BufSiz&gt;&amp;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文提到, 由于 <code>deque</code> 的连续性是使用数组进行拼接的, 所以需要一个<strong>指向指针的指针</strong>来记录每块数组的地址, 所以 <code>iterator</code> 就需要一个<strong>指向指针的指针</strong>来保证 <code>iterator</code> 在跨域数组的时候找到下(上)一顺序的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// node</span></span><br><span class="line">  <span class="keyword">typedef</span> T** map_pointer;</span><br><span class="line">  map_pointer node;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 同时还 <code>iterator</code> 中还设置了三个 <code>T*</code>指针 <code>cur</code>, <code>first</code>, <code>last</code> </p><ul><li>cur: 当前指向的位置</li><li>first: 该数组中头的位置</li><li>last: 该数组中尾的位置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  T* cur;</span><br><span class="line">  T* first;</span><br><span class="line">  T* last;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 初始化cur指向当前数组位置, last指针数组的尾, node指向y</span></span><br><span class="line">  __deque_iterator(T* x, map_pointer y)  : <span class="built_in">cur</span>(x), <span class="built_in">first</span>(*y), <span class="built_in">last</span>(*y + <span class="built_in">buffer_size</span>()), <span class="built_in">node</span>(y) &#123;&#125;</span><br><span class="line">  <span class="comment">// 初始化为一个空的deque</span></span><br><span class="line">  __deque_iterator() : <span class="built_in">cur</span>(<span class="number">0</span>), <span class="built_in">first</span>(<span class="number">0</span>), <span class="built_in">last</span>(<span class="number">0</span>), <span class="built_in">node</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 接受一个迭代器</span></span><br><span class="line">  __deque_iterator(<span class="keyword">const</span> iterator&amp; x) : <span class="built_in">cur</span>(x.cur), <span class="built_in">first</span>(x.first), <span class="built_in">last</span>(x.last), <span class="built_in">node</span>(x.node) &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h3><p><code>__deque_iterator</code> 实现了基本运算符 在分析 <code>__deque_iterator</code> 的运算符之前先介绍一个基础函数 <code>set_node</code> </p><p>由于在 <code>__deque_iterator</code> 移动时可能会跨越数组, 所以需要重新设定指向数组指针的位置, <code>set_node</code> 则提供了更新指向将要前往的数组的头部位置的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_node</span><span class="params">(map_pointer new_node)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 让node指针另一个数组的头, 同时修改头和尾的地址</span></span><br><span class="line">    node = new_node;</span><br><span class="line">    first = *new_node;</span><br><span class="line">    last = first + <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="重载-和–"><a href="#重载-和–" class="headerlink" title="重载++和–"></a>重载++和–</h4><p>要注意 <code>__deque_iterator</code> 在向前或者向后移动在跨越数组时会出现越界的情况, 需要进行判断, 如果跨越了数组就要重新设置 <code>node</code> 指向的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">...  </span><br><span class="line"> <span class="comment">// 这里需要判断是否达到当前数组的尾部</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    ++cur;</span><br><span class="line">    <span class="comment">// 达到了尾部就需要更新node的指向</span></span><br><span class="line">    <span class="keyword">if</span> (cur == last) &#123;</span><br><span class="line">      <span class="built_in">set_node</span>(node + <span class="number">1</span>);</span><br><span class="line">      cur = first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 同理, 需要判断是否到达数组的头. 到达就要更新node指向</span></span><br><span class="line">  self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == first) &#123;</span><br><span class="line">      <span class="built_in">set_node</span>(node - <span class="number">1</span>);</span><br><span class="line">      cur = last;</span><br><span class="line">    &#125;</span><br><span class="line">    --cur;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  self <span class="keyword">operator</span>++(<span class="keyword">int</span>)  &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="重载-等"><a href="#重载-等" class="headerlink" title="重载+, -等"></a>重载+, -等</h4><p>由于 <code>__deque_iterator</code> 是 <code>random_access_iterator_tag</code> 类型迭代器, 所以支持   <code>+, -</code> 运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Ref</span>, <span class="keyword">class</span> <span class="title">Ptr</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">deque_iterator</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">// 重载指针</span></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *cur; &#125;</span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span> + n); &#125; <span class="comment">// 这个会调用重载+运算符</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __SGI_STL_NO_ARROW_OPERATOR</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __SGI_STL_NO_ARROW_OPERATOR */</span></span></span><br><span class="line"></span><br><span class="line">  self&amp; <span class="keyword">operator</span>+=(difference_type n) </span><br><span class="line">  &#123;</span><br><span class="line">    difference_type offset = n + (cur - first);<span class="comment">// 要移动的距离</span></span><br><span class="line">    <span class="comment">// 如果是在的当前数组内并且向前移动就直接指向那个位置就行了.</span></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; offset &lt; <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()))</span><br><span class="line">      cur += n;</span><br><span class="line">     <span class="comment">// 向后移动或已经不再当前数组中</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算需要跨多少个数组</span></span><br><span class="line">      difference_type node_offset = offset &gt; <span class="number">0</span> ? offset / <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) : -<span class="built_in">difference_type</span>((-offset - <span class="number">1</span>) / <span class="built_in">buffer_size</span>()) - <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">set_node</span>(node + node_offset);</span><br><span class="line">      cur = first + (offset - node_offset * <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 以下都是调用+运算符</span></span><br><span class="line">difference_type <span class="keyword">operator</span>-(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">difference_type</span>(<span class="built_in">buffer_size</span>()) * (node - x.node - <span class="number">1</span>) + (cur - first) + (x.last - x.cur);</span><br><span class="line">  &#125;</span><br><span class="line">  self <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp += n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self&amp; <span class="keyword">operator</span>-=(difference_type n) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> += -n; &#125;</span><br><span class="line"> </span><br><span class="line">  self <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    self tmp = *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp -= n;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> cur == x.cur; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == x); &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> self&amp; x) <span class="keyword">const</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> (node == x.node) ? (cur &lt; x.cur) : (node &lt; x.node);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="deque-结构"><a href="#deque-结构" class="headerlink" title="deque 结构"></a>deque 结构</h2><h3 id="基本类型定义"><a href="#基本类型定义" class="headerlink" title="基本类型定义"></a>基本类型定义</h3><p><code>deque</code> 满足  <code>traits</code> 编程的嵌套定义类型.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line"><span class="keyword">public</span>:                         </span><br><span class="line">    <span class="comment">// 满足traits编程 可以利用 traits 来获取关于容器的基础信息</span></span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:                        </span><br><span class="line">   <span class="comment">// 定义迭代器 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*, BufSiz&gt;              iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;, BufSiz&gt;  const_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_NON_TYPE_TMPL_PARAM_BUG */</span></span></span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, T&amp;, T*&gt;                      iterator;</span><br><span class="line">  <span class="keyword">typedef</span> __deque_iterator&lt;T, <span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T*&gt;          const_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_NON_TYPE_TMPL_PARAM_BUG */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反向迭代器</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator, value_type, const_reference, </span><br><span class="line">                           difference_type&gt;  </span><br><span class="line">          const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator, value_type, reference, difference_type&gt;</span><br><span class="line">          reverse_iterator; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line">    <span class="comment">// map, 指向指针的指针 用来记录数组的地址</span></span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;<span class="comment">// value_type类型的空间配置器</span></span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;pointer, Alloc&gt; map_allocator;<span class="comment">// 指针类型的空间配置器</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>map_pointer</code> 是一个 <strong>指向指针的指针</strong> 用来管理 <code>deque</code> 中数组的数据</p><h3 id="构造和析构函数"><a href="#构造和析构函数" class="headerlink" title="构造和析构函数"></a>构造和析构函数</h3><p><strong>构造函数</strong> 有多种重载函数, 接受许多类型的创建 <code>deque</code> 的方式, 不过可以发现绝大部分的构造函数都会调用 <code>create_map_and_nodes</code> 这个方法, 其就是构造函数的核心, 在下面将会进行分析</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                        </span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="built_in">deque</span>() : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 接受一个deque</span></span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">const</span> deque&amp; x) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(x.<span class="built_in">size</span>());</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), start);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_map_and_nodes</span>());</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 接受 n:初始化大小, value:初始化的值</span></span><br><span class="line">  <span class="built_in">deque</span>(size_type n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> value_type&amp; value) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, value);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 接受 n:初始化大小</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">deque</span><span class="params">(size_type n)</span> : start(), finish(), map(<span class="number">0</span>), map_size(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="built_in">fill_initialize</span>(n, <span class="built_in">value_type</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">    <span class="comment">//利用两个 InputIterator 类型迭代器范围内的元素进行初始化</span></span><br><span class="line">    <span class="comment">// 前提是可以使用成员模板</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="built_in">deque</span>(InputIterator first, InputIterator last) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">range_initialize</span>(first, last, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">  <span class="built_in">deque</span>(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(last - first);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, start);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_map_and_nodes</span>());</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 接受两个迭代器, 构造一个范围</span></span><br><span class="line">  <span class="built_in">deque</span>(const_iterator first, const_iterator last) : <span class="built_in">start</span>(), <span class="built_in">finish</span>(), <span class="built_in">map</span>(<span class="number">0</span>), <span class="built_in">map_size</span>(<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">create_map_and_nodes</span>(last - first);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, start);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_map_and_nodes</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="create-map-and-nodes-函数实现"><a href="#create-map-and-nodes-函数实现" class="headerlink" title="create_map_and_nodes 函数实现."></a>create_map_and_nodes 函数实现.</h4><ol><li><p>计算初始化时需要容纳多少元素</p></li><li><p>在默认开辟的空间和第一步中的空间取 <code>max</code> 保证 <code>dqeue</code> 在向前和向后扩展数组时都有空间</p></li><li><p>计算出初始时最前面数组和最后面数组的位置, 这里给两个位置前面预留的空间为 <code>(map_size - num_nodes) / 2</code> 保证了前后预留空间都相同</p></li><li><p>为已经确定的空间范围**(最前和最后两个数组之间)** 都分配一个 <code>buffer_size</code> 的数组</p></li><li><p>将 <code>start</code> 和 <code>finish</code> 中的 <code>cur</code> 指向所对应的数组, 并更新 <code>first, lasr</code> , 即将 <code>start</code> 和 <code>finish</code> 指向第一个元素和最后一个元素的位置</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">create_map_and_nodes</span>(size_type num_elements) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 计算初始化类型参数的个数</span></span><br><span class="line">  size_type num_nodes = num_elements / <span class="built_in">buffer_size</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 因为deque是头尾插入都是O(1), 就是deque在头和尾都留有空间方便头尾插入</span></span><br><span class="line">    <span class="comment">// 两者取最大的. num_nodes是保证前后都留有位置</span></span><br><span class="line">  map_size = <span class="built_in">max</span>(<span class="built_in">initial_map_size</span>(), num_nodes + <span class="number">2</span>);</span><br><span class="line">  map = map_allocator::<span class="built_in">allocate</span>(map_size);<span class="comment">// 分配空间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算出数组的头前面留出来的位置保存并在nstart.</span></span><br><span class="line">  map_pointer nstart = map + (map_size - num_nodes) / <span class="number">2</span>;</span><br><span class="line">  map_pointer nfinish = nstart + num_nodes - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY </span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// 为每一个a[cur]分配一个buffer_size的数组, 即这样就实现了二维数组即map</span></span><br><span class="line">    <span class="keyword">for</span> (cur = nstart; cur &lt;= nfinish; ++cur)</span><br><span class="line">      *cur = <span class="built_in">allocate_node</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer n = nstart; n &lt; cur; ++n)</span><br><span class="line">      <span class="built_in">deallocate_node</span>(*n);</span><br><span class="line">    map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line"><span class="comment">// 修改start, finish, cur指针的位置</span></span><br><span class="line">  start.<span class="built_in">set_node</span>(nstart);</span><br><span class="line">  finish.<span class="built_in">set_node</span>(nfinish);</span><br><span class="line">  start.cur = start.first;</span><br><span class="line">  finish.cur = finish.first + num_elements % <span class="built_in">buffer_size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="range-initialize-函数"><a href="#range-initialize-函数" class="headerlink" title="range_initialize 函数"></a>range_initialize 函数</h4><p>虽然 <code>deque</code> 的 <code>iterator</code> 是 <code>random_access_iterator_tag</code> 类型, 但是在执行构造函数时可能接收到的是 <code>list</code> 或其他容器的迭代器, 就会通过该方法来确定如何向 <code>deque</code> 内部添加元素</p><p>这种设计考虑了不同迭代器的差异, 迭代器要 <strong>向下兼容</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">range_initialize</span>(InputIterator first,</span><br><span class="line">                                                InputIterator last,</span><br><span class="line">                                                input_iterator_tag) &#123;</span><br><span class="line">  <span class="built_in">create_map_and_nodes</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 一个个进行插入操作</span></span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">    <span class="built_in">push_back</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">range_initialize</span>(ForwardIterator first,</span><br><span class="line">                                                ForwardIterator last,</span><br><span class="line">                                                forward_iterator_tag) &#123;</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算距离, 申请空间. 失败则释放所有空间</span></span><br><span class="line">  <span class="built_in">distance</span>(first, last, n);</span><br><span class="line">  <span class="built_in">create_map_and_nodes</span>(n);</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="built_in">uninitialized_copy</span>(first, last, start);</span><br><span class="line">  &#125;</span><br><span class="line">  __STL_UNWIND(<span class="built_in">destroy_map_and_nodes</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fill-initialize-函数"><a href="#fill-initialize-函数" class="headerlink" title="fill_initialize 函数"></a>fill_initialize 函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">fill_initialize</span>(size_type n, <span class="keyword">const</span> value_type&amp; value) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">  <span class="built_in">create_map_and_nodes</span>(n);</span><br><span class="line">  map_pointer cur;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">      <span class="comment">//对每个空间进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (cur = start.node; cur &lt; finish.node; ++cur)</span><br><span class="line">      <span class="built_in">uninitialized_fill</span>(*cur, *cur + <span class="built_in">buffer_size</span>(), value);</span><br><span class="line">      <span class="comment">// 最后一个数组单独处理. 毕竟最后一个数组一般不是会全部填充满</span></span><br><span class="line">    <span class="built_in">uninitialized_fill</span>(finish.first, finish.cur, value);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (map_pointer n = start.node; n &lt; cur; ++n)</span><br><span class="line">      <span class="built_in">destroy</span>(*n, *n + <span class="built_in">buffer_size</span>());</span><br><span class="line">    <span class="built_in">destroy_map_and_nodes</span>();</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="析构函数-分步释放内存"><a href="#析构函数-分步释放内存" class="headerlink" title="析构函数, 分步释放内存."></a>析构函数, 分步释放内存.</h3><ul><li>释放开辟的各个数组内的元素</li><li>释放记录数组地址的数组空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">   ~<span class="built_in">deque</span>() &#123;</span><br><span class="line">    <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">    <span class="built_in">destroy_map_and_nodes</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>deque</code>是一个”二维数组”并且每个数组之间并不连续, 所以需要一个数组一个数组的执行释放.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This is only used as a cleanup function in catch clauses.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">destroy_map_and_nodes</span>() &#123;</span><br><span class="line"><span class="comment">// 便利所有的数组, 一个个析构</span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt;= finish.node; ++cur)</span><br><span class="line">    <span class="built_in">deallocate_node</span>(*cur);</span><br><span class="line">    <span class="comment">// 内存释放</span></span><br><span class="line">  map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">  pointer <span class="built_in">allocate_node</span>() &#123; <span class="keyword">return</span> data_allocator::<span class="built_in">allocate</span>(<span class="built_in">buffer_size</span>()); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deallocate_node</span><span class="params">(pointer n)</span> </span>&#123;</span><br><span class="line">    data_allocator::<span class="built_in">deallocate</span>(n, <span class="built_in">buffer_size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="deque基本属性获取方法"><a href="#deque基本属性获取方法" class="headerlink" title="deque基本属性获取方法"></a>deque基本属性获取方法</h3><p><code>deque</code> 的 <code>first</code> 指向第一个元素的地址, <code>finish</code> 指向最后一个元素的后一个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Internal typedefs</span></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 获取缓冲区大小</span></span><br><span class="line">  <span class="keyword">static</span> size_type <span class="built_in">buffer_size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> __deque_buf_size(BufSiz, <span class="built_in"><span class="keyword">sizeof</span></span>(value_type));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> size_type <span class="title">initial_map_size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">8</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Data members</span></span><br><span class="line">  iterator start;<span class="comment">// 指向第一个元素的地址</span></span><br><span class="line">  iterator finish;<span class="comment">// 指向最后一个元素的后一个地址, 即尾</span></span><br><span class="line"></span><br><span class="line">  map_pointer map;<span class="comment">// 定义map, 指向指针的指针</span></span><br><span class="line">  size_type map_size;<span class="comment">// map的实际大小</span></span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Basic accessors</span></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;<span class="comment">// 获取头地址</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;<span class="comment">// 获取尾地址</span></span><br><span class="line">  <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"><span class="comment">// 倒转后获取首尾地址.</span></span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(finish); &#125;</span><br><span class="line">  <span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(start); &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(finish);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(start);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取第一个和最后一个元素的值</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *start; &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    const_iterator tmp = finish;</span><br><span class="line">    --tmp;</span><br><span class="line">    <span class="keyword">return</span> *tmp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish - start;; &#125; <span class="comment">// 获取数组的大小</span></span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish == start; &#125;<span class="comment">// 判断deque是否为空</span></span><br><span class="line">    </span><br><span class="line">  reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)]; &#125;</span><br><span class="line">  const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> start[<span class="built_in">difference_type</span>(n)];</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="deque-的操作符重载"><a href="#deque-的操作符重载" class="headerlink" title="deque 的操作符重载"></a>deque 的操作符重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Constructor, destructor.</span></span><br><span class="line">    <span class="comment">// 重载 = </span></span><br><span class="line">    <span class="comment">// 原deque比赋值的大, 就必须清除多余的元素, 否则就需要将多余的元素进行插入</span></span><br><span class="line">  deque&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> deque&amp; x) &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type len = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (&amp;x != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 清楚原deque的多余元素</span></span><br><span class="line">      <span class="keyword">if</span> (len &gt;= x.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">copy</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), start), finish);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        const_iterator mid = x.<span class="built_in">begin</span>() + <span class="built_in">difference_type</span>(len);</span><br><span class="line">        <span class="built_in">copy</span>(x.<span class="built_in">begin</span>(), mid, start);</span><br><span class="line">        <span class="built_in">insert</span>(finish, mid, x.<span class="built_in">end</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;        </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_NON_TYPE_TMPL_PARAM_BUG</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载==, !=, &lt;</span></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> deque&lt;T, Alloc, <span class="number">0</span>&gt;&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>() == x.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">equal</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), x.<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> deque&lt;T, Alloc, <span class="number">0</span>&gt;&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">size</span>() != x.<span class="built_in">size</span>() || !<span class="built_in">equal</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), x.<span class="built_in">begin</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> deque&lt;T, Alloc, <span class="number">0</span>&gt;&amp; x) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>(), x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_NON_TYPE_TMPL_PARAM_BUG */</span></span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> deque&lt;T, Alloc, BufSiz&gt;&amp; x,</span><br><span class="line">                <span class="keyword">const</span> deque&lt;T, Alloc, BufSiz&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">equal</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> deque&lt;T, Alloc, BufSiz&gt;&amp; x,</span><br><span class="line">               <span class="keyword">const</span> deque&lt;T, Alloc, BufSiz&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="deque-的-元素操作"><a href="#deque-的-元素操作" class="headerlink" title="deque 的 元素操作"></a>deque 的 元素操作</h2><h3 id="push-pop"><a href="#push-pop" class="headerlink" title="push, pop"></a>push, pop</h3><p>由于 <code>deque</code> 都可以实现双向操作 所以其 <code>push</code>, <code>pop</code> 的操作都类似于 <code>list</code> 的 <code>push</code> 和 <code>pop</code> 操作, 但是由于 <code>list</code> 采用链表实现, 所以不会涉及到容器边界的判断, 而由于 <code>deque</code> 是利用不连续的数组来实现元素的存储, 所以在插入和弹出数据是需要对边界线进行判断</p><h4 id="push-实现"><a href="#push-实现" class="headerlink" title="push 实现"></a>push 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         </span><br><span class="line">    <span class="comment">// 对尾进行插入</span></span><br><span class="line">    <span class="comment">// 判断函数是否达到了数组尾部. 没有达到就直接进行插入</span></span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">push_back</span>(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.last - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(finish.cur, t);</span><br><span class="line">      ++finish.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">push_back_aux</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 对头进行插入</span></span><br><span class="line">    <span class="comment">// 判断函数是否达到了数组头部. 没有达到就直接进行插入</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">const</span> value_type&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.first) &#123;</span><br><span class="line">      <span class="built_in">construct</span>(start.cur - <span class="number">1</span>, t);</span><br><span class="line">      --start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">push_front_aux</span>(t);</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果在 <code>push</code> 操作中发现数组越界的情况, 就移动到相应的下一个数组进行 <code>push</code> 操作, 其是调用 <code>push_front(back)_aux</code> 方法来实现, 这个辅助方法会在后面进行介绍</p><h4 id="push-front-back-aux"><a href="#push-front-back-aux" class="headerlink" title="push_front(back)_aux"></a>push_front(back)_aux</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called only if finish.cur == finish.last - 1.</span></span><br><span class="line"><span class="comment">// 到达了数组的尾部</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_back_aux</span>(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  <span class="built_in">reserve_map_at_back</span>();</span><br><span class="line">  <span class="comment">// 申请空间</span></span><br><span class="line">  *(finish.node + <span class="number">1</span>) = <span class="built_in">allocate_node</span>();</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">  <span class="comment">// 执行构造</span></span><br><span class="line">    <span class="built_in">construct</span>(finish.cur, t_copy);</span><br><span class="line">    <span class="comment">// 移动node, 指向下一个数组的头</span></span><br><span class="line">    finish.<span class="built_in">set_node</span>(finish.node + <span class="number">1</span>);</span><br><span class="line">    finish.cur = finish.first;<span class="comment">// cur只指向当前数组的头</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果分配失败, 释放掉该内存</span></span><br><span class="line">  __STL_UNWIND(<span class="built_in">deallocate_node</span>(*(finish.node + <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called only if start.cur == start.first.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">push_front_aux</span>(<span class="keyword">const</span> value_type&amp; t) &#123;</span><br><span class="line">  value_type t_copy = t;</span><br><span class="line">  <span class="built_in">reserve_map_at_front</span>();</span><br><span class="line">  <span class="comment">// 申请空间</span></span><br><span class="line">  *(start.node - <span class="number">1</span>) = <span class="built_in">allocate_node</span>();</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">  <span class="comment">// 先要移动node, 让其指向上一个数组的尾部</span></span><br><span class="line">    start.<span class="built_in">set_node</span>(start.node - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// cur指向当前数组的尾部</span></span><br><span class="line">    start.cur = start.last - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 执行构造</span></span><br><span class="line">    <span class="built_in">construct</span>(start.cur, t_copy);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">    start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);</span><br><span class="line">    start.cur = start.first;</span><br><span class="line">    <span class="built_in">deallocate_node</span>(*(start.node - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#     <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里要注意, 由于在尾部插入的时候, 是判断的插入的位置是不是该数组的最后一个位置, 也即 <code>finish</code> 是指向的最后一个元素的后一个地址, 而 <code>first</code> 当前指向的位置是有元素的, 所以 <code>push_back</code> 是先执行构造再移动 <code>node</code>, <code>push_front</code> 则是先移动 <code>node</code> 再进行构造, 下面 <code>pop</code> 也是同理 </p><h4 id="pop-实现"><a href="#pop-实现" class="headerlink" title="pop 实现"></a>pop 实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="comment">// 对尾部进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否达到数组的头部. 没有到达就直接释放</span></span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">pop_back</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (finish.cur != finish.first) &#123;</span><br><span class="line">      --finish.cur;</span><br><span class="line">      <span class="built_in">destroy</span>(finish.cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">pop_back_aux</span>();</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 对头部进行操作</span></span><br><span class="line">    <span class="comment">// 判断是否达到数组的尾部. 没有到达就直接释放</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start.cur != start.last - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">destroy</span>(start.cur);</span><br><span class="line">      ++start.cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">      <span class="built_in">pop_front_aux</span>();</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="pop判断越界后执行-pop-xxx-aux-方法"><a href="#pop判断越界后执行-pop-xxx-aux-方法" class="headerlink" title="pop判断越界后执行 pop_xxx_aux 方法"></a>pop判断越界后执行 <code>pop_xxx_aux</code> 方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called only if finish.cur == finish.first.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;:: <span class="built_in">pop_back_aux</span>() &#123;</span><br><span class="line">  <span class="built_in">deallocate_node</span>(finish.first);<span class="comment">// 先调用析构函数</span></span><br><span class="line">  finish.<span class="built_in">set_node</span>(finish.node - <span class="number">1</span>);<span class="comment">// 再移动node</span></span><br><span class="line">  finish.cur = finish.last - <span class="number">1</span>;<span class="comment">// 然后cur指向当前数组的最后位置</span></span><br><span class="line">  <span class="built_in">destroy</span>(finish.cur);<span class="comment">// 最后释放内存空间.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Called only if start.cur == start.last - 1.  Note that if the deque</span></span><br><span class="line"><span class="comment">//  has at least one element (a necessary precondition for this member</span></span><br><span class="line"><span class="comment">//  function), and if start.cur == start.last, then the deque must have</span></span><br><span class="line"><span class="comment">//  at least two nodes.</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">pop_front_aux</span>() &#123;</span><br><span class="line">  <span class="built_in">destroy</span>(start.cur);<span class="comment">// 先释放内存空间.</span></span><br><span class="line">  <span class="built_in">deallocate_node</span>(start.first);<span class="comment">// 再调用析构函数</span></span><br><span class="line">  start.<span class="built_in">set_node</span>(start.node + <span class="number">1</span>);<span class="comment">// 然后移动node</span></span><br><span class="line">  start.cur = start.first;<span class="comment">// 最后cur指向当前数组的第一个位置</span></span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><p><strong>注意</strong> 这里 <code>dellocate_node</code> 函数是析构的数组空间</p><blockquote><p>reserve_map_at一类函数. pop和push都先调用了reserve_map_at_XX函数, 这些函数<br>主要是为了判断前后空间是否足够.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">void</span> <span class="built_in">new_elements_at_front</span>(size_type new_elements);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">new_elements_at_back</span><span class="params">(size_type new_elements)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy_nodes_at_front</span><span class="params">(iterator before_start)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy_nodes_at_back</span><span class="params">(iterator after_finish)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:                      <span class="comment">// Allocation of map and nodes</span></span><br><span class="line">  <span class="comment">// Makes sure the map has space for new nodes.  Does not actually</span></span><br><span class="line">  <span class="comment">//  add the nodes.  Can invalidate map pointers.  (And consequently, </span></span><br><span class="line">  <span class="comment">//  deque iterators.)</span></span><br><span class="line"><span class="comment">// 始终保证后面要有一个及以上的空数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_back</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add + <span class="number">1</span> &gt; map_size - (finish.node - map))</span><br><span class="line">      <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 始终保证前面要有一个及以上的空数组大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reserve_map_at_front</span> <span class="params">(size_type nodes_to_add = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nodes_to_add &gt; start.node - map)</span><br><span class="line">      <span class="built_in">reallocate_map</span>(nodes_to_add, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reallocate_map</span><span class="params">(size_type nodes_to_add, <span class="keyword">bool</span> add_at_front)</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="对于-reallocate-map-方法"><a href="#对于-reallocate-map-方法" class="headerlink" title="对于 reallocate_map 方法"></a>对于 reallocate_map 方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">reallocate_map</span>(size_type nodes_to_add, <span class="keyword">bool</span> add_at_front) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 保存现在的空间大小和新的空间大小</span></span><br><span class="line">  size_type old_num_nodes = finish.node - start.node + <span class="number">1</span>;</span><br><span class="line">  size_type new_num_nodes = old_num_nodes + nodes_to_add;</span><br><span class="line"></span><br><span class="line">  map_pointer new_nstart;</span><br><span class="line">    <span class="comment">// map_size &gt; 2 * new_num_nodes 发现deque空间还很充足就只是调整deque内部的元素就行了, 没必要重新开空间</span></span><br><span class="line">    <span class="comment">// 这种情况主要出现在一直往首或尾单方向插入元素, 导致首(尾)前面还有很多余留的空间, 这种情况就这样调整</span></span><br><span class="line">  <span class="keyword">if</span> (map_size &gt; <span class="number">2</span> * new_num_nodes) &#123;</span><br><span class="line">    new_nstart = map + (map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (new_nstart &lt; start.node)</span><br><span class="line">      <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">copy_backward</span>(start.node, finish.node + <span class="number">1</span>, new_nstart + old_num_nodes);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 空间是真的不够了</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size_type new_map_size = map_size + <span class="built_in">max</span>(map_size, nodes_to_add) + <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 分配空间. 重新定位start的位置</span></span><br><span class="line">    map_pointer new_map = map_allocator::<span class="built_in">allocate</span>(new_map_size);</span><br><span class="line">    new_nstart = new_map + (new_map_size - new_num_nodes) / <span class="number">2</span> + (add_at_front ? nodes_to_add : <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 拷贝原deque元素, 最后释放掉原内存空间</span></span><br><span class="line">    <span class="built_in">copy</span>(start.node, finish.node + <span class="number">1</span>, new_nstart);</span><br><span class="line">    map_allocator::<span class="built_in">deallocate</span>(map, map_size);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调整map</span></span><br><span class="line">    map = new_map;</span><br><span class="line">    map_size = new_map_size;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 重新调整start, finish</span></span><br><span class="line">  start.<span class="built_in">set_node</span>(new_nstart);</span><br><span class="line">  finish.<span class="built_in">set_node</span>(new_nstart + old_num_nodes - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其是在 <code>deque</code> 空间不足时使用, 来进行扩容</p><ol><li>deque 的空间足够使用 其内部移动 <code>start</code>, <code>finish</code> 来实现, 这种情况一般是前后剩余空间失衡所进行的移动</li><li>deque 空间不足<br>i. 申请更大的空间<br>ii. 将所有元素拷贝到新的空间<br>iii. 修改原 map 的 start 和 finish 指向</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">destroy_nodes_at_front</span>(iterator before_start) &#123;</span><br><span class="line">  <span class="keyword">for</span> (map_pointer n = before_start.node; n &lt; start.node; ++n)</span><br><span class="line">    <span class="built_in">deallocate_node</span>(*n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">destroy_nodes_at_back</span>(iterator after_finish) &#123;</span><br><span class="line">  <span class="keyword">for</span> (map_pointer n = after_finish.node; n &gt; finish.node; --n)</span><br><span class="line">    <span class="built_in">deallocate_node</span>(*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">  iterator <span class="built_in">reserve_elements_at_front</span>(size_type n) &#123;</span><br><span class="line">      <span class="comment">//查看最前面的数组剩余多少空间</span></span><br><span class="line">    size_type vacancies = start.cur - start.first;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; vacancies) </span><br><span class="line">        <span class="comment">//给多出元素数量在分配足够的数组</span></span><br><span class="line">      <span class="built_in">new_elements_at_front</span>(n - vacancies);</span><br><span class="line">      <span class="comment">//返回重新添加元素后的新的 start</span></span><br><span class="line">    <span class="keyword">return</span> start - <span class="built_in">difference_type</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">  <span class="function">iterator <span class="title">reserve_elements_at_back</span><span class="params">(size_type n)</span> </span>&#123;</span><br><span class="line">    size_type vacancies = (finish.last - finish.cur) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; vacancies)</span><br><span class="line">      <span class="built_in">new_elements_at_back</span>(n - vacancies);</span><br><span class="line">    <span class="keyword">return</span> finish + <span class="built_in">difference_type</span>(n);</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">new_elements_at_front</span>(size_type new_elements) &#123;</span><br><span class="line">    <span class="comment">//计算至少需要多少数组</span></span><br><span class="line">  size_type new_nodes = (new_elements + <span class="built_in">buffer_size</span>() - <span class="number">1</span>) / <span class="built_in">buffer_size</span>();</span><br><span class="line">  <span class="built_in">reserve_map_at_front</span>(new_nodes);</span><br><span class="line">  size_type i;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">      <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= new_nodes; ++i)</span><br><span class="line">      *(start.node - i) = <span class="built_in">allocate_node</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      <span class="built_in">deallocate_node</span>(*(start.node - j));      </span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">new_elements_at_back</span>(size_type new_elements) &#123;</span><br><span class="line">  size_type new_nodes = (new_elements + <span class="built_in">buffer_size</span>() - <span class="number">1</span>) / <span class="built_in">buffer_size</span>();</span><br><span class="line">  <span class="built_in">reserve_map_at_back</span>(new_nodes);</span><br><span class="line">  size_type i;</span><br><span class="line">  __STL_TRY &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= new_nodes; ++i)</span><br><span class="line">      *(finish.node + i) = <span class="built_in">allocate_node</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">    <span class="keyword">for</span> (size_type j = <span class="number">1</span>; j &lt; i; ++j)</span><br><span class="line">      <span class="built_in">deallocate_node</span>(*(finish.node + j));      </span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>之前考虑到 <code>deque</code> 在前后实现插入时为了保证时间复杂度为 O(1), 所以在前后预留了空间, 所以 <code>push</code> 和 `pop  都可以在前面的数组进行操作</p><p>对于 <code>earse</code> 由于 <code>deque</code> 是由数组构成的, 所以地址空间是 <strong>相对连续</strong> 的, 故在删除时也要像 <code>vector</code> 一样, 要移动大量元素, <code>deque</code> 为了保证效率尽可能的高, 采用了判断删除的位置是中间偏后还是中间偏前来进行移动</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Erase</span></span><br><span class="line">  iterator <span class="built_in">erase</span>(iterator pos) </span><br><span class="line">  &#123;</span><br><span class="line">    iterator next = pos;</span><br><span class="line">    ++next;</span><br><span class="line">    difference_type index = pos - start;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏前, 移动前面的元素</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (<span class="built_in">size</span>() &gt;&gt; <span class="number">1</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">copy_backward</span>(start, pos, next);</span><br><span class="line">      <span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏后, 移动后面的元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">copy</span>(next, finish, pos);</span><br><span class="line">      <span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + index;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 范围删除, 实际也是调用上面的erase函数.</span></span><br><span class="line">  <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>; </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>erase(iterator first, iterator last)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::iterator </span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">erase</span>(iterator first, iterator last) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (first == start &amp;&amp; last == finish) &#123;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">return</span> finish;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 计算出两个迭代器的距离, 毕竟是连续的, 可以直接计算</span></span><br><span class="line">    difference_type n = last - first;</span><br><span class="line">      <span class="comment">// 同样, 选择前后哪种方法移动.</span></span><br><span class="line">    difference_type elems_before = first - start;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏前, 移动前面的元素</span></span><br><span class="line">    <span class="keyword">if</span> (elems_before &lt; (<span class="built_in">size</span>() - n) / <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="built_in">copy_backward</span>(start, first, last);</span><br><span class="line">      iterator new_start = start + n;</span><br><span class="line">      <span class="built_in">destroy</span>(start, new_start);</span><br><span class="line">        <span class="comment">// 可能会涉及到跨数组的问题(用户使用并不知道)</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = start.node; cur &lt; new_start.node; ++cur)</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">      start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 删除的地方是中间偏后, 移动后面的元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">      iterator new_finish = finish - n;</span><br><span class="line">      <span class="built_in">destroy</span>(new_finish, finish);</span><br><span class="line">        <span class="comment">// 可能会涉及到跨数组的问题(用户使用并不知道)</span></span><br><span class="line">      <span class="keyword">for</span> (map_pointer cur = new_finish.node + <span class="number">1</span>; cur &lt;= finish.node; ++cur)</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(*cur, <span class="built_in">buffer_size</span>());</span><br><span class="line">      finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start + elems_before;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clear-方法"><a href="#clear-方法" class="headerlink" title="clear 方法"></a>clear 方法</h3><p>删除所有元素, 一共有两步</p><ol><li>从第二个数组一直到倒数第二个数组, 一次性全部删除, 因为中间的数组一定是满的</li><li>删除首尾两个数组元素</li><li></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">clear</span>() &#123;</span><br><span class="line"><span class="comment">// 从第二个数组开始到倒数第二个数组一次性全部删除</span></span><br><span class="line"><span class="comment">// 毕竟中间的数组肯定都是满的, 前后两个数组就不一定是填充满的.</span></span><br><span class="line">  <span class="keyword">for</span> (map_pointer node = start.node + <span class="number">1</span>; node &lt; finish.node; ++node) &#123;</span><br><span class="line">    <span class="built_in">destroy</span>(*node, *node + <span class="built_in">buffer_size</span>());</span><br><span class="line">    data_allocator::<span class="built_in">deallocate</span>(*node, <span class="built_in">buffer_size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 删除前后两个数组的元素.</span></span><br><span class="line">  <span class="keyword">if</span> (start.node != finish.node) &#123; <span class="comment">// 防止重复释放元素</span></span><br><span class="line">    <span class="built_in">destroy</span>(start.cur, start.last);</span><br><span class="line">    <span class="built_in">destroy</span>(finish.first, finish.cur);</span><br><span class="line">    data_allocator::<span class="built_in">deallocate</span>(finish.first, <span class="built_in">buffer_size</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">destroy</span>(start.cur, finish.cur);</span><br><span class="line"></span><br><span class="line">  finish = start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h3><p><code>deque</code>的swap操作也只是交换了start, finish, map, 并没有交换所有的元素.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">swap</span>(deque&amp; x)</span><br><span class="line">        &#123;</span><br><span class="line">        __STD::<span class="built_in">swap</span>(start, x.start);</span><br><span class="line">        __STD::<span class="built_in">swap</span>(finish, x.finish);</span><br><span class="line">        __STD::<span class="built_in">swap</span>(map, x.map);</span><br><span class="line">        __STD::<span class="built_in">swap</span>(map_size, x.map_size);</span><br><span class="line">      &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSiz</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(deque&lt;T, Alloc, BufSiz&gt;&amp; x, deque&lt;T, Alloc, BufSiz&gt;&amp; y)</span> </span>&#123;</span><br><span class="line">  x.<span class="built_in">swap</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h3><p><strong>resize函数</strong>. 重新将<code>deque</code>进行调整, 实现与<code>list</code>一样的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">void</span> <span class="built_in">resize</span>(size_type new_size) &#123; <span class="built_in">resize</span>(new_size, <span class="built_in">value_type</span>()); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> size_type len = <span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 元素大小大于了要修改的大小, 则释放掉超过的元素</span></span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; len) </span><br><span class="line">      <span class="built_in">erase</span>(start + new_size, finish);</span><br><span class="line">    <span class="comment">// 元素不够, 就从end开始到要求的大小为止都初始化x</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">insert</span>(finish, new_size - len, x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><h4 id="insert-实现"><a href="#insert-实现" class="headerlink" title="insert 实现"></a>insert 实现</h4><p>先列出所有的重载方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position)</span> </span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用相同的重载函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">long</span> n, <span class="keyword">const</span> value_type&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, InputIterator first, InputIterator last)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, const_iterator first, const_iterator last)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, InputIterator first, InputIterator last, input_iterator_tag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, ForwardIterator first, ForwardIterator last,forward_iterator_tag)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>单点插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc, <span class="keyword">size_t</span> BufSiz = <span class="number">0</span>&gt; </span><br><span class="line">class deque &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">public</span>:                         <span class="comment">// Insert</span></span><br><span class="line">  iterator <span class="built_in">insert</span>(iterator position, <span class="keyword">const</span> value_type&amp; x) &#123;</span><br><span class="line">      <span class="comment">// 如果只是在头尾插入, 直接调用push就行了.</span></span><br><span class="line">    <span class="keyword">if</span> (position.cur == start.cur) &#123;</span><br><span class="line">      <span class="built_in">push_front</span>(x);</span><br><span class="line">      <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (position.cur == finish.cur) &#123;</span><br><span class="line">      <span class="built_in">push_back</span>(x);</span><br><span class="line">      iterator tmp = finish;</span><br><span class="line">      --tmp;</span><br><span class="line">      <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 随机插入</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>单位置插入多个元素</strong></p><p>**insert(iterator pos, size_type n, const value_type&amp; x) ** 在指定的位置插入n个元素并初始化.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert</span>(iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 同样判断是不是直接在头尾进行插入.</span></span><br><span class="line">  <span class="keyword">if</span> (pos.cur == start.cur) &#123;</span><br><span class="line">      <span class="comment">// 判断还有没有足够的空间</span></span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);</span><br><span class="line">    <span class="built_in">uninitialized_fill</span>(new_start, start, x); <span class="comment">// 范围初始化</span></span><br><span class="line">    start = new_start;<span class="comment">// 修改start位置</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pos.cur == finish.cur) &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);<span class="comment">// 判断还有没有足够的空间</span></span><br><span class="line">    <span class="built_in">uninitialized_fill</span>(finish, new_finish, x);<span class="comment">// 范围初始化</span></span><br><span class="line">    finish = new_finish;<span class="comment">// 修改finish位置</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 随机插入</span></span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">insert_aux</span>(pos, n, x);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">int</span> n, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(pos, (size_type) n, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, <span class="keyword">long</span> n, <span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(pos, (size_type) n, x);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>**void insert(iterator pos, InputIterator first, InputIterator last) **. 通过参数的类型选择最优, 高效率的插入方式.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator pos, InputIterator first, InputIterator last)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(pos, first, last, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// input_iterator_tag类型的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert</span>(iterator pos,InputIterator first, InputIterator last,</span><br><span class="line">input_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">copy</span>(first, last, <span class="built_in">inserter</span>(*<span class="keyword">this</span>, pos));<span class="comment">// 直接调用copy函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forward_iterator_tag类型的迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert</span>(iterator pos,ForwardIterator first,ForwardIterator last,forward_iterator_tag) </span><br><span class="line">&#123;</span><br><span class="line">  size_type n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">distance</span>(first, last, n); <span class="comment">// 计算迭代器之间的距离</span></span><br><span class="line">    <span class="comment">// 同样, 首尾插入判断</span></span><br><span class="line">  <span class="keyword">if</span> (pos.cur == start.cur) &#123;</span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, new_start);</span><br><span class="line">      start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_front</span>(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pos.cur == finish.cur) &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, finish);</span><br><span class="line">      finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_back</span>(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 随机插入</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">insert_aux</span>(pos, first, last, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert</span>(iterator pos,<span class="keyword">const</span> value_type* first,<span class="keyword">const</span> value_type* last) </span><br><span class="line">&#123;</span><br><span class="line">  size_type n = last - first;</span><br><span class="line">  <span class="keyword">if</span> (pos.cur == start.cur) &#123;</span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, new_start);</span><br><span class="line">      start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_front</span>(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pos.cur == finish.cur) &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, finish);</span><br><span class="line">      finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_back</span>(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">insert_aux</span>(pos, first, last, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert</span>(iterator pos,const_iterator first,const_iterator last)</span><br><span class="line">&#123;</span><br><span class="line">  size_type n = last - first;</span><br><span class="line">  <span class="keyword">if</span> (pos.cur == start.cur) &#123;</span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, new_start);</span><br><span class="line">      start = new_start;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_front</span>(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (pos.cur == finish.cur) &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(first, last, finish);</span><br><span class="line">      finish = new_finish;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_back</span>(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">insert_aux</span>(pos, first, last, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>insert_aux</strong></p><p>上面的每一个方法, 基本都调用了 <code>insert_aux</code> 方法, 下面就介绍一下该方法</p><p>**insert_aux(iterator pos, const value_type&amp; x) **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">typename</span> deque&lt;T, Alloc, BufSize&gt;::iterator</span><br><span class="line">deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, <span class="keyword">const</span> value_type&amp; x) </span><br><span class="line">&#123;</span><br><span class="line">  difference_type index = pos - start;</span><br><span class="line">  value_type x_copy = x;</span><br><span class="line">    <span class="comment">// 判断插入的位置离头还是尾比较近</span></span><br><span class="line">    <span class="comment">// 离头进</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">push_front</span>(<span class="built_in">front</span>());<span class="comment">// 将头往前移动</span></span><br><span class="line">      <span class="comment">// 调整将要移动的距离</span></span><br><span class="line">    iterator front1 = start;</span><br><span class="line">    ++front1;</span><br><span class="line">    iterator front2 = front1;</span><br><span class="line">    ++front2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">    iterator pos1 = pos;</span><br><span class="line">    ++pos1;</span><br><span class="line">      <span class="comment">// 用copy进行调整</span></span><br><span class="line">    <span class="built_in">copy</span>(front2, pos1, front1);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 离尾近</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">push_back</span>(<span class="built_in">back</span>());<span class="comment">// 将尾往前移动</span></span><br><span class="line">      <span class="comment">// 调整将要移动的距离</span></span><br><span class="line">    iterator back1 = finish;</span><br><span class="line">    --back1;</span><br><span class="line">    iterator back2 = back1;</span><br><span class="line">    --back2;</span><br><span class="line">    pos = start + index;</span><br><span class="line">      <span class="comment">// 用copy进行调整</span></span><br><span class="line">    <span class="built_in">copy_backward</span>(pos, back2, back1);</span><br><span class="line">  &#125;</span><br><span class="line">  *pos = x_copy;</span><br><span class="line">  <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**insert_aux(iterator pos, size_type n, const value_type&amp; x) ** </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> difference_type elems_before = pos - start;</span><br><span class="line">  size_type length = <span class="built_in">size</span>();</span><br><span class="line">  value_type x_copy = x;</span><br><span class="line">    <span class="comment">// 判断插入的位置离头还是尾比较近</span></span><br><span class="line">    <span class="comment">// 离头近</span></span><br><span class="line">  <span class="keyword">if</span> (elems_before &lt; length / <span class="number">2</span>) &#123;</span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);<span class="comment">// 新的内存空间</span></span><br><span class="line">    iterator old_start = start;</span><br><span class="line">      <span class="comment">// 计算pos的新位置</span></span><br><span class="line">    pos = start + elems_before;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="comment">// 到头的距离大于插入的个数n</span></span><br><span class="line">      <span class="keyword">if</span> (elems_before &gt;= <span class="built_in">difference_type</span>(n)) &#123;</span><br><span class="line">          <span class="comment">// 一部分一部分的进行调整</span></span><br><span class="line">        iterator start_n = start + <span class="built_in">difference_type</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(start, start_n, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">copy</span>(start_n, pos, old_start);</span><br><span class="line">        <span class="built_in">fill</span>(pos - <span class="built_in">difference_type</span>(n), pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">// 到头的距离不大于插入的个数n</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_copy_fill(start, pos, new_start, start, x_copy);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">fill</span>(old_start, pos, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_front</span>(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 离尾近. 执行都是一样的</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);</span><br><span class="line">    iterator old_finish = finish;</span><br><span class="line">    <span class="keyword">const</span> difference_type elems_after = <span class="built_in">difference_type</span>(length) - elems_before;</span><br><span class="line">    pos = finish - elems_after;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; <span class="built_in">difference_type</span>(n)) &#123;</span><br><span class="line">        iterator finish_n = finish - <span class="built_in">difference_type</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish_n, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, finish_n, old_finish);</span><br><span class="line">        <span class="built_in">fill</span>(pos, pos + <span class="built_in">difference_type</span>(n), x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        __uninitialized_fill_copy(finish, pos + <span class="built_in">difference_type</span>(n),</span><br><span class="line">                                  x_copy,</span><br><span class="line">                                  pos, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">fill</span>(pos, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_back</span>(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>剩余方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES  </span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos,</span><br><span class="line">                                          ForwardIterator first,</span><br><span class="line">                                          ForwardIterator last,</span><br><span class="line">                                          size_type n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> difference_type elems_before = pos - start;</span><br><span class="line">  size_type length = <span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (elems_before &lt; length / <span class="number">2</span>) &#123;</span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);</span><br><span class="line">    iterator old_start = start;</span><br><span class="line">    pos = start + elems_before;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_before &gt;= <span class="built_in">difference_type</span>(n)) &#123;</span><br><span class="line">        iterator start_n = start + <span class="built_in">difference_type</span>(n); </span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(start, start_n, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">copy</span>(start_n, pos, old_start);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, pos - <span class="built_in">difference_type</span>(n));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ForwardIterator mid = first;</span><br><span class="line">        <span class="built_in">advance</span>(mid, <span class="built_in">difference_type</span>(n) - elems_before);</span><br><span class="line">        __uninitialized_copy_copy(start, pos, first, mid, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">copy</span>(mid, last, old_start);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_front</span>(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);</span><br><span class="line">    iterator old_finish = finish;</span><br><span class="line">    <span class="keyword">const</span> difference_type elems_after = <span class="built_in">difference_type</span>(length) - elems_before;</span><br><span class="line">    pos = finish - elems_after;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; <span class="built_in">difference_type</span>(n)) &#123;</span><br><span class="line">        iterator finish_n = finish - <span class="built_in">difference_type</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish_n, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, finish_n, old_finish);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, pos);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ForwardIterator mid = first;</span><br><span class="line">        <span class="built_in">advance</span>(mid, elems_after);</span><br><span class="line">        __uninitialized_copy_copy(mid, last, pos, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">copy</span>(first, mid, pos);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_back</span>(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos,</span><br><span class="line">                                          <span class="keyword">const</span> value_type* first,</span><br><span class="line">                                          <span class="keyword">const</span> value_type* last,</span><br><span class="line">                                          size_type n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> difference_type elems_before = pos - start;</span><br><span class="line">  size_type length = <span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (elems_before &lt; length / <span class="number">2</span>) &#123;</span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);</span><br><span class="line">    iterator old_start = start;</span><br><span class="line">    pos = start + elems_before;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_before &gt;= <span class="built_in">difference_type</span>(n)) &#123;</span><br><span class="line">        iterator start_n = start + <span class="built_in">difference_type</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(start, start_n, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">copy</span>(start_n, pos, old_start);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, pos - <span class="built_in">difference_type</span>(n));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value_type* mid = first + (<span class="built_in">difference_type</span>(n) - elems_before);</span><br><span class="line">        __uninitialized_copy_copy(start, pos, first, mid, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">copy</span>(mid, last, old_start);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_front</span>(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);</span><br><span class="line">    iterator old_finish = finish;</span><br><span class="line">    <span class="keyword">const</span> difference_type elems_after = <span class="built_in">difference_type</span>(length) - elems_before;</span><br><span class="line">    pos = finish - elems_after;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; <span class="built_in">difference_type</span>(n)) &#123;</span><br><span class="line">        iterator finish_n = finish - <span class="built_in">difference_type</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish_n, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, finish_n, old_finish);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, pos);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> value_type* mid = first + elems_after;</span><br><span class="line">        __uninitialized_copy_copy(mid, last, pos, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">copy</span>(first, mid, pos);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_back</span>(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>, <span class="title">size_t</span> <span class="title">BufSize</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> deque&lt;T, Alloc, BufSize&gt;::<span class="built_in">insert_aux</span>(iterator pos,</span><br><span class="line">                                          const_iterator first,</span><br><span class="line">                                          const_iterator last,</span><br><span class="line">                                          size_type n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> difference_type elems_before = pos - start;</span><br><span class="line">  size_type length = <span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (elems_before &lt; length / <span class="number">2</span>) &#123;</span><br><span class="line">    iterator new_start = <span class="built_in">reserve_elements_at_front</span>(n);</span><br><span class="line">    iterator old_start = start;</span><br><span class="line">    pos = start + elems_before;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_before &gt;= n) &#123;</span><br><span class="line">        iterator start_n = start + n;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(start, start_n, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">copy</span>(start_n, pos, old_start);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, pos - <span class="built_in">difference_type</span>(n));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        const_iterator mid = first + (n - elems_before);</span><br><span class="line">        __uninitialized_copy_copy(start, pos, first, mid, new_start);</span><br><span class="line">        start = new_start;</span><br><span class="line">        <span class="built_in">copy</span>(mid, last, old_start);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_front</span>(new_start));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    iterator new_finish = <span class="built_in">reserve_elements_at_back</span>(n);</span><br><span class="line">    iterator old_finish = finish;</span><br><span class="line">    <span class="keyword">const</span> difference_type elems_after = length - elems_before;</span><br><span class="line">    pos = finish - elems_after;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">        iterator finish_n = finish - <span class="built_in">difference_type</span>(n);</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish_n, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">copy_backward</span>(pos, finish_n, old_finish);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, pos);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        const_iterator mid = first + elems_after;</span><br><span class="line">        __uninitialized_copy_copy(mid, last, pos, finish, finish);</span><br><span class="line">        finish = new_finish;</span><br><span class="line">        <span class="built_in">copy</span>(first, mid, pos);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(<span class="built_in">destroy_nodes_at_back</span>(new_finish));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>为了渐少在增加或者删除元素时移动元素所带来的时间复杂度的提升, <code>deque</code> 的设计不可谓不复杂, 但是我认为, 其是为了支持更多的功能而采用如此复杂的设计. 不过其中一些操作在我看来是不需要进行深入了解的, 比如 <code>earse</code> 以及 <code>insert</code> 操作, 其原因在于对于 <code>deque</code> 的定义<strong>双端队列</strong>的<strong>元素出入顺序就只允许首尾进出</strong>, 所以对于<code>deque</code> 设计出的随机插入, 删除, 提取元素是不符合双端队列的定义, 而且绝大多数使用者都是按照双端队列的定义来进行使用的, 我暂时没有思考出 <code>deque</code> 提供如此复杂的设计和功能是出于什么目的, 不过以后在阅读了更多的优秀源码之后, 可能会得到答案, 到时会进行分析==(预定 &lt;分析为何部分 **STL** 容器的设计复杂度远超过其定义&gt; )==.</p><p>在后续实现自己 <strong>Tiny STL</strong> 时, 考虑使用 <code>list</code> 作为适配器来实现 <code>deque</code>的功能, 其实对于 <code>stack</code> 和 <code>queue</code> 使用<code>list</code> 来实现底层容器在时间复杂度上是相对优于标准库提供的<code>deque</code>, 对于绝大多数使用者, 本质上还是在使用其定义出的结构来使用此类容器, 所以并不会设计的如此复杂, 从而考虑尽可能降低时间复杂度</p>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>queue 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/queue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/queue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h1><p><code>queue</code> 是队列, 只允许元素从队首弹出, 在队尾进入, 其也是使用 <code>deque</code> 作为默认容器, 将其功能进行封装得到的, </p><p>其可参考 <a href="https://cu1universe.icu/STL-%E6%BA%90%E7%A0%81/stack-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">stack</a></p><h2 id="queue-结构"><a href="#queue-结构" class="headerlink" title="queue 结构"></a>queue 结构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> deque&lt;T&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span> &#123;</span></span><br><span class="line">  <span class="comment">//定义友元函数</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> queue&amp; x, <span class="keyword">const</span> queue&amp; y);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> queue&amp; x, <span class="keyword">const</span> queue&amp; y);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="comment">// 调用 deque 的 front 方法</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="comment">// 由于只提供前出后入的功能, 所以只封装了 push_back, pop_front函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_front</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现重载</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> queue&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>queue</code>与<code>stack</code>都是使用底层接口封装的结构, 他们是被称为配接器而不是容器.</p>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/stack-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/stack-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h1><p><code>stack</code> 是栈, 它只允许在元素在栈顶进出, 而且在实现 <code>stack</code> 这个数据结构的时候, 我们发现, 似乎有一个数据结构已经满足了 <code>stack</code> 只允许元素在尾部进出的功能, 就是 <code>deque</code>, 它已经实现了在头尾都允许元素进出的功能, 所以只需要将 <code>deque</code> 封装一下即也就提取出 <code>pop_back</code>,  <code>push_back</code> 就行了. 其实, 不只是 <code>deque</code> , 只要是提供了 <code>pop_back</code>,  <code>push_back</code> 功能的数据结构即可, <code>list</code> 也提供了这些方法. </p><p>由此发现, <code>stack</code>严格来说并不是容器, 它是一底部容器完成其所有的工作, 它只修改了容器的接口, 准确是叫<strong>配接器</strong>.</p><h2 id="stack-源码"><a href="#stack-源码" class="headerlink" title="stack 源码"></a>stack 源码</h2><p><code>stack</code>也满足<code>straits</code>编程规范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">stack</span> &#123;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>== __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> stack&amp;, <span class="keyword">const</span> stack&amp;);</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt; __STL_NULL_TMPL_ARGS (<span class="keyword">const</span> stack&amp;, <span class="keyword">const</span> stack&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125; <span class="comment">//调用容器的 empty()</span></span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125; <span class="comment">//调用容器的 size()</span></span><br><span class="line">  <span class="function">reference <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125; <span class="comment">//调用容器的 push_back</span></span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">back</span>(); &#125;</span><br><span class="line">  <span class="comment">// 只封装了 push_back和pop_back 方法, 只对尾进行操作</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123; c.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c.<span class="built_in">pop_back</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用容器自己的运算符重载方法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c == y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>&gt;</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; x, <span class="keyword">const</span> stack&lt;T, Sequence&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.c &lt; y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>严格来说 <code>stack</code> 是适配器, 就是修改其他容器提供的功能, 同样 <code>queue</code> 也是以 <code>deque</code> 为默认容器的适配器</p>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板方法模式</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><h2 id="应对问题"><a href="#应对问题" class="headerlink" title="应对问题"></a>应对问题</h2><p>在项目构建过程中, 对于某一些问题, 都是有着稳定的整体操作结构, 但是在各个子步骤中却有着许多的改变需求, 并且由于某些原因不能将子任务和整体结构同时实现</p><p>比如对于一个应用程序具有 5 个步骤</p><p><a href="https://imgtu.com/i/HR0VNn"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/15/HR0VNn.png" alt="HR0VNn.png"></a></p><p>作为 Library 开发人员, 设计了整个应用程序的架构和整体步骤, 但是对于 2, 4 步骤, 并不能知道作为程序开发者将如何实现这些步骤,  所以可以使用 <strong>模板方法模式</strong> 来保证流程的稳定</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><blockquote><p>定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟(变化)到子类中。Template Method使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤                                                                                                                                ——《设计模式》GoF</p></blockquote><h2 id="结构-Structure"><a href="#结构-Structure" class="headerlink" title="结构 (Structure)"></a>结构 (Structure)</h2><p><a href="https://imgtu.com/i/HRc8s0"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/15/HRc8s0.png" alt="HRc8s0.png"></a></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于整个算法(程序的某个任务)的具体骨架是稳定的, 但是对于其中某些步骤并不稳定的话, 可以设计一个抽象类, 将稳定的部分以及整体流程设计出来, 并将不稳定的, 变化的部分交给程序发开者通过继承的方式进行扩展</p><h3 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h3><p>Library 开发者提供一个抽象类 来提供整个程序的流程骨架以及部分稳定的步骤过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">lass Library&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//template method</span></span><br><span class="line">    <span class="comment">// 整体骨架流程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Step1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Step2</span>()) &#123; </span><br><span class="line">            <span class="built_in">Step3</span>(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="built_in">Step4</span>(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Step5</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">Library</span>()&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 这些步骤是要组合成一个流程来进行使用的, 在大部分情况下单独使用没有意义&#x27;</span></span><br><span class="line"><span class="comment">    * 故不开放给外部调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step1</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Step5</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Library 事先并不知道应用者要如何实现这些步骤, </span></span><br><span class="line"><span class="comment">     * 所以将这两个步骤以纯虚函数的方式定义, 待应用开发者进行实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>=<span class="number">0</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="application-开发者"><a href="#application-开发者" class="headerlink" title="application 开发者"></a>application 开发者</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承 Library 并提供自己对于步骤 2 4 的实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Application</span> :</span> <span class="keyword">public</span> Library &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Step2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Step4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="主程序中使用"><a href="#主程序中使用" class="headerlink" title="主程序中使用"></a>主程序中使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Library* pLib=<span class="keyword">new</span> <span class="built_in">Application</span>();</span><br><span class="line">    lib-&gt;<span class="built_in">Run</span>();</span><br><span class="line"><span class="keyword">delete</span> pLib;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="要点总结"><a href="#要点总结" class="headerlink" title="要点总结"></a>要点总结</h2><ul><li><p>Template Method 模式是一种非常基础的设计模式, 在面向对象系统中有着大量的应用. 它使用最简洁的机制 (虚函数的多态性) 为很多应用程序框架提供了灵活的扩展点, 是代码复用方面的基本实现结构</p></li><li><p>除了可以灵活应对子步骤的变化外, “不要调用我, 让我来调用你” 的反向控制结构是 Template Method 的典型应用.</p></li><li><p>在具体实现方面, 被 Template Method 调用的虚方法可以具有实现, 也可以没有任何实现 (抽象方法, 纯虚方法),  但一般推荐将它们设置为 protected 方法</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>heap 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/heap/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/heap/</url>
      
        <content type="html"><![CDATA[<h1 id="STL-中的-heap"><a href="#STL-中的-heap" class="headerlink" title="STL 中的 heap"></a>STL 中的 heap</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>源码来自 <code>SIGSTL3.0</code></p><p>在看之前默认你已经拥有了关于 <strong>堆, 大小根堆, 堆排序</strong> 等前置知识. <strong>heap</strong> 严格来说并不属于容器, 它只是实现关于对操作的一些模板函数, 故没有迭代器和遍历等操作</p><h2 id="heap-作用描述"><a href="#heap-作用描述" class="headerlink" title="heap 作用描述"></a>heap 作用描述</h2><ul><li><p>将一段序列转换为满足堆的性质(大根堆或者小根堆)</p></li><li><p>进行堆排序</p></li><li><p>向上维护堆的性质</p></li><li><p>取出堆顶元素</p></li></ul><h2 id="heap-分析"><a href="#heap-分析" class="headerlink" title="heap 分析"></a>heap 分析</h2><h3 id="push-插入元素"><a href="#push-插入元素" class="headerlink" title="push 插入元素"></a><strong>push</strong> 插入元素</h3><p>插入函数为 <code>push_heap</code> 由于堆排序是不稳定的以及可能需要交换两个不连续位置的值 所以 <code>heap</code> 只接受 <code>RandomAccessIterator</code> 类型的迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __push_heap_aux(first, last, <span class="built_in">distance_type</span>(first), <span class="built_in">value_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __push_heap_aux(RandomAccessIterator first, RandomAccessIterator last, Distance*, T*) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里传入的是两个迭代器的长度, 0, 还有最后一个数据</span></span><br><span class="line">  __push_heap(first, <span class="built_in">Distance</span>((last - first) - <span class="number">1</span>), <span class="built_in">Distance</span>(<span class="number">0</span>),  <span class="built_in">T</span>(*(last - <span class="number">1</span>)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到 <code>push_heap</code> 作为接口函数调用了 <code>__push_heap_aux</code>  而它又作为接口函数封装了<code>__push_heap</code> 不难发现 <code>__push_heap</code> 就是 <code>push</code> 操作的核心代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __push_heap(RandomAccessIterator first, Distance holeIndex,Distance topIndex, T value) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//取得要调整的叶子节点的上级节点</span></span><br><span class="line">  Distance parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 这里判断的是当前没有达到堆顶并且传入的值大于根节点的值, 那就将根节点下移</span></span><br><span class="line">  <span class="keyword">while</span> (holeIndex &gt; topIndex &amp;&amp; *(first + parent) &lt; value) &#123;</span><br><span class="line">      <span class="comment">// 将根节点下移</span></span><br><span class="line">    *(first + holeIndex) = *(first + parent);</span><br><span class="line">    holeIndex = parent;</span><br><span class="line">    parent = (holeIndex - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">  &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将数组插入到合适的位置, 可能是根也可能是叶</span></span><br><span class="line">  *(first + holeIndex) = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>这里的插入和一般上看到的入堆是有一些出入的, 我更倾向于把它看作一种自底向上的堆调整方式. </p></li><li><p><code>holeIndex</code> 作为的是要新数字的叶子节点位置 它可以是任意一个叶子节点, 正如它的名字一样 <strong>空洞下标</strong>  所以对于 <code>__push_heap</code> 函数要做的就是待这个空出的叶子节点的值确定之后 向上调整维护堆的性质即可, 但是在 <code>__push_heap_aux</code> 封装的过程中, 参数默认为<strong>该段序列的最后一个位置</strong>, 对应到满二叉树上即为<strong>最后一个叶子节点</strong> </p><p>这里可以对照下面的图理解一下</p><p><a href="https://imgtu.com/i/Hy8b3q"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/14/Hy8b3q.png" alt="Hy8b3q.png"></a></p><p>  当然也可以令其他叶子节点为空然后向上维护堆的性质 如下图</p><p><a href="https://imgtu.com/i/Hy8qg0"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/14/Hy8qg0.png" alt="Hy8qg0.png"></a></p><p>所以 <code>__push_heap</code> 函数的本质就是在一个固定大小的堆里维护某一个叶子节点到堆顶节点的链去保证整个堆的性质</p></li></ul><h3 id="pop-弹出元素"><a href="#pop-弹出元素" class="headerlink" title="pop 弹出元素"></a>pop 弹出元素</h3><p><code>pop</code> 操作用于弹出堆顶元素 并继续维护其余元素满足堆的性质 但是 <code>pop</code> 操作并没有真正意义上把元素删除掉，而是将顶部元素覆盖掉, 将多出的 <strong>(按照弹出前后逻辑上的元素数量比较)</strong> 放置在最后并不指向该元素 <code>pop</code> 的实现有两种, 一种是按照标准库默认的优先级判断实现, 另一种则是按照用户自己传入的 <strong>仿函数</strong>中自定义的判断标准, 判断优先级. 这里将两种实现都列举出来, 但只会以第一种方式作为例子进行分析.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                     Compare comp)</span> </span>&#123;</span><br><span class="line">    __pop_heap_aux(first, last, <span class="built_in">value_type</span>(first), comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap_aux(RandomAccessIterator first, </span><br><span class="line">                  RandomAccessIterator last, T*, Compare comp) &#123;</span><br><span class="line">  __pop_heap(first, last - <span class="number">1</span>, last - <span class="number">1</span>, <span class="built_in">T</span>(*(last - <span class="number">1</span>)), comp,</span><br><span class="line">             <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(RandomAccessIterator first,    RandomAccessIterator last,</span><br><span class="line">                       RandomAccessIterator result, T value, </span><br><span class="line">                       Compare comp, Distance*) &#123;</span><br><span class="line">  *result = *first;</span><br><span class="line">  __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), </span><br><span class="line">                value, comp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> __pop_heap(RandomAccessIterator first,             RandomAccessIterator last,</span><br><span class="line">           RandomAccessIterator result, T value, Distance*) &#123;</span><br><span class="line">  *result = *first;<span class="comment">// 因为这里是大根堆, 所以first的值就是最大值, 先将最大值保存.</span></span><br><span class="line">  __adjust_heap(first, <span class="built_in">Distance</span>(<span class="number">0</span>), <span class="built_in">Distance</span>(last - first), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>依旧可以看出 <code>pop</code> 操作是在 <code>__pop_heap</code> 函数上进行了两次封装. 故只需要去分析 <code>__pop_heap</code> 函数即可</li></ul><p>这里重点分析第一个种形式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __adjust_heap(RandomAccessIterator first, Distance holeIndex, Distance len, T value) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// holeIndex传入的是0</span></span><br><span class="line">  Distance topIndex = holeIndex;</span><br><span class="line">    <span class="comment">// secondChild是右孩子的一个节点</span></span><br><span class="line">  Distance secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (secondChild &lt; len) &#123;</span><br><span class="line">      <span class="comment">// 比较左右节点, 根节点较下就将根节点下移, 比较大的节点上移</span></span><br><span class="line">    <span class="keyword">if</span> (*(first + secondChild) &lt; *(first + (secondChild - <span class="number">1</span>)))</span><br><span class="line">      secondChild--;</span><br><span class="line">    *(first + holeIndex) = *(first + secondChild);</span><br><span class="line">    holeIndex = secondChild;</span><br><span class="line">      <span class="comment">// 下一个左右节点</span></span><br><span class="line">    secondChild = <span class="number">2</span> * (secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (secondChild == len) &#123;</span><br><span class="line">      <span class="comment">// 没有右节点就找左节点并且上移</span></span><br><span class="line">    *(first + holeIndex) = *(first + (secondChild - <span class="number">1</span>));</span><br><span class="line">    holeIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 重新调整堆</span></span><br><span class="line">  __push_heap(first, holeIndex, topIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// cmpare版本只将比较修改成用户定义的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Distance</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __adjust_heap(RandomAccessIterator first, Distance holeIndex,</span><br><span class="line">                   Distance len, T value, Compare comp) &#123;</span><br><span class="line">  Distance topIndex = holeIndex;</span><br><span class="line">  Distance secondChild = <span class="number">2</span> * holeIndex + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">while</span> (secondChild &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">comp</span>(*(first + secondChild), *(first + (secondChild - <span class="number">1</span>))))</span><br><span class="line">      secondChild--;</span><br><span class="line">    *(first + holeIndex) = *(first + secondChild);</span><br><span class="line">    holeIndex = secondChild;</span><br><span class="line">    secondChild = <span class="number">2</span> * (secondChild + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (secondChild == len) &#123;</span><br><span class="line">    *(first + holeIndex) = *(first + (secondChild - <span class="number">1</span>));</span><br><span class="line">    holeIndex = secondChild - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  __push_heap(first, holeIndex, topIndex, value, comp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>__pop_heap</code> 函数的本质就是在维护堆性质的情况下去把原堆顶进行覆盖, 然后再以覆盖堆顶的某个儿子作为堆顶再重复这个操作, 直到某个叶子节点为空时, 利用 <code>__push_heap</code> 函数将<strong>原来堆的最后一个叶子节点补充进这个空叶子节点并向上维护新的堆</strong> 即可 这时可以发现在堆的最后依旧会留有一个值为操作堆之前的数据, 但是由于弹出了堆顶元素, 所以堆的规模在逻辑上是减小了 1 的, 所以对于最后一个多出的元素无论是什么都是无关紧要的</li></ul><p>上面描述的比较绕, 具体可以看下面的图理解一下</p><ul><li><a href="https://imgtu.com/i/Hy8LvV"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/14/Hy8LvV.png" alt="Hy8LvV.png"></a>有一种特殊情况即为当空洞到达最后一个叶子节点的父节点时, 由于不能比较左右儿子的大小去选择使哪个节点为空, 所以只能选择左儿子为空</li></ul><p><a href="https://imgtu.com/i/Hy8HCn"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/14/Hy8HCn.png" alt="Hy8HCn.png"></a></p><p>在调整完毕后, 调用 <code>__push_heap</code> 函数去把最后一个叶子节点的值放入之前被置空的叶子节点后进行调整使剩下的完全二叉树满足堆的性质</p><ul><li><p>结合上面的图可以发现, <strong>除去置空点为根的子树</strong> , 以<strong>置空点左右儿子为根的子树</strong>  均满足堆的性质</p><p>当置空点为叶子节点时, 其余元素依旧构成了堆(由于该节点只是被逻辑置空 所以依旧可以认为当前是一棵完全二叉树)  所以只需要将最后一个叶子节点填入该置空叶子节点并维护其与堆顶的链, 就可以得到一个堆</p></li></ul><p>这时再结合上面的 <code>__push_heap</code> 函数的分析, 其实可以更好的理解它的思想. 从最后插入堆只是前面的 <code>push</code> 的一种情况而已, 而 <code>__push_heap</code> 的设计可以让它不只可以处理入堆操作, 也实现了修改维护堆性质的功能, 从而使用这项功能支持了 <code>pop</code> 操作的实现</p><h3 id="分割线-—————————————————————————"><a href="#分割线-—————————————————————————" class="headerlink" title="分割线 —————————————————————————-"></a>分割线 —————————————————————————-</h3><p>下面的两种操作</p><ul><li>建堆 </li><li>堆排序</li></ul><p>它们的实现与日常中见到的实现就基本没有差异了</p><h3 id="make-heap函数-将数组变为堆存放"><a href="#make-heap函数-将数组变为堆存放" class="headerlink" title="make_heap函数, 将数组变为堆存放."></a>make_heap函数, 将数组变为堆存放.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  __make_heap(first, last, <span class="built_in">value_type</span>(first), <span class="built_in">distance_type</span>(first));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> __make_heap(RandomAccessIterator first, RandomAccessIterator last, T*,</span><br><span class="line">                 Distance*) &#123;</span><br><span class="line">  <span class="keyword">if</span> (last - first &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 计算长度, 并找出中间的根值</span></span><br><span class="line">  Distance len = last - first;</span><br><span class="line">  Distance parent = (len - <span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="comment">// 一个个进行调整, 放到后面</span></span><br><span class="line">    __adjust_heap(first, parent, len, <span class="built_in">T</span>(*(first + parent)));</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    parent--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sort-堆排序其实就是每次将第一位数据弹出从而实现排序功能"><a href="#sort-堆排序其实就是每次将第一位数据弹出从而实现排序功能" class="headerlink" title="sort, 堆排序其实就是每次将第一位数据弹出从而实现排序功能."></a>sort, 堆排序其实就是每次将第一位数据弹出从而实现排序功能.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) <span class="built_in">pop_heap</span>(first, last--);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">RandomAccessIterator</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomAccessIterator first, RandomAccessIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">               Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (last - first &gt; <span class="number">1</span>) <span class="built_in">pop_heap</span>(first, last--, comp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="heap-总结"><a href="#heap-总结" class="headerlink" title="heap 总结"></a>heap 总结</h3><p><code>heap</code> 没有自己的迭代器, 甚至它都不能被称作一个容器, 我认为比较合适的说法是将支持 <code>RandomAccessIterator</code> 的容器进行堆的操作. <code>heap</code> 中最重要的就是 <code>pop</code> 和 <code>push</code> 的实现</p><p>而且需要注意的是, <code>push</code> 操作在堆的最后进行插入时, 是要容器构建好最后一个位置的空间和值的</p><p><code>push</code> 操作本质还是用于维护插入后堆的性质的</p>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>priority_queue 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/priority_queue/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/priority_queue/</url>
      
        <content type="html"><![CDATA[<h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前分析的 <code>heap</code> 是为了分析 <code>priority_queue</code> 做准备, <code>priority_queue </code> 是一个堆优先队列, 支持插入和删除元素,  但是对于插入和删除进行了限制, 对于插入只能在堆的最后进行插入, 只能获取和删除堆顶元素, 由于<code>priority_queue</code> 也是队列的一种体现, 所以为了<strong>维护队列</strong>的特性, 不提供迭代器以进行遍历操作. 同时它也不能被严格称作容器, 它是以支持<code>RandomAccessIterator</code> 类型迭代器容器和 <code>heap</code> 支持对容器数据进行堆操作的一个配置器</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __STL_LIMITED_DEFAULT_TEMPLATES</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span> =</span> vector&lt;T&gt;, </span><br><span class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;<span class="keyword">typename</span> Sequence::value_type&gt; &gt;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Sequence</span>, <span class="keyword">class</span> <span class="title">Compare</span>&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 符合traits编程规范</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::value_type value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::size_type size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::reference reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> Sequence::const_reference const_reference;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  Sequence c;<span class="comment">// 定义vector容器的对象</span></span><br><span class="line">  Compare comp;<span class="comment">// 定义比较函数(伪函数)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 <code>Sequence</code> 也可以是 <code>deque</code> 因为 <code>deque</code> 也支持 <code>RandomAccessIterator</code> 类型迭代器</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">priority_queue</span>() : <span class="built_in">c</span>() &#123;&#125;<span class="comment">// 默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">priority_queue</span><span class="params">(<span class="keyword">const</span> Compare&amp; x)</span> :  c(), comp(x) &#123;</span>&#125;<span class="comment">// 设置伪函数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_MEMBER_TEMPLATES</span></span><br><span class="line">    <span class="comment">// 接受以迭代器类型的参数</span></span><br><span class="line">    <span class="comment">// 接受两个迭代器以及函数. 传入的迭代器范围内表示的元素以comp定义的方式进行调整</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last, <span class="keyword">const</span> Compare&amp; x)</span><br><span class="line">    : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line">    <span class="comment">// 接受两个迭代器. 传入的迭代器范围内表示的元素以标准库默认的优先级进行调整</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line">  <span class="built_in">priority_queue</span>(InputIterator first, InputIterator last) </span><br><span class="line">    : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">     <span class="comment">// 接受两个迭代器以及函数. 传入的迭代器范围内表示的元素以comp定义的方式进行调整</span></span><br><span class="line">  <span class="built_in">priority_queue</span>(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last, </span><br><span class="line">                 <span class="keyword">const</span> Compare&amp; x) : <span class="built_in">c</span>(first, last), <span class="built_in">comp</span>(x) &#123;</span><br><span class="line">    <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 接受两个迭代器. 传入的迭代器范围内表示的元素以标准库默认的优先级进行调整</span></span><br><span class="line">  <span class="built_in">priority_queue</span>(<span class="keyword">const</span> value_type* first, <span class="keyword">const</span> value_type* last) </span><br><span class="line">    : <span class="built_in">c</span>(first, last) &#123; <span class="built_in">make_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_MEMBER_TEMPLATES */</span></span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><p><code>priority_queue</code> 有三种获取其内部值的方法, 都是封装了 <code>Sequence</code> 的方法和 <code>heap</code> 中的函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">empty</span>(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">size</span>(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c.<span class="built_in">front</span>(); &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="push和pop实现"><a href="#push和pop实现" class="headerlink" title="push和pop实现"></a>push和pop实现</h3><p><strong>push</strong> 和 <strong>pop</strong> 具体都是采用的<code>heap</code>算法.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">priority_queue</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> value_type&amp; x)</span> </span>&#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      c.<span class="built_in">push_back</span>(x); </span><br><span class="line">        <span class="comment">// 间接使用heap算法</span></span><br><span class="line">      <span class="built_in">push_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">     <span class="comment">// 间接使用heap算法</span></span><br><span class="line">      <span class="built_in">pop_heap</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>(), comp);</span><br><span class="line">      c.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(c.<span class="built_in">clear</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>priority_queue</code> 本身实现是很复杂的, 但是其内部都是封装了 <code>Sequence</code>, <code>heap </code>, 就比较简单明了, 就是将 <code>Sequence</code> 作为容器,  <code>heap</code> 作为算法来操作的配置器, 这也体现了STL的灵活性是很高的, 通过各个容器与算法的结合就能做出另一种功能的结构.</p>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式(Singleton Pattern)"></a>单例模式(Singleton Pattern)</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>​    该设计模式属于创建型模式, 其意图是保证一个类仅有一个实例, 并提供一个可以访问它的全局访问点, 保证所有的程序都可以访问该类所提供的唯一 一个实例.</p><p>对于概念的部分, 本文并不过多叙述, 主要还是侧重于代码层面的问题</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><a href="https://imgtu.com/i/Hywy4O"><img src="https://s1.ax1x.com/2022/05/01/OCJm2n.gif" data-original="https://s4.ax1x.com/2022/02/14/Hywy4O.png" alt="Hywy4O.png"></a></p><h3 id="如果要构建一个单例模式"><a href="#如果要构建一个单例模式" class="headerlink" title="如果要构建一个单例模式:"></a>如果要构建一个单例模式:</h3><ol><li>要使其构造函数私有化, 保证不会在类外被其他程序创建</li><li>使用静态变量或者静态指针定义或指向该唯一对象</li><li>使用一个 public 静态方法来获取该对象</li></ol><h2 id="最简单的懒汉型单例模式"><a href="#最简单的懒汉型单例模式" class="headerlink" title="最简单的懒汉型单例模式"></a>最简单的懒汉型单例模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//****数据****</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> Singleton* p;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//1</span></span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">Singleton</span>(); <span class="comment">//2</span></span><br><span class="line">        <span class="keyword">return</span> p; <span class="comment">//3 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;;</span><br><span class="line">    ~<span class="built_in">Singleton</span>() &#123; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​    如果刚开始看起来这种型式的单例模式, 可能会认为这种写法是比较正确的. 事实上, 如果在只考虑单线程的情况下, 这种代码模式是正确的, 可是当在多线程的环境下, 当线程 Ⅰ 进入步骤 1 但是还没有执行步骤 2 时, 时间片耗尽, 此时 p 依旧是一个 <code>nullptr</code>  此时当线程 Ⅱ 在步骤 1 时发现, p 为空指针, 所以它也会进入步骤 2, 这就导致了该对象被多次创建, 这就违反了单例模式的设计原则,  并且会导致第一次创建对象的地址丢失, 导致内存泄漏, 于是考虑出加锁的形式来限制</p><h2 id="线程安全模式"><a href="#线程安全模式" class="headerlink" title="线程安全模式"></a>线程安全模式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程安全版本，但锁的代价过高</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双检查锁机制"><a href="#双检查锁机制" class="headerlink" title="双检查锁机制"></a>双检查锁机制</h2><p>这个版本是线程安全的, 但是对于单例模式, 读操作是可以同时发生的, 只有写操作是需要保证只有一次操作的, 但是这个版本的代码则无论是否是读操作或是写操作, 都要进行加锁, 这样就导致了加锁的性能消耗过大</p><p>所以对于根据读写操作进行加锁的思想, 引出了 <strong>双检查锁机制</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双检查锁，但由于内存读写reorder不安全</span></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        Lock lock;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span>) &#123; </span><br><span class="line">            p = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于双检查锁机制,  可能会有这样的疑问, 既然已经检查过 p 是否为空了, 为什么还要检查一次呢? 不妨模拟一下多线程环境下对于这段代码的访问顺序, 不难发现, 虽然在 p 为空时进行了加锁, 但是依旧可以有多个线程同时进入第 4 行, 既然进入了第 4 行, 如果不再进行检查, 即使加锁, 不同的线程也会在拿到锁之后执行完第一个 <code>if(p==nullptr)</code> 中的代码, 依旧会出现该对象被多次创建的问题, 所以双检查锁机制是必要的</p><h2 id="C-11版本之后的跨平台实现-volatile"><a href="#C-11版本之后的跨平台实现-volatile" class="headerlink" title="C++ 11版本之后的跨平台实现 (volatile)"></a>C++ 11版本之后的跨平台实现 (volatile)</h2><p>在使用了双检查锁机制后, 对于单例模式的实现似乎就已经无懈可击了, 不过在后来的使用中, 这种实现则被发现并不是绝对正确的. 问题的来源来自于编译器的优化方式, 对于不同版本的编译器, 其在底层创建对象的时候, 可能并不是先构造对象内存空间, 然后调用构造函数, 而是可能以某一种顺序执行, 这就带来了问题.</p><p>由于构造对象的过程并不是原子操作, 所以当线程第一次创建对象时, 时间片耗尽, 另一线程要去获取该对象, 由于此时 p 已经不为空, 则将会把一个没有进行初始化的对象返回, 从而导致错误, 为了解决这个问题,  <strong>c++ 11</strong> 中采用了原子操作的方式</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C++ 11版本之后的跨平台实现 (volatile)</span></span><br><span class="line">std::atomic&lt;Singleton*&gt; Singleton::m_instance;</span><br><span class="line">std::mutex Singleton::m_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Singleton* tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);<span class="comment">//获取内存fence</span></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        tmp = m_instance.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (tmp == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> Singleton;</span><br><span class="line">            std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);<span class="comment">//释放内存fence</span></span><br><span class="line">            m_instance.<span class="built_in">store</span>(tmp, std::memory_order_relaxed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方式实现又太过复杂, 由于 <strong>c++11</strong> 之后在创建对象时强制将其设置为原子操作, 故直接使用下面的简略写法即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Singleton <span class="title">Singleton::getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector 源码分析</title>
      <link href="/STL-%E6%BA%90%E7%A0%81/vector/"/>
      <url>/STL-%E6%BA%90%E7%A0%81/vector/</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p><code>vector</code> 是 <strong>STL</strong> 实现的一个动态数组类本文只是分析 <code>vector</code> 的结构以及一些重要的设计方法, 对于一些没有那么重要的方法或者函数将一笔掠过, 如果想仔细了解, 请自行阅读源码</p><p><code>vector</code> 的内容主要定义在 <code>stl_vector.h</code> 中, 该文件只是定义了 <code>vector</code> 对象以及相应类方法, 而且由于不直接透露 <code>vector</code> 的实现, 对其进行了一次封装, 将 <code>stl_vector.h</code> 与它所需要的头文件组合成<code>vector.h</code>, 直接使用 <code>stl_vector.h</code> 会缺少 <code>vector</code> 所依赖的函数或者方法的定义以及实现</p><h2 id="定义部分"><a href="#定义部分" class="headerlink" title="定义部分"></a>定义部分</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span> =</span> alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type; </span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer; </span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* iterator;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type* const_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> value_type&amp; reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span> size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span> difference_type;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __STL_CLASS_PARTIAL_SPECIALIZATION</span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator&gt; reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;const_iterator, value_type, const_reference, </span><br><span class="line">                           difference_type&gt;  const_reverse_iterator;</span><br><span class="line">  <span class="keyword">typedef</span> reverse_iterator&lt;iterator, value_type, reference, difference_type&gt;</span><br><span class="line">          reverse_iterator;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __STL_CLASS_PARTIAL_SPECIALIZATION */</span></span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> simple_alloc&lt;value_type, Alloc&gt; data_allocator;</span><br></pre></td></tr></table></figure><ul><li><p>  <code>reverse_iterator</code> 为反向迭代器, 即 移动方向与正向迭代器相反</p></li><li><p>  <code>simple_alloc&lt;value_type, Alloc&gt; </code>  进行对象内存的构造以及释放</p></li><li><p>  在 <code>SGI_2.91</code> 中 <code>vector</code> 的迭代器就是原始的指针</p></li></ul><h2 id="vector-对象"><a href="#vector-对象" class="headerlink" title="vector 对象"></a><strong>vector</strong> 对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iterator start;</span><br><span class="line">iterator finish;</span><br><span class="line">iterator end_of_storage;</span><br></pre></td></tr></table></figure><ul><li><p>  <code>start </code>动态数组的起始地址</p></li><li><p>  <code>finish</code> 最后一个数据的下一个位置</p></li><li><p>  <code>end_of_storage</code> 整个动态数组最大容量位置的后一个位置</p></li><li><p>  可以看出 <code>vector</code> 本身并不是内含一个数组, 而且指向堆中一块内存的指针</p></li></ul><h2 id="获取基本数据"><a href="#获取基本数据" class="headerlink" title="获取基本数据"></a>获取基本数据</h2><h3 id="获取迭代器"><a href="#获取迭代器" class="headerlink" title="获取迭代器"></a>获取迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> start; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> finish; &#125;</span><br></pre></td></tr></table></figure><h3 id="获取反向迭代器"><a href="#获取反向迭代器" class="headerlink" title="获取反向迭代器"></a>获取反向迭代器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">reverse_iterator <span class="title">rbegin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">end</span>()); &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rbegin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">end</span>()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">reverse_iterator <span class="title">rend</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">reverse_iterator</span>(<span class="built_in">begin</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_reverse_iterator <span class="title">rend</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">const_reverse_iterator</span>(<span class="built_in">begin</span>()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取容器基本信息"><a href="#获取容器基本信息" class="headerlink" title="获取容器基本信息"></a>获取容器基本信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//容器大小</span></span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="built_in">end</span>() - <span class="built_in">begin</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器最大大小 最多可以记录 size_type(-1) 个字节 / 单个元素大小 </span></span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(<span class="number">-1</span>) / <span class="built_in"><span class="keyword">sizeof</span></span>(T); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前容器的容量</span></span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">size_type</span>(end_of_storage - <span class="built_in">begin</span>()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() == <span class="built_in">end</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一个元素</span></span><br><span class="line"><span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *<span class="built_in">begin</span>(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后一个元素</span></span><br><span class="line"><span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *(<span class="built_in">end</span>() - <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure><h2 id="vector-构造方法"><a href="#vector-构造方法" class="headerlink" title="vector 构造方法"></a>vector 构造方法</h2><h3 id="无参构造"><a href="#无参构造" class="headerlink" title="无参构造"></a>无参构造</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>() : <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>这里可以看出 <code>vector</code> 并没有预留出容量,  而是默认容量为空</p><p>下面这些构造方法都是调用了 <code>fill_initialize</code> 方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将容器初始化为长度为 n 且值均为 value </span></span><br><span class="line"><span class="built_in">vector</span>(size_type n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面方法的 int 型重载</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面方法的 long 型重载</span></span><br><span class="line"><span class="built_in">vector</span>(<span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; value) &#123; <span class="built_in">fill_initialize</span>(n, value); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造长度为 n 且所有元素值均为该类型默认构造值, 而且要求在创建对象的时候显示调用该构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">vector</span><span class="params">(size_type n)</span> </span>&#123; <span class="built_in">fill_initialize</span>(n, <span class="built_in">T</span>()); &#125;</span><br></pre></td></tr></table></figure><p>上面的有参构造全部都调用了 <code>fill_initialize</code> 的辅助方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_initialize</span><span class="params">(size_type n, <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">start = <span class="built_in">allocate_and_fill</span>(n, value);</span><br><span class="line">finish = start + n;</span><br><span class="line">end_of_storage = finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先使用内存分配函数 <code>allocate_and_fill</code> 建立了一块长度为 $n$ 且值为 $value$ 的空间, 并将其赋值给 $start$ , $finish$ 为最后一个元素的下一个位置,  <code>end_of_storage</code> 此时为 $n$ 该容器被初始化为容量为 $n$ 且拥有 $n$ 个值为 $value$  的元素</p><h3 id="拷贝构造方法"><a href="#拷贝构造方法" class="headerlink" title="拷贝构造方法"></a>拷贝构造方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">    start = <span class="built_in">allocate_and_copy</span>(x.<span class="built_in">end</span>() - x.<span class="built_in">begin</span>(), x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">    finish = start + (x.<span class="built_in">end</span>() - x.<span class="built_in">begin</span>());</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  其本质就是调用 <code>allocate_and_copy</code> 函数来将要被拷贝的 <code>vector</code> 内元素赋值给当前创建的对象, 但是只是接收了被拷贝对象的元素值, <strong>并没有拷贝被拷贝对象的容量(仔细观察一下)</strong></li></ul><h3 id="接受一个范围来进行初始化的构造方法"><a href="#接受一个范围来进行初始化的构造方法" class="headerlink" title="接受一个范围来进行初始化的构造方法"></a>接受一个范围来进行初始化的构造方法</h3><p>如果定义允许使用类成员模板, 那么该构造方法就为接受一个输入型迭代器所表示的范围进行初始化, 代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="built_in">vector</span>(InputIterator first, InputIterator last) :</span><br><span class="line">    <span class="built_in">start</span>(<span class="number">0</span>), <span class="built_in">finish</span>(<span class="number">0</span>), <span class="built_in">end_of_storage</span>(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">range_initialize</span>(first, last, <span class="built_in">iterator_category</span>(first));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了 <code>range_initialize</code> 函数来进行范围的初始化 第三个参数表示将会根据迭代种类来实例化合适的范围初始化函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(InputIterator first, InputIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                    input_iterator_tag)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> ( ; first != last; ++first)</span><br><span class="line">        <span class="comment">//这个方法暂且不表 后文会提到</span></span><br><span class="line">  <span class="built_in">push_back</span>(*first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">range_initialize</span><span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                        forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(first, last, n);</span><br><span class="line">    start = <span class="built_in">allocate_and_copy</span>(n, first, last);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>  如果是 <code>InputIterator</code> 类型迭代器, 那么只能采用一次向前移动一个单位</p></li><li><p>  如果是 <code>ForwardIterator</code> 类型迭代器, 那么就可以采取范围拷贝的方式来进行范围初始化</p></li></ul><p>如果当前不允许使用类成员模板, 那么构造方法就为接受当前 <code>vector </code> 的迭代器表示的范围进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>(const_iterator first, const_iterator last) &#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里没有直接计算迭代器距离, 而是调用了 distance 因为不是所有迭代器都可以直接做减法来计算距离</span></span><br><span class="line">    <span class="built_in">distance</span>(first, last, n);</span><br><span class="line">    start = <span class="built_in">allocate_and_copy</span>(n, first, last);</span><br><span class="line">    finish = start + n;</span><br><span class="line">    end_of_storage = finish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">vector</span>() &#123; </span><br><span class="line">    <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  没什么特别, 内部调用了内存管理的函数来对内存进行释放 相对没有那么重要</li></ul><h2 id="reserve-方法-重新设定容器大小"><a href="#reserve-方法-重新设定容器大小" class="headerlink" title="reserve 方法(重新设定容器大小)"></a>reserve 方法(重新设定容器大小)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reserve</span><span class="params">(size_type n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">capacity</span>() &lt; n) &#123;</span><br><span class="line">        <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">        iterator tmp = <span class="built_in">allocate_and_copy</span>(n, start, finish);</span><br><span class="line">        <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">        <span class="built_in">deallocate</span>();</span><br><span class="line">        start = tmp;</span><br><span class="line">        finish = tmp + old_size;</span><br><span class="line">        end_of_storage = start + n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  该方法仅在要求重新设定的容器大小大于当前容器的最大容量时才会生效, 本质就是将重新开辟一块空间为 $n$ 的空间并将元素复制进去, 同时释放原来指向的空间, 并更新容器内所维护的数组块内存信息</li></ul><h2 id="交换方法-swap"><a href="#交换方法-swap" class="headerlink" title="交换方法 swap()"></a>交换方法 swap()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(vector&lt;T, Alloc&gt;&amp; x)</span> </span>&#123;</span><br><span class="line">    __STD::<span class="built_in">swap</span>(start, x.start);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(finish, x.finish);</span><br><span class="line">    __STD::<span class="built_in">swap</span>(end_of_storage, x.end_of_storage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>  vector 没有选择交换内存空间的数据, 而是选择了交换维护元素空间的信息,  提高了效率</li></ul><h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><p>该部分分为 <strong>插入数据</strong> 和 <strong>删除数据</strong> 两方面来进行剖析</p><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>首先先介绍进行辅助插入数据的函数, 或者说 <code>vector</code> 提供的 <code>public</code> 的插入数据方式都是以这些函数为底层实现</p><h4 id="insert-aux-iterator-position-const-T-amp-x"><a href="#insert-aux-iterator-position-const-T-amp-x" class="headerlink" title="insert_aux(iterator position, const T&amp; x);"></a>insert_aux(iterator position, const T&amp; x);</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert_aux</span>(iterator position, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">    <span class="built_in">construct</span>(finish, *(finish - <span class="number">1</span>));</span><br><span class="line">    ++finish;</span><br><span class="line">    T x_copy = x;</span><br><span class="line">    <span class="built_in">copy_backward</span>(position, finish - <span class="number">2</span>, finish - <span class="number">1</span>);</span><br><span class="line">    *position = x_copy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">const</span> size_type len = old_size != <span class="number">0</span> ? <span class="number">2</span> * old_size : <span class="number">1</span>;</span><br><span class="line">    iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">    iterator new_finish = new_start;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">      new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">      <span class="built_in">construct</span>(new_finish, x);</span><br><span class="line">      ++new_finish;</span><br><span class="line">      new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#       <span class="meta-keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">    <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">      <span class="built_in">destroy</span>(new_start, new_finish); </span><br><span class="line">      data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">      <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#       <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">    <span class="built_in">destroy</span>(<span class="built_in">begin</span>(), <span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">deallocate</span>();</span><br><span class="line">    start = new_start;</span><br><span class="line">    finish = new_finish;</span><br><span class="line">    end_of_storage = new_start + len;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数为要插入的迭代器的位置, 以及要插入的值.   插入要分两种情况</p><ul><li><p>  如果没有到达了容器的最大容量, 如果没有就将最后一个元素向后移动一个位置, 再将 <strong>position</strong> 到原来最后一个元素的前一个元素向后复制一个位置, 这样就在 <strong>position</strong>, 位置置空, 此时再插入要插入的元素即可</p></li><li><p>  如果到达了容器的最大容量, 那么就要开辟一块容量大小为当前最大容量两倍的空间作为容器将要管理的空间, 并将 <strong>begin 到position - 1</strong> 位置的元素复制到新的位置, 同时在 <strong>position</strong> 位置插入要插入的元素, 再将剩下的元素复制进新的容器内, 并将原容器的内存释放</p></li><li><p>  可以发现, <strong>vecotr</strong> 在扩容时会预留比原来最大容量多一倍的容量以应对之后的元素加入</p></li></ul><h4 id="push-back"><a href="#push-back" class="headerlink" title="push_back"></a>push_back</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, x);</span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insert_aux</span>(<span class="built_in">end</span>(), x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">insert</span><span class="params">(iterator position, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    size_type n = position - <span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">if</span> (finish != end_of_storage &amp;&amp; position == <span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="built_in">construct</span>(finish, x);</span><br><span class="line">        ++finish;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insert_aux</span>(position, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">begin</span>() + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法就是以 <strong>insert_aux</strong> 为底层来实现, 来实现在指定位置或者最后位置插入数据</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>下面的 <strong>insert</strong> 等方法都是将多个元素或者某个范围内的元素插入某个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, size_type n, <span class="keyword">const</span> T&amp; x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) &#123;</span><br><span class="line">      T x_copy = x;</span><br><span class="line">      <span class="keyword">const</span> size_type elems_after = finish - position;</span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 如果 pos 到 finish 的元素数量 &gt; n 那么就可以直接通过移动来空出 n 个元素的位置</span></span><br><span class="line"><span class="comment">       * 否则就先再最后补出 n - elems_after 个元素, 然后将要移动的元素移动补出元素的 end() </span></span><br><span class="line"><span class="comment">       * 的最后位置, 这样即空出了 n 个元素的位置</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish - n, finish, finish);</span><br><span class="line">        finish += n;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);</span><br><span class="line">        <span class="built_in">fill</span>(position, position + n, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">uninitialized_fill_n</span>(finish, n - elems_after, x_copy);</span><br><span class="line">        finish += n - elems_after;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);</span><br><span class="line">        finish += elems_after;</span><br><span class="line">        <span class="built_in">fill</span>(position, old_finish, x_copy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();        </span><br><span class="line">      <span class="keyword">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">      iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">      iterator new_finish = new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_fill_n</span>(new_finish, n, x);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">ifdef</span>  __STL_USE_EXCEPTIONS </span></span><br><span class="line">      <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">      <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">      <span class="built_in">deallocate</span>();</span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理其实与 <strong>insert_aux</strong> 类似, 都是先检查剩余空间够不够插入要求插入的元素数量, 如果足够就再次考虑需要将多少元素向后移动, 如果剩余空间不足以插入要求插入的元素数量, 那么就将进行扩容, 同时扩容大小是插入数据数量与原容器最大容量的 <strong>max</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面 insert 方法的重载方法, 都是以调用 insert 方法实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(iterator pos, <span class="keyword">int</span> n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(pos, (size_type) n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span> <span class="params">(iterator pos, <span class="keyword">long</span> n, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">insert</span>(pos, (size_type) n, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="range-insert"><a href="#range-insert" class="headerlink" title="range_insert"></a>range_insert</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">range_insert</span>(iterator pos,</span><br><span class="line">                                    InputIterator first, InputIterator last,</span><br><span class="line">                                    input_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">for</span> ( ; first != last; ++first) &#123;</span><br><span class="line">    pos = <span class="built_in">insert</span>(pos, *first);</span><br><span class="line">    ++pos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用了上面的 <strong>insert</strong>  方法来依次将该范围内元素插入 由于是 <strong>InputIterator</strong> 迭代器所以选择的是一次向前移动一步</p><p>该方法还有 <strong>ForwardIterator</strong> 迭代器的重载方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">ForwardIterator</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">range_insert</span>(iterator position,</span><br><span class="line">                                    ForwardIterator first,</span><br><span class="line">                                    ForwardIterator last,</span><br><span class="line">                                    forward_iterator_tag) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//比上面的 insert 多了一步通过计算迭代器之间的距离来计算要插入的元素数量</span></span><br><span class="line">    <span class="built_in">distance</span>(first, last, n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) &#123;</span><br><span class="line">      <span class="keyword">const</span> size_type elems_after = finish - position;</span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish - n, finish, finish);</span><br><span class="line">        finish += n;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, position);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        ForwardIterator mid = first;</span><br><span class="line">        <span class="built_in">advance</span>(mid, elems_after);</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(mid, last, finish);</span><br><span class="line">        finish += n - elems_after;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);</span><br><span class="line">        finish += elems_after;</span><br><span class="line">        <span class="built_in">copy</span>(first, mid, position);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">      iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">      iterator new_finish = new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(first, last, new_finish);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">      <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">      <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">      <span class="built_in">deallocate</span>();</span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现思想及其原理与多个元素插入方法类似, 这里就不进行赘述</p><p>在禁用类成员模板的情况下, <strong>vector</strong> 也提供了相应的将两个迭代器之间的元素插入当前容器的某个位置的方法</p><p>原理思想与上述无异 此处直接展示代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> vector&lt;T, Alloc&gt;::<span class="built_in">insert</span>(iterator position, </span><br><span class="line">                              const_iterator first, </span><br><span class="line">                              const_iterator last) &#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    size_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">distance</span>(first, last, n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size_type</span>(end_of_storage - finish) &gt;= n) &#123;</span><br><span class="line">      <span class="keyword">const</span> size_type elems_after = finish - position;</span><br><span class="line">      iterator old_finish = finish;</span><br><span class="line">      <span class="keyword">if</span> (elems_after &gt; n) &#123;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(finish - n, finish, finish);</span><br><span class="line">        finish += n;</span><br><span class="line">        <span class="built_in">copy_backward</span>(position, old_finish - n, old_finish);</span><br><span class="line">        <span class="built_in">copy</span>(first, last, position);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(first + elems_after, last, finish);</span><br><span class="line">        finish += n - elems_after;</span><br><span class="line">        <span class="built_in">uninitialized_copy</span>(position, old_finish, finish);</span><br><span class="line">        finish += elems_after;</span><br><span class="line">        <span class="built_in">copy</span>(first, first + elems_after, position);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> size_type old_size = <span class="built_in">size</span>();</span><br><span class="line">      <span class="keyword">const</span> size_type len = old_size + <span class="built_in">max</span>(old_size, n);</span><br><span class="line">      iterator new_start = data_allocator::<span class="built_in">allocate</span>(len);</span><br><span class="line">      iterator new_finish = new_start;</span><br><span class="line">      __STL_TRY &#123;</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(start, position, new_start);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(first, last, new_finish);</span><br><span class="line">        new_finish = <span class="built_in">uninitialized_copy</span>(position, finish, new_finish);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">ifdef</span> __STL_USE_EXCEPTIONS</span></span><br><span class="line">      <span class="built_in"><span class="keyword">catch</span></span>(...) &#123;</span><br><span class="line">        <span class="built_in">destroy</span>(new_start, new_finish);</span><br><span class="line">        data_allocator::<span class="built_in">deallocate</span>(new_start, len);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#         <span class="meta-keyword">endif</span> <span class="comment">/* __STL_USE_EXCEPTIONS */</span></span></span><br><span class="line">      <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">      <span class="built_in">deallocate</span>();</span><br><span class="line">      start = new_start;</span><br><span class="line">      finish = new_finish;</span><br><span class="line">      end_of_storage = new_start + len;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><h4 id="pop-back"><a href="#pop-back" class="headerlink" title="pop_back"></a>pop_back</h4><p>直接选择移动 <strong>end()</strong> 位置向前移动一位并将该位置元素摧毁释放掉</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    --finish;</span><br><span class="line">    <span class="built_in">destroy</span>(finish);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h4><p>该方法有重载方法, 第一个是删除某个位置元素, 而第二个是删除 <strong>first - last</strong> 范围内的元素, 代码很简单清晰</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator position)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (position + <span class="number">1</span> != <span class="built_in">end</span>())</span><br><span class="line">        <span class="built_in">copy</span>(position + <span class="number">1</span>, finish, position);</span><br><span class="line">    --finish;</span><br><span class="line">    <span class="built_in">destroy</span>(finish);</span><br><span class="line">    <span class="keyword">return</span> position;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span> </span>&#123;</span><br><span class="line">    iterator i = <span class="built_in">copy</span>(last, finish, first);</span><br><span class="line">    <span class="built_in">destroy</span>(i, finish);</span><br><span class="line">    finish = finish - (last - first);</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重新设置容器容量-resize"><a href="#重新设置容器容量-resize" class="headerlink" title="重新设置容器容量 resize()"></a>重新设置容器容量 resize()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 如果新设置的容量小于当前容量, 那么就删除掉多余元素 反之则在最后插入不足的元素数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size, <span class="keyword">const</span> T&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; <span class="built_in">size</span>()) </span><br><span class="line">        <span class="built_in">erase</span>(<span class="built_in">begin</span>() + new_size, <span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insert</span>(<span class="built_in">end</span>(), new_size - <span class="built_in">size</span>(), x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*可以发现该方法只是上面方法的重载方法, 对于没有指定修改容量后元素值的一律按照默认值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(size_type new_size)</span> </span>&#123; <span class="built_in">resize</span>(new_size, <span class="built_in">T</span>()); &#125;</span><br></pre></td></tr></table></figure><h2 id="重载运算符"><a href="#重载运算符" class="headerlink" title="重载运算符"></a>重载运算符</h2><h3 id="operator"><a href="#operator" class="headerlink" title="operator[]"></a>operator[]</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reference <span class="keyword">operator</span>[](size_type n) &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br><span class="line">const_reference <span class="keyword">operator</span>[](size_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(<span class="built_in">begin</span>() + n); &#125;</span><br></pre></td></tr></table></figure><h3 id="operator-1"><a href="#operator-1" class="headerlink" title="operator="></a>operator=</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line">vector&lt;T, Alloc&gt;&amp; vector&lt;T, Alloc&gt;::<span class="keyword">operator</span>=(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; x) &#123;</span><br><span class="line">  <span class="comment">//首先判断是不是自己赋值给自己, 如果是就不需要进行后续操作了</span></span><br><span class="line">  <span class="keyword">if</span> (&amp;x != <span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//如果被赋值对象的最大容量小于 x 对象的当前容量, 就要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (x.<span class="built_in">size</span>() &gt; <span class="built_in">capacity</span>()) &#123;</span><br><span class="line">      iterator tmp = <span class="built_in">allocate_and_copy</span>(x.<span class="built_in">end</span>() - x.<span class="built_in">begin</span>(),</span><br><span class="line">                                       x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>());</span><br><span class="line">      <span class="built_in">destroy</span>(start, finish);</span><br><span class="line">      <span class="built_in">deallocate</span>();</span><br><span class="line">      start = tmp;</span><br><span class="line">      end_of_storage = start + (x.<span class="built_in">end</span>() - x.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反之要删除掉多余元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">size</span>() &gt;= x.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      iterator i = <span class="built_in">copy</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), <span class="built_in">begin</span>());</span><br><span class="line">      <span class="built_in">destroy</span>(i, finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">copy</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">begin</span>() + <span class="built_in">size</span>(), start);</span><br><span class="line">      <span class="built_in">uninitialized_copy</span>(x.<span class="built_in">begin</span>() + <span class="built_in">size</span>(), x.<span class="built_in">end</span>(), finish);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新 end()</span></span><br><span class="line">    finish = start + x.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="operator-2"><a href="#operator-2" class="headerlink" title="operator=="></a>operator==</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大小相同且 equal(x.begin(), x.end(), y.begin()) 为真即可</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; x, <span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> x.<span class="built_in">size</span>() == y.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">equal</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="operator-lt"><a href="#operator-lt" class="headerlink" title="operator&lt;"></a>operator&lt;</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照字典序的比较规则进行比较</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; x, <span class="keyword">const</span> vector&lt;T, Alloc&gt;&amp; y) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">lexicographical_compare</span>(x.<span class="built_in">begin</span>(), x.<span class="built_in">end</span>(), y.<span class="built_in">begin</span>(), y.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> STL 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
